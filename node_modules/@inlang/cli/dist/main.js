import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// <define:ENV_DEFINED_IN_BUILD_STEP>
var define_ENV_DEFINED_IN_BUILD_STEP_default;
var init_define_ENV_DEFINED_IN_BUILD_STEP = __esm({
  "<define:ENV_DEFINED_IN_BUILD_STEP>"() {
    define_ENV_DEFINED_IN_BUILD_STEP_default = { isProduction: true };
  }
});

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @constructor
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       * @constructor
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {any} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument2;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns number
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          const visibleOptions = parentCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (globalOptionList.length > 0) {
            output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(`
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, "g");
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i2) => {
          if (line === "\n")
            return "";
          return (i2 > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {any} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {any} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {string | string[]} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {Object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        this.implied = Object.assign(this.implied || {}, impliedOptionValues);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       * @api private
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @api private
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @api private
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {any} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.splitOptionFlags = splitOptionFlags;
    exports.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i2 = 0; i2 <= a.length; i2++) {
        d[i2] = [i2];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i2 = 1; i2 <= a.length; i2++) {
          let cost = 1;
          if (a[i2 - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i2][j] = Math.min(
            d[i2 - 1][j] + 1,
            // deletion
            d[i2][j - 1] + 1,
            // insertion
            d[i2 - 1][j - 1] + cost
            // substitution
          );
          if (i2 > 1 && j > 1 && a[i2 - 1] === b[j - 2] && a[i2 - 2] === b[j - 1]) {
            d[i2][j] = Math.min(d[i2][j], d[i2 - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var EventEmitter = __require("events").EventEmitter;
    var childProcess = __require("child_process");
    var path4 = __require("path");
    var fs7 = __require("fs");
    var process2 = __require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {Object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new Command2(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {boolean|string} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {Object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {Function|*} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      /**
       * Override default decision whether to add implicit help command.
       *
       *    addHelpCommand() // force on
       *    addHelpCommand(false); // force off
       *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
       *
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      /**
       * @return {boolean}
       * @api private
       */
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @api private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @api private
       */
      _optionEx(config3, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config3.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m2 = regex.exec(val);
            return m2 ? m2[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description` and optional
       * coercion `fn`.
       *
       * The `flags` string contains the short and/or long flags,
       * separated by comma, a pipe or space. The following are all valid
       * all will output this way when `--help` is used.
       *
       *     "-p, --pepper"
       *     "-p|--pepper"
       *     "-p --pepper"
       *
       * @example
       * // simple boolean defaulting to undefined
       * program.option('-p, --pepper', 'add pepper');
       *
       * program.pepper
       * // => undefined
       *
       * --pepper
       * program.pepper
       * // => true
       *
       * // simple boolean defaulting to true (unless non-negated option is also defined)
       * program.option('-C, --no-cheese', 'remove cheese');
       *
       * program.cheese
       * // => true
       *
       * --no-cheese
       * program.cheese
       * // => false
       *
       * // required argument
       * program.option('-C, --chdir <path>', 'change the working directory');
       *
       * --chdir /tmp
       * program.chdir
       * // => "/tmp"
       *
       * // optional argument
       * program.option('-c, --cheese [type]', 'add cheese [marble]');
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {Function|*} [fn] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      /**
      * Add a required option which must have a value after parsing. This usually means
      * the option must be specified on the command line. (Otherwise the same as .option().)
      *
      * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
      *
      * @param {string} flags
      * @param {string} [description]
      * @param {Function|*} [fn] - custom option processing function or default value
      * @param {*} [defaultValue]
      * @return {Command} `this` command for chaining
      */
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
       * for unknown options.
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
       * for excess arguments.
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {Boolean} [positional=true]
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {Boolean} [passThrough=true]
       * for unknown options.
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      /**
        * Whether to store option values as properties on command object,
        * or store separately (specify false). In both cases the option values can be accessed using .opts().
        *
        * @param {boolean} [storeAsProperties=true]
        * @return {Command} `this` command for chaining
        */
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {Object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {Object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
        * Store option value and where the value came from.
        *
        * @param {string} key
        * @param {Object} value
        * @param {string} source - expected values are default/config/env/cli/implied
        * @return {Command} `this` command for chaining
        */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
        * Get source of option value.
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
        * Get source of option value. See also .optsWithGlobals().
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSourceWithGlobals(key) {
        let source;
        getCommandAndParents(this).forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @api private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process2.argv;
          if (process2.versions && process2.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * program.parse(process.argv);
       * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * await program.parseAsync(process.argv);
       * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {Object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @api private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path4.resolve(baseDir, baseName);
          if (fs7.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path4.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find((ext) => fs7.existsSync(`${localBin}${ext}`));
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs7.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path4.resolve(path4.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path4.basename(this._scriptPath, path4.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path4.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process2.exit.bind(process2));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @api private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let hookResult;
        hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
        hookResult = this._chainOrCall(hookResult, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return hookResult;
      }
      /**
       * Check this.args against expected this._args.
       *
       * @api private
       */
      _checkNumberOfArguments() {
        this._args.forEach((arg, i2) => {
          if (arg.required && this.args[i2] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this._args and save as this.processedArgs!
       *
       * @api private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {Promise|undefined} promise
       * @param {Function} fn
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @api private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            actionResult = this._chainOrCall(actionResult, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @api private
       */
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @api private
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @api private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForConflictingOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd._checkForConflictingLocalOptions();
        }
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {String[]} argv
       * @return {{operands: String[], unknown: String[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {Object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i2 = 0; i2 < len; i2++) {
            const key = this.options[i2].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {Object}
       */
      optsWithGlobals() {
        return getCommandAndParents(this).reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {Object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config3 = errorOptions || {};
        const exitCode = config3.exitCode || 1;
        const code = config3.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @api private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @api private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @api private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @api private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @api private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @api private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @api private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @api private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s2 = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s2} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @api private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Set the program version to `str`.
       *
       * This method auto-registers the "-V, --version" flag
       * which will print the version number when passed.
       *
       * You can optionally supply the  flags and description to override the defaults.
       *
       * @param {string} str
       * @param {string} [flags]
       * @param {string} [description]
       * @return {this | string} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {Object} [argsDescription]
       * @return {string|Command}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {string|Command}
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {string[]|Command}
       */
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {String|Command}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this._args.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path4.basename(filename, path4.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {string|Command}
       */
      executableDir(path5) {
        if (path5 === void 0)
          return this._executableDir;
        this._executableDir = path5;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @api private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      /**
       * You can pass in flags and a description to override the help
       * flags and help description for your command. Pass in false to
       * disable the built-in help option.
       *
       * @param {string | boolean} [flags]
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {string | Function} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports = module.exports = new Command2();
    exports.program = exports;
    exports.Argument = Argument2;
    exports.Command = Command2;
    exports.CommanderError = CommanderError2;
    exports.Help = Help2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
    exports.Option = Option2;
  }
});

// ../../node_modules/prompts/node_modules/kleur/index.js
var require_kleur = __commonJS({
  "../../node_modules/prompts/node_modules/kleur/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;
    var $ = {
      enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
      // modifiers
      reset: init3(0, 0),
      bold: init3(1, 22),
      dim: init3(2, 22),
      italic: init3(3, 23),
      underline: init3(4, 24),
      inverse: init3(7, 27),
      hidden: init3(8, 28),
      strikethrough: init3(9, 29),
      // colors
      black: init3(30, 39),
      red: init3(31, 39),
      green: init3(32, 39),
      yellow: init3(33, 39),
      blue: init3(34, 39),
      magenta: init3(35, 39),
      cyan: init3(36, 39),
      white: init3(37, 39),
      gray: init3(90, 39),
      grey: init3(90, 39),
      // background colors
      bgBlack: init3(40, 49),
      bgRed: init3(41, 49),
      bgGreen: init3(42, 49),
      bgYellow: init3(43, 49),
      bgBlue: init3(44, 49),
      bgMagenta: init3(45, 49),
      bgCyan: init3(46, 49),
      bgWhite: init3(47, 49)
    };
    function run(arr, str) {
      let i2 = 0, tmp, beg = "", end = "";
      for (; i2 < arr.length; i2++) {
        tmp = arr[i2];
        beg += tmp.open;
        end += tmp.close;
        if (str.includes(tmp.close)) {
          str = str.replace(tmp.rgx, tmp.close + tmp.open);
        }
      }
      return beg + str + end;
    }
    function chain(has, keys) {
      let ctx = { has, keys };
      ctx.reset = $.reset.bind(ctx);
      ctx.bold = $.bold.bind(ctx);
      ctx.dim = $.dim.bind(ctx);
      ctx.italic = $.italic.bind(ctx);
      ctx.underline = $.underline.bind(ctx);
      ctx.inverse = $.inverse.bind(ctx);
      ctx.hidden = $.hidden.bind(ctx);
      ctx.strikethrough = $.strikethrough.bind(ctx);
      ctx.black = $.black.bind(ctx);
      ctx.red = $.red.bind(ctx);
      ctx.green = $.green.bind(ctx);
      ctx.yellow = $.yellow.bind(ctx);
      ctx.blue = $.blue.bind(ctx);
      ctx.magenta = $.magenta.bind(ctx);
      ctx.cyan = $.cyan.bind(ctx);
      ctx.white = $.white.bind(ctx);
      ctx.gray = $.gray.bind(ctx);
      ctx.grey = $.grey.bind(ctx);
      ctx.bgBlack = $.bgBlack.bind(ctx);
      ctx.bgRed = $.bgRed.bind(ctx);
      ctx.bgGreen = $.bgGreen.bind(ctx);
      ctx.bgYellow = $.bgYellow.bind(ctx);
      ctx.bgBlue = $.bgBlue.bind(ctx);
      ctx.bgMagenta = $.bgMagenta.bind(ctx);
      ctx.bgCyan = $.bgCyan.bind(ctx);
      ctx.bgWhite = $.bgWhite.bind(ctx);
      return ctx;
    }
    function init3(open2, close) {
      let blk = {
        open: `\x1B[${open2}m`,
        close: `\x1B[${close}m`,
        rgx: new RegExp(`\\x1b\\[${close}m`, "g")
      };
      return function(txt) {
        if (this !== void 0 && this.has !== void 0) {
          this.has.includes(open2) || (this.has.push(open2), this.keys.push(blk));
          return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
        }
        return txt === void 0 ? chain([open2], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
      };
    }
    module.exports = $;
  }
});

// ../../node_modules/prompts/dist/util/action.js
var require_action = __commonJS({
  "../../node_modules/prompts/dist/util/action.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape")
        return;
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c")
          return "abort";
        if (key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      if (isSelect) {
        if (key.name === "j")
          return "down";
        if (key.name === "k")
          return "up";
      }
      if (key.name === "return")
        return "submit";
      if (key.name === "enter")
        return "submit";
      if (key.name === "backspace")
        return "delete";
      if (key.name === "delete")
        return "deleteForward";
      if (key.name === "abort")
        return "abort";
      if (key.name === "escape")
        return "exit";
      if (key.name === "tab")
        return "next";
      if (key.name === "pagedown")
        return "nextPage";
      if (key.name === "pageup")
        return "prevPage";
      if (key.name === "home")
        return "home";
      if (key.name === "end")
        return "end";
      if (key.name === "up")
        return "up";
      if (key.name === "down")
        return "down";
      if (key.name === "right")
        return "right";
      if (key.name === "left")
        return "left";
      return false;
    };
  }
});

// ../../node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS({
  "../../node_modules/prompts/dist/util/strip.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (str) => {
      const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "../../node_modules/sisteransi/src/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var ESC = "\x1B";
    var CSI = `${ESC}[`;
    var beep = "\x07";
    var cursor = {
      to(x2, y) {
        if (!y)
          return `${CSI}${x2 + 1}G`;
        return `${CSI}${y + 1};${x2 + 1}H`;
      },
      move(x2, y) {
        let ret = "";
        if (x2 < 0)
          ret += `${CSI}${-x2}D`;
        else if (x2 > 0)
          ret += `${CSI}${x2}C`;
        if (y < 0)
          ret += `${CSI}${-y}A`;
        else if (y > 0)
          ret += `${CSI}${y}B`;
        return ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    };
    var scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    };
    var erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i2 = 0; i2 < count; i2++)
          clear += this.line + (i2 < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module.exports = { cursor, scroll, erase, beep };
  }
});

// ../../node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS({
  "../../node_modules/prompts/dist/util/clear.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return { s: F2, n: function n() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s2() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f3() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var strip = require_strip();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var width = (str) => [...strip(str)].length;
    module.exports = function(prompt, perLine) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      var _iterator = _createForOfIteratorHelper(lines), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          let line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return erase.lines(rows);
    };
  }
});

// ../../node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS({
  "../../node_modules/prompts/dist/util/figures.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module.exports = figures;
  }
});

// ../../node_modules/prompts/dist/util/style.js
var require_style = __commonJS({
  "../../node_modules/prompts/dist/util/style.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var c = require_kleur();
    var figures = require_figures();
    var styles = Object.freeze({
      password: {
        scale: 1,
        render: (input) => "*".repeat(input.length)
      },
      emoji: {
        scale: 2,
        render: (input) => "\u{1F603}".repeat(input.length)
      },
      invisible: {
        scale: 0,
        render: (input) => ""
      },
      default: {
        scale: 1,
        render: (input) => `${input}`
      }
    });
    var render = (type) => styles[type] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/dist/util/lines.js
var require_lines = __commonJS({
  "../../node_modules/prompts/dist/util/lines.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var strip = require_strip();
    module.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine)
        return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// ../../node_modules/prompts/dist/util/wrap.js
var require_wrap = __commonJS({
  "../../node_modules/prompts/dist/util/wrap.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
          arr[arr.length - 1] += ` ${w}`;
        else
          arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// ../../node_modules/prompts/dist/util/entriesToDisplay.js
var require_entriesToDisplay = __commonJS({
  "../../node_modules/prompts/dist/util/entriesToDisplay.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0)
        startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return {
        startIndex,
        endIndex
      };
    };
  }
});

// ../../node_modules/prompts/dist/util/index.js
var require_util = __commonJS({
  "../../node_modules/prompts/dist/util/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      action: require_action(),
      clear: require_clear(),
      style: require_style(),
      strip: require_strip(),
      figures: require_figures(),
      lines: require_lines(),
      wrap: require_wrap(),
      entriesToDisplay: require_entriesToDisplay()
    };
  }
});

// ../../node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS({
  "../../node_modules/prompts/dist/elements/prompt.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var readline = __require("readline");
    var _require = require_util();
    var action = _require.action;
    var EventEmitter = __require("events");
    var _require2 = require_src();
    var beep = _require2.beep;
    var cursor = _require2.cursor;
    var color = require_kleur();
    var Prompt = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({
          input: this.in,
          escapeCodeTimeout: 50
        });
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY)
          this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY)
            this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender)
          this.firstRender = false;
      }
    };
    module.exports = Prompt;
  }
});

// ../../node_modules/prompts/dist/elements/text.js
var require_text = __commonJS({
  "../../node_modules/prompts/dist/elements/text.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util();
    var style = _require2.style;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var figures = _require2.figures;
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          _this2.value = _this2.value || _this2.initial;
          _this2.cursorOffset = 0;
          _this2.cursor = _this2.rendered.length;
          yield _this2.validate();
          if (_this2.error) {
            _this2.red = true;
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder)
          return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart())
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i2) => a + `
${i2 ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/select.js
var require_select = __commonJS({
  "../../node_modules/prompts/dist/elements/select.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var wrap = _require.wrap;
    var entriesToDisplay = _require.entriesToDisplay;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {
              title: ch,
              value: idx
            };
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else
          this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            let title, prefix, desc = "", v = this.choices[i2];
            if (i2 === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i2 === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title = this.cursor === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i2 ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title = this.cursor === i2 ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i2 ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i2) {
                desc = ` - ${v.description}`;
                if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap(v.description, {
                    margin: 3,
                    width: this.out.columns
                  });
                }
              }
            }
            this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS({
  "../../node_modules/prompts/dist/elements/toggle.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var erase = _require2.erase;
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false)
          return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true)
          return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else
          return this.bell();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS({
  "../../node_modules/prompts/dist/dateparts/datepart.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = class {
      constructor({
        token,
        date,
        parts,
        locales
      }) {
        this.token = token;
        this.date = date || /* @__PURE__ */ new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module.exports = DatePart;
  }
});

// ../../node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS({
  "../../node_modules/prompts/dist/dateparts/meridiem.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module.exports = Meridiem;
  }
});

// ../../node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS({
  "../../node_modules/prompts/dist/dateparts/day.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module.exports = Day;
  }
});

// ../../node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS({
  "../../node_modules/prompts/dist/dateparts/hours.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token))
          hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module.exports = Hours;
  }
});

// ../../node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/milliseconds.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS({
  "../../node_modules/prompts/dist/dateparts/minutes.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m2 = this.date.getMinutes();
        return this.token.length > 1 ? String(m2).padStart(2, "0") : m2;
      }
    };
    module.exports = Minutes;
  }
});

// ../../node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS({
  "../../node_modules/prompts/dist/dateparts/month.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module.exports = Month;
  }
});

// ../../node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/seconds.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s2 = this.date.getSeconds();
        return this.token.length > 1 ? String(s2).padStart(2, "0") : s2;
      }
    };
    module.exports = Seconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS({
  "../../node_modules/prompts/dist/dateparts/year.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module.exports = Year;
  }
});

// ../../node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS({
  "../../node_modules/prompts/dist/dateparts/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      DatePart: require_datepart(),
      Meridiem: require_meridiem(),
      Day: require_day(),
      Hours: require_hours(),
      Milliseconds: require_milliseconds(),
      Minutes: require_minutes(),
      Month: require_month(),
      Seconds: require_seconds(),
      Year: require_year()
    };
  }
});

// ../../node_modules/prompts/dist/elements/date.js
var require_date = __commonJS({
  "../../node_modules/prompts/dist/elements/date.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var _require3 = require_dateparts();
    var DatePart = _require3.DatePart;
    var Meridiem = _require3.Meridiem;
    var Day = _require3.Day;
    var Hours = _require3.Hours;
    var Milliseconds = _require3.Milliseconds;
    var Minutes = _require3.Minutes;
    var Month = _require3.Month;
    var Seconds = _require3.Seconds;
    var Year = _require3.Year;
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({
        token
      }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || /* @__PURE__ */ new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date)
          this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({
            token: result[idx] || match,
            date: this.date,
            parts: this.parts,
            locales: this.locales
          }) : result[idx] || match);
        }
        let parts = this.parts.reduce((arr, i2) => {
          if (typeof i2 === "string" && typeof arr[arr.length - 1] === "string")
            arr[arr.length - 1] += i2;
          else
            arr.push(i2);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === "string") {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = "red";
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce((a, l, i2) => a + `
${i2 ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/number.js
var require_number = __commonJS({
  "../../node_modules/prompts/dist/elements/number.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var cursor = _require.cursor;
    var erase = _require.erase;
    var _require2 = require_util();
    var style = _require2.style;
    var figures = _require2.figures;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x2) {
        return this.float ? parseFloat(x2) : parseInt(x2);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x2 = this.value;
        this.value = x2 !== `` ? x2 : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = `red`;
            _this2.fire();
            _this2.render();
            return;
          }
          let x2 = _this2.value;
          _this2.value = x2 !== `` ? x2 : _this2.initial;
          _this2.done = true;
          _this2.aborted = false;
          _this2.error = false;
          _this2.fire();
          _this2.render();
          _this2.out.write(`
`);
          _this2.close();
        })();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max)
          return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min)
          return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3)
          this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`)
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max)
          this.value = this.max;
        if (this.value < this.min)
          this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i2) => a + `
${i2 ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/multiselect.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var Prompt = require_prompt();
    var _require2 = require_util();
    var clear = _require2.clear;
    var figures = _require2.figures;
    var style = _require2.style;
    var wrap = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = {
              title: ch,
              value: idx
            };
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e2) => e2.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e2) => e2.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e2) => e2.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i2, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title, desc;
        if (v.disabled) {
          title = cursor2 === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title = cursor2 === i2 ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i2 && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, {
                margin: prefix.length,
                width: this.out.columns
              });
            }
          }
        }
        return prefix + title + color.gray(desc || "");
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        let prefix, styledOptions = [];
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          if (i2 === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i2 === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i2], i2, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e2) => e2.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS({
  "../../node_modules/prompts/dist/elements/autocomplete.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util();
    var style = _require2.style;
    var clear = _require2.clear;
    var figures = _require2.figures;
    var wrap = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var getVal = (arr, i2) => arr[i2] && (arr[i2].value || arr[i2].title || arr[i2]);
    var getTitle = (arr, i2) => arr[i2] && (arr[i2].title || arr[i2].value || arr[i2]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = {
          noMatches: opts.noMatches || "no matches found"
        };
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number")
          choice = this.choices[this._fb];
        else if (typeof this._fb === "string")
          choice = {
            title: this._fb
          };
        return choice || this._fb || {
          title: this.i18n.noMatches
        };
      }
      moveSelect(i2) {
        this.select = i2;
        if (this.suggestions.length > 0)
          this.value = getVal(this.suggestions, i2);
        else
          this.value = this.fallback.value;
        this.fire();
      }
      complete(cb) {
        var _this = this;
        return _asyncToGenerator(function* () {
          const p = _this.completing = _this.suggest(_this.input, _this.choices);
          const suggestions = yield p;
          if (_this.completing !== p)
            return;
          _this.suggestions = suggestions.map((s2, i2, arr) => ({
            title: getTitle(arr, i2),
            value: getVal(arr, i2),
            description: s2.description
          }));
          _this.completing = false;
          const l = Math.max(suggestions.length - 1, 0);
          _this.moveSelect(Math.min(l, _this.select));
          cb && cb();
        })();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else
          this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, {
              margin: 3,
              width: this.out.columns
            });
          }
        }
        return prefix + " " + title + color.gray(desc || "");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i2) => this.renderOption(item, this.select === i2 + startIndex, i2 === 0 && startIndex > 0, i2 + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/autocompleteMultiselect.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var MultiselectPrompt = require_multiselect();
    var _require2 = require_util();
    var clear = _require2.clear;
    var style = _require2.style;
    var figures = _require2.figures;
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e2) => e2.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e2) => e2.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i2) {
        let title;
        if (v.disabled)
          title = cursor2 === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else
          title = cursor2 === i2 ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e2) => e2.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS({
  "../../node_modules/prompts/dist/elements/confirm.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS({
  "../../node_modules/prompts/dist/elements/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      TextPrompt: require_text(),
      SelectPrompt: require_select(),
      TogglePrompt: require_toggle(),
      DatePrompt: require_date(),
      NumberPrompt: require_number(),
      MultiselectPrompt: require_multiselect(),
      AutocompletePrompt: require_autocomplete(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
      ConfirmPrompt: require_confirm()
    };
  }
});

// ../../node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS({
  "../../node_modules/prompts/dist/prompts.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var $ = exports;
    var el = require_elements();
    var noop2 = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type](args);
        const onAbort = opts.onAbort || noop2;
        const onSubmit = opts.onSubmit || noop2;
        const onExit = opts.onExit || noop2;
        p.on("state", args.onState || noop2);
        p.on("submit", (x2) => res(onSubmit(x2)));
        p.on("exit", (x2) => res(onExit(x2)));
        p.on("abort", (x2) => rej(onAbort(x2)));
      });
    }
    $.text = (args) => toPrompt("TextPrompt", args);
    $.password = (args) => {
      args.style = "password";
      return $.text(args);
    };
    $.invisible = (args) => {
      args.style = "invisible";
      return $.text(args);
    };
    $.number = (args) => toPrompt("NumberPrompt", args);
    $.date = (args) => toPrompt("DatePrompt", args);
    $.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $.list = (args) => {
      const sep = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep).map((s2) => s2.trim())
      });
    };
    $.toggle = (args) => toPrompt("TogglePrompt", args);
    $.select = (args) => toPrompt("SelectPrompt", args);
    $.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
    $.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// ../../node_modules/prompts/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/prompts/dist/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return { s: F2, n: function n() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s2() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f3() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var prompts3 = require_prompts();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop2 = () => {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      _prompt = _asyncToGenerator(function* (questions = [], {
        onSubmit = noop2,
        onCancel = noop2
      } = {}) {
        const answers = {};
        const override2 = prompt._override || {};
        questions = [].concat(questions);
        let answer, question, quit, name, type, lastPrompt;
        const getFormattedAnswer = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
            if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
              return;
            }
            return question2.format ? yield question2.format(answer2, answers) : answer2;
          });
          return function getFormattedAnswer2(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();
        var _iterator = _createForOfIteratorHelper(questions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            question = _step.value;
            var _question = question;
            name = _question.name;
            type = _question.type;
            if (typeof type === "function") {
              type = yield type(answer, _objectSpread({}, answers), question);
              question["type"] = type;
            }
            if (!type)
              continue;
            for (let key in question) {
              if (passOn.includes(key))
                continue;
              let value = question[key];
              question[key] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
            }
            lastPrompt = question;
            if (typeof question.message !== "string") {
              throw new Error("prompt message is required");
            }
            var _question2 = question;
            name = _question2.name;
            type = _question2.type;
            if (prompts3[type] === void 0) {
              throw new Error(`prompt type (${type}) is not defined`);
            }
            if (override2[question.name] !== void 0) {
              answer = yield getFormattedAnswer(question, override2[question.name]);
              if (answer !== void 0) {
                answers[name] = answer;
                continue;
              }
            }
            try {
              answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts3[type](question);
              answers[name] = answer = yield getFormattedAnswer(question, answer, true);
              quit = yield onSubmit(question, answer, answers);
            } catch (err) {
              quit = !(yield onCancel(question, answers));
            }
            if (quit)
              return answers;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return answers;
      });
      return _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module.exports = Object.assign(prompt, {
      prompt,
      prompts: prompts3,
      inject,
      override
    });
  }
});

// ../../node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS({
  "../../node_modules/prompts/lib/util/action.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape")
        return;
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c")
          return "abort";
        if (key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      if (isSelect) {
        if (key.name === "j")
          return "down";
        if (key.name === "k")
          return "up";
      }
      if (key.name === "return")
        return "submit";
      if (key.name === "enter")
        return "submit";
      if (key.name === "backspace")
        return "delete";
      if (key.name === "delete")
        return "deleteForward";
      if (key.name === "abort")
        return "abort";
      if (key.name === "escape")
        return "exit";
      if (key.name === "tab")
        return "next";
      if (key.name === "pagedown")
        return "nextPage";
      if (key.name === "pageup")
        return "prevPage";
      if (key.name === "home")
        return "home";
      if (key.name === "end")
        return "end";
      if (key.name === "up")
        return "up";
      if (key.name === "down")
        return "down";
      if (key.name === "right")
        return "right";
      if (key.name === "left")
        return "left";
      return false;
    };
  }
});

// ../../node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS({
  "../../node_modules/prompts/lib/util/strip.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (str) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS({
  "../../node_modules/prompts/lib/util/clear.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var strip = require_strip2();
    var { erase, cursor } = require_src();
    var width = (str) => [...strip(str)].length;
    module.exports = function(prompt, perLine) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      for (let line of lines) {
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      }
      return erase.lines(rows);
    };
  }
});

// ../../node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS({
  "../../node_modules/prompts/lib/util/figures.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module.exports = figures;
  }
});

// ../../node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS({
  "../../node_modules/prompts/lib/util/style.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var c = require_kleur();
    var figures = require_figures2();
    var styles = Object.freeze({
      password: { scale: 1, render: (input) => "*".repeat(input.length) },
      emoji: { scale: 2, render: (input) => "\u{1F603}".repeat(input.length) },
      invisible: { scale: 0, render: (input) => "" },
      default: { scale: 1, render: (input) => `${input}` }
    });
    var render = (type) => styles[type] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/lib/util/lines.js
var require_lines2 = __commonJS({
  "../../node_modules/prompts/lib/util/lines.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var strip = require_strip2();
    module.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine)
        return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// ../../node_modules/prompts/lib/util/wrap.js
var require_wrap2 = __commonJS({
  "../../node_modules/prompts/lib/util/wrap.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
          arr[arr.length - 1] += ` ${w}`;
        else
          arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// ../../node_modules/prompts/lib/util/entriesToDisplay.js
var require_entriesToDisplay2 = __commonJS({
  "../../node_modules/prompts/lib/util/entriesToDisplay.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0)
        startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return { startIndex, endIndex };
    };
  }
});

// ../../node_modules/prompts/lib/util/index.js
var require_util2 = __commonJS({
  "../../node_modules/prompts/lib/util/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      action: require_action2(),
      clear: require_clear2(),
      style: require_style2(),
      strip: require_strip2(),
      figures: require_figures2(),
      lines: require_lines2(),
      wrap: require_wrap2(),
      entriesToDisplay: require_entriesToDisplay2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS({
  "../../node_modules/prompts/lib/elements/prompt.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var readline = __require("readline");
    var { action } = require_util2();
    var EventEmitter = __require("events");
    var { beep, cursor } = require_src();
    var color = require_kleur();
    var Prompt = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({ input: this.in, escapeCodeTimeout: 50 });
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY)
          this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY)
            this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender)
          this.firstRender = false;
      }
    };
    module.exports = Prompt;
  }
});

// ../../node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS({
  "../../node_modules/prompts/lib/elements/text.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { erase, cursor } = require_src();
    var { style, clear, lines, figures } = require_util2();
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        this.value = this.value || this.initial;
        this.cursorOffset = 0;
        this.cursor = this.rendered.length;
        await this.validate();
        if (this.error) {
          this.red = true;
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder)
          return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart())
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.red ? color.red(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i2) => a + `
${i2 ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS({
  "../../node_modules/prompts/lib/elements/select.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear, figures, wrap, entriesToDisplay } = require_util2();
    var { cursor } = require_src();
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = { title: ch, value: idx };
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else
          this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
        ].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            let title, prefix, desc = "", v = this.choices[i2];
            if (i2 === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i2 === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title = this.cursor === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i2 ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title = this.cursor === i2 ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i2 ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i2) {
                desc = ` - ${v.description}`;
                if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap(v.description, { margin: 3, width: this.out.columns });
                }
              }
            }
            this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS({
  "../../node_modules/prompts/lib/elements/toggle.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear } = require_util2();
    var { cursor, erase } = require_src();
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false)
          return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true)
          return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else
          return this.bell();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.value ? this.inactive : color.cyan().underline(this.inactive),
          color.gray("/"),
          this.value ? color.cyan().underline(this.active) : this.active
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/datepart.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = class {
      constructor({ token, date, parts, locales }) {
        this.token = token;
        this.date = date || /* @__PURE__ */ new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module.exports = DatePart;
  }
});

// ../../node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/meridiem.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module.exports = Meridiem;
  }
});

// ../../node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/day.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module.exports = Day;
  }
});

// ../../node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/hours.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token))
          hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module.exports = Hours;
  }
});

// ../../node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/milliseconds.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/minutes.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m2 = this.date.getMinutes();
        return this.token.length > 1 ? String(m2).padStart(2, "0") : m2;
      }
    };
    module.exports = Minutes;
  }
});

// ../../node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/month.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module.exports = Month;
  }
});

// ../../node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/seconds.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s2 = this.date.getSeconds();
        return this.token.length > 1 ? String(s2).padStart(2, "0") : s2;
      }
    };
    module.exports = Seconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/year.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var DatePart = require_datepart2();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module.exports = Year;
  }
});

// ../../node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      DatePart: require_datepart2(),
      Meridiem: require_meridiem2(),
      Day: require_day2(),
      Hours: require_hours2(),
      Milliseconds: require_milliseconds2(),
      Minutes: require_minutes2(),
      Month: require_month2(),
      Seconds: require_seconds2(),
      Year: require_year2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS({
  "../../node_modules/prompts/lib/elements/date.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear, figures } = require_util2();
    var { erase, cursor } = require_src();
    var { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = require_dateparts2();
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({ token }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || /* @__PURE__ */ new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date)
          this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales }) : result[idx] || match);
        }
        let parts = this.parts.reduce((arr, i2) => {
          if (typeof i2 === "string" && typeof arr[arr.length - 1] === "string")
            arr[arr.length - 1] += i2;
          else
            arr.push(i2);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === "string") {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = "red";
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
        ].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce(
            (a, l, i2) => a + `
${i2 ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`,
            ``
          );
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS({
  "../../node_modules/prompts/lib/elements/number.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { cursor, erase } = require_src();
    var { style, figures, clear, lines } = require_util2();
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x2) {
        return this.float ? parseFloat(x2) : parseInt(x2);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x2 = this.value;
        this.value = x2 !== `` ? x2 : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = `red`;
          this.fire();
          this.render();
          return;
        }
        let x2 = this.value;
        this.value = x2 !== `` ? x2 : this.initial;
        this.done = true;
        this.aborted = false;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max)
          return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min)
          return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3)
          this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`)
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max)
          this.value = this.max;
        if (this.value < this.min)
          this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed)
          return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i2) => a + `
${i2 ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/multiselect.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var { cursor } = require_src();
    var Prompt = require_prompt2();
    var { clear, figures, style, wrap, entriesToDisplay } = require_util2();
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = { title: ch, value: idx };
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e2) => e2.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e2) => e2.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e2) => e2.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i2, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title, desc;
        if (v.disabled) {
          title = cursor2 === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title = cursor2 === i2 ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i2 && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, { margin: prefix.length, width: this.out.columns });
            }
          }
        }
        return prefix + title + color.gray(desc || "");
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
        let prefix, styledOptions = [];
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          if (i2 === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i2 === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i2], i2, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e2) => e2.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocomplete.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { erase, cursor } = require_src();
    var { style, clear, figures, wrap, entriesToDisplay } = require_util2();
    var getVal = (arr, i2) => arr[i2] && (arr[i2].value || arr[i2].title || arr[i2]);
    var getTitle = (arr, i2) => arr[i2] && (arr[i2].title || arr[i2].value || arr[i2]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = { noMatches: opts.noMatches || "no matches found" };
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number")
          choice = this.choices[this._fb];
        else if (typeof this._fb === "string")
          choice = { title: this._fb };
        return choice || this._fb || { title: this.i18n.noMatches };
      }
      moveSelect(i2) {
        this.select = i2;
        if (this.suggestions.length > 0)
          this.value = getVal(this.suggestions, i2);
        else
          this.value = this.fallback.value;
        this.fire();
      }
      async complete(cb) {
        const p = this.completing = this.suggest(this.input, this.choices);
        const suggestions = await p;
        if (this.completing !== p)
          return;
        this.suggestions = suggestions.map((s2, i2, arr) => ({ title: getTitle(arr, i2), value: getVal(arr, i2), description: s2.description }));
        this.completing = false;
        const l = Math.max(suggestions.length - 1, 0);
        this.moveSelect(Math.min(l, this.select));
        cb && cb();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else
          this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, { margin: 3, width: this.out.columns });
          }
        }
        return prefix + " " + title + color.gray(desc || "");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);
        this.outputText = [
          style.symbol(this.done, this.aborted, this.exited),
          color.bold(this.msg),
          style.delimiter(this.completing),
          this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
        ].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i2) => this.renderOption(
            item,
            this.select === i2 + startIndex,
            i2 === 0 && startIndex > 0,
            i2 + startIndex === endIndex - 1 && endIndex < this.choices.length
          )).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocompleteMultiselect.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var { cursor } = require_src();
    var MultiselectPrompt = require_multiselect2();
    var { clear, style, figures } = require_util2();
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e2) => e2.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e2) => e2.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i2) {
        let title;
        if (v.disabled)
          title = cursor2 === i2 ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else
          title = cursor2 === i2 ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e2) => e2.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS({
  "../../node_modules/prompts/lib/elements/confirm.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear } = require_util2();
    var { erase, cursor } = require_src();
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed)
          return;
        if (this.firstRender)
          this.out.write(cursor.hide);
        else
          this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS({
  "../../node_modules/prompts/lib/elements/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      TextPrompt: require_text2(),
      SelectPrompt: require_select2(),
      TogglePrompt: require_toggle2(),
      DatePrompt: require_date2(),
      NumberPrompt: require_number2(),
      MultiselectPrompt: require_multiselect2(),
      AutocompletePrompt: require_autocomplete2(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
      ConfirmPrompt: require_confirm2()
    };
  }
});

// ../../node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS({
  "../../node_modules/prompts/lib/prompts.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var $ = exports;
    var el = require_elements2();
    var noop2 = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type](args);
        const onAbort = opts.onAbort || noop2;
        const onSubmit = opts.onSubmit || noop2;
        const onExit = opts.onExit || noop2;
        p.on("state", args.onState || noop2);
        p.on("submit", (x2) => res(onSubmit(x2)));
        p.on("exit", (x2) => res(onExit(x2)));
        p.on("abort", (x2) => rej(onAbort(x2)));
      });
    }
    $.text = (args) => toPrompt("TextPrompt", args);
    $.password = (args) => {
      args.style = "password";
      return $.text(args);
    };
    $.invisible = (args) => {
      args.style = "invisible";
      return $.text(args);
    };
    $.number = (args) => toPrompt("NumberPrompt", args);
    $.date = (args) => toPrompt("DatePrompt", args);
    $.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $.list = (args) => {
      const sep = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep).map((s2) => s2.trim())
      });
    };
    $.toggle = (args) => toPrompt("TogglePrompt", args);
    $.select = (args) => toPrompt("SelectPrompt", args);
    $.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(
      choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase())
    );
    $.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// ../../node_modules/prompts/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/prompts/lib/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var prompts3 = require_prompts2();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop2 = () => {
    };
    async function prompt(questions = [], { onSubmit = noop2, onCancel = noop2 } = {}) {
      const answers = {};
      const override2 = prompt._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type, lastPrompt;
      const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
        if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
          return;
        }
        return question2.format ? await question2.format(answer2, answers) : answer2;
      };
      for (question of questions) {
        ({ name, type } = question);
        if (typeof type === "function") {
          type = await type(answer, { ...answers }, question);
          question["type"] = type;
        }
        if (!type)
          continue;
        for (let key in question) {
          if (passOn.includes(key))
            continue;
          let value = question[key];
          question[key] = typeof value === "function" ? await value(answer, { ...answers }, lastPrompt) : value;
        }
        lastPrompt = question;
        if (typeof question.message !== "string") {
          throw new Error("prompt message is required");
        }
        ({ name, type } = question);
        if (prompts3[type] === void 0) {
          throw new Error(`prompt type (${type}) is not defined`);
        }
        if (override2[question.name] !== void 0) {
          answer = await getFormattedAnswer(question, override2[question.name]);
          if (answer !== void 0) {
            answers[name] = answer;
            continue;
          }
        }
        try {
          answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts3[type](question);
          answers[name] = answer = await getFormattedAnswer(question, answer, true);
          quit = await onSubmit(question, answer, answers);
        } catch (err) {
          quit = !await onCancel(question, answers);
        }
        if (quit)
          return answers;
      }
      return answers;
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module.exports = Object.assign(prompt, { prompt, prompts: prompts3, inject, override });
  }
});

// ../../node_modules/prompts/index.js
var require_prompts3 = __commonJS({
  "../../node_modules/prompts/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function isNodeLT(tar) {
      tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
      let i2 = 0, src = process.versions.node.split(".").map(Number);
      for (; i2 < tar.length; i2++) {
        if (src[i2] > tar[i2])
          return false;
        if (tar[i2] > src[i2])
          return true;
      }
      return false;
    }
    module.exports = isNodeLT("8.6.0") ? require_dist() : require_lib();
  }
});

// ../../node_modules/consola/dist/consola.js
var require_consola = __commonJS({
  "../../node_modules/consola/dist/consola.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function u(u2) {
      return u2 && "object" == typeof u2 && "default" in u2 ? u2.default : u2;
    }
    var D = u(__require("util"));
    var e2 = __require("path");
    var t2 = __require("fs");
    var r2 = u(__require("os"));
    var n = u(__require("tty"));
    function s2(u2, D2) {
      return u2(D2 = { exports: {} }, D2.exports), D2.exports;
    }
    var o;
    var i2 = (o = Object.freeze({ __proto__: null, default: [{ name: "AppVeyor", constant: "APPVEYOR", env: "APPVEYOR", pr: "APPVEYOR_PULL_REQUEST_NUMBER" }, { name: "Bamboo", constant: "BAMBOO", env: "bamboo_planKey" }, { name: "Bitbucket Pipelines", constant: "BITBUCKET", env: "BITBUCKET_COMMIT" }, { name: "Bitrise", constant: "BITRISE", env: "BITRISE_IO", pr: "BITRISE_PULL_REQUEST" }, { name: "Buddy", constant: "BUDDY", env: "BUDDY_WORKSPACE_ID", pr: "BUDDY_EXECUTION_PULL_REQUEST_ID" }, { name: "Buildkite", constant: "BUILDKITE", env: "BUILDKITE", pr: { env: "BUILDKITE_PULL_REQUEST", ne: "false" } }, { name: "CircleCI", constant: "CIRCLE", env: "CIRCLECI", pr: "CIRCLE_PULL_REQUEST" }, { name: "Cirrus CI", constant: "CIRRUS", env: "CIRRUS_CI", pr: "CIRRUS_PR" }, { name: "AWS CodeBuild", constant: "CODEBUILD", env: "CODEBUILD_BUILD_ARN" }, { name: "Codeship", constant: "CODESHIP", env: { CI_NAME: "codeship" } }, { name: "Drone", constant: "DRONE", env: "DRONE", pr: { DRONE_BUILD_EVENT: "pull_request" } }, { name: "dsari", constant: "DSARI", env: "DSARI" }, { name: "GitLab CI", constant: "GITLAB", env: "GITLAB_CI" }, { name: "GoCD", constant: "GOCD", env: "GO_PIPELINE_LABEL" }, { name: "Hudson", constant: "HUDSON", env: "HUDSON_URL" }, { name: "Jenkins", constant: "JENKINS", env: ["JENKINS_URL", "BUILD_ID"], pr: { any: ["ghprbPullId", "CHANGE_ID"] } }, { name: "Magnum CI", constant: "MAGNUM", env: "MAGNUM" }, { name: "Sail CI", constant: "SAIL", env: "SAILCI", pr: "SAIL_PULL_REQUEST_NUMBER" }, { name: "Semaphore", constant: "SEMAPHORE", env: "SEMAPHORE", pr: "PULL_REQUEST_NUMBER" }, { name: "Shippable", constant: "SHIPPABLE", env: "SHIPPABLE", pr: { IS_PULL_REQUEST: "true" } }, { name: "Solano CI", constant: "SOLANO", env: "TDDIUM", pr: "TDDIUM_PR_ID" }, { name: "Strider CD", constant: "STRIDER", env: "STRIDER" }, { name: "TaskCluster", constant: "TASKCLUSTER", env: ["TASK_ID", "RUN_ID"] }, { name: "Solano CI", constant: "TDDIUM", env: "TDDIUM", pr: "TDDIUM_PR_ID", deprecated: true }, { name: "TeamCity", constant: "TEAMCITY", env: "TEAMCITY_VERSION" }, { name: "Team Foundation Server", constant: "TFS", env: "TF_BUILD" }, { name: "Travis CI", constant: "TRAVIS", env: "TRAVIS", pr: { env: "TRAVIS_PULL_REQUEST", ne: "false" } }] })) && o.default || o;
    var a = s2(function(u2, D2) {
      var e3 = process.env;
      function t3(u3) {
        return "string" == typeof u3 ? !!e3[u3] : Object.keys(u3).every(function(D3) {
          return e3[D3] === u3[D3];
        });
      }
      Object.defineProperty(D2, "_vendors", { value: i2.map(function(u3) {
        return u3.constant;
      }) }), D2.name = null, D2.isPR = null, i2.forEach(function(u3) {
        var r3 = (Array.isArray(u3.env) ? u3.env : [u3.env]).every(function(u4) {
          return t3(u4);
        });
        if (D2[u3.constant] = r3, r3)
          switch (D2.name = u3.name, typeof u3.pr) {
            case "string":
              D2.isPR = !!e3[u3.pr];
              break;
            case "object":
              "env" in u3.pr ? D2.isPR = u3.pr.env in e3 && e3[u3.pr.env] !== u3.pr.ne : "any" in u3.pr ? D2.isPR = u3.pr.any.some(function(u4) {
                return !!e3[u4];
              }) : D2.isPR = t3(u3.pr);
              break;
            default:
              D2.isPR = null;
          }
      }), D2.isCI = !!(e3.CI || e3.CONTINUOUS_INTEGRATION || e3.BUILD_NUMBER || e3.RUN_ID || D2.name);
    });
    var l = (a.name, a.isPR, a.isCI, false);
    var c = false;
    var h2 = false;
    var F2 = "development";
    var C = "undefined" != typeof window;
    var f3 = "";
    var E = false;
    function g(u2) {
      return !(!u2 || "false" === u2);
    }
    "undefined" != typeof process && (process.platform && (f3 = String(process.platform)), process.stdout && (h2 = g(process.stdout.isTTY)), l = Boolean(a.isCI), process.env && (process.env.NODE_ENV && (F2 = process.env.NODE_ENV), c = g(process.env.DEBUG), E = g(process.env.MINIMAL)));
    var d = { browser: C, test: "test" === F2, dev: "development" === F2 || "dev" === F2, production: "production" === F2, debug: c, ci: l, tty: h2, minimal: void 0, minimalCLI: void 0, windows: /^win/i.test(f3), darwin: /^darwin/i.test(f3), linux: /^linux/i.test(f3) };
    d.minimal = E || d.ci || d.test || !d.tty, d.minimalCLI = d.minimal;
    var p = Object.freeze(d);
    var m2 = {};
    m2[m2.Fatal = 0] = "Fatal", m2[m2.Error = 0] = "Error", m2[m2.Warn = 1] = "Warn", m2[m2.Log = 2] = "Log", m2[m2.Info = 3] = "Info", m2[m2.Success = 3] = "Success", m2[m2.Debug = 4] = "Debug", m2[m2.Trace = 5] = "Trace", m2[m2.Silent = -1 / 0] = "Silent", m2[m2.Verbose = 1 / 0] = "Verbose";
    var b = { silent: { level: -1 }, fatal: { level: m2.Fatal }, error: { level: m2.Error }, warn: { level: m2.Warn }, log: { level: m2.Log }, info: { level: m2.Info }, success: { level: m2.Success }, debug: { level: m2.Debug }, trace: { level: m2.Trace }, verbose: { level: m2.Trace }, ready: { level: m2.Info }, start: { level: m2.Info } };
    function y(u2) {
      return D2 = u2, "[object Object]" === Object.prototype.toString.call(D2) && (!(!u2.message && !u2.args) && !u2.stack);
      var D2;
    }
    var B = false;
    var v = [];
    var _ = class {
      constructor(u2 = {}) {
        this._reporters = u2.reporters || [], this._types = u2.types || b, this.level = void 0 !== u2.level ? u2.level : 3, this._defaults = u2.defaults || {}, this._async = void 0 !== u2.async ? u2.async : void 0, this._stdout = u2.stdout, this._stderr = u2.stderr, this._mockFn = u2.mockFn, this._throttle = u2.throttle || 1e3, this._throttleMin = u2.throttleMin || 5;
        for (const u3 in this._types) {
          const D2 = { type: u3, ...this._types[u3], ...this._defaults };
          this[u3] = this._wrapLogFn(D2), this[u3].raw = this._wrapLogFn(D2, true);
        }
        this._mockFn && this.mockTypes(), this._lastLogSerialized = void 0, this._lastLog = void 0, this._lastLogTime = void 0, this._lastLogCount = 0, this._throttleTimeout = void 0;
      }
      get stdout() {
        return this._stdout || console._stdout;
      }
      get stderr() {
        return this._stderr || console._stderr;
      }
      create(u2) {
        return new _(Object.assign({ reporters: this._reporters, level: this.level, types: this._types, defaults: this._defaults, stdout: this._stdout, stderr: this._stderr, mockFn: this._mockFn }, u2));
      }
      withDefaults(u2) {
        return this.create({ defaults: Object.assign({}, this._defaults, u2) });
      }
      withTag(u2) {
        return this.withDefaults({ tag: this._defaults.tag ? this._defaults.tag + ":" + u2 : u2 });
      }
      addReporter(u2) {
        return this._reporters.push(u2), this;
      }
      removeReporter(u2) {
        if (u2) {
          const D2 = this._reporters.indexOf(u2);
          if (D2 >= 0)
            return this._reporters.splice(D2, 1);
        } else
          this._reporters.splice(0);
        return this;
      }
      setReporters(u2) {
        return this._reporters = Array.isArray(u2) ? u2 : [u2], this;
      }
      wrapAll() {
        this.wrapConsole(), this.wrapStd();
      }
      restoreAll() {
        this.restoreConsole(), this.restoreStd();
      }
      wrapConsole() {
        for (const u2 in this._types)
          console["__" + u2] || (console["__" + u2] = console[u2]), console[u2] = this[u2].raw;
      }
      restoreConsole() {
        for (const u2 in this._types)
          console["__" + u2] && (console[u2] = console["__" + u2], delete console["__" + u2]);
      }
      wrapStd() {
        this._wrapStream(this.stdout, "log"), this._wrapStream(this.stderr, "log");
      }
      _wrapStream(u2, D2) {
        u2 && (u2.__write || (u2.__write = u2.write), u2.write = (u3) => {
          this[D2].raw(String(u3).trim());
        });
      }
      restoreStd() {
        this._restoreStream(this.stdout), this._restoreStream(this.stderr);
      }
      _restoreStream(u2) {
        u2 && u2.__write && (u2.write = u2.__write, delete u2.__write);
      }
      pauseLogs() {
        B = true;
      }
      resumeLogs() {
        B = false;
        const u2 = v.splice(0);
        for (const D2 of u2)
          D2[0]._logFn(D2[1], D2[2]);
      }
      mockTypes(u2) {
        if (this._mockFn = u2 || this._mockFn, "function" == typeof this._mockFn)
          for (const u3 in this._types)
            this[u3] = this._mockFn(u3, this._types[u3]) || this[u3], this[u3].raw = this[u3];
      }
      _wrapLogFn(u2, D2) {
        return (...e3) => {
          if (!B)
            return this._logFn(u2, e3, D2);
          v.push([this, u2, e3, D2]);
        };
      }
      _logFn(u2, D2, e3) {
        if (u2.level > this.level)
          return !!this._async && Promise.resolve(false);
        const t3 = Object.assign({ date: /* @__PURE__ */ new Date(), args: [] }, u2);
        !e3 && 1 === D2.length && y(D2[0]) ? Object.assign(t3, D2[0]) : t3.args = Array.from(D2), t3.message && (t3.args.unshift(t3.message), delete t3.message), t3.additional && (Array.isArray(t3.additional) || (t3.additional = t3.additional.split("\n")), t3.args.push("\n" + t3.additional.join("\n")), delete t3.additional), t3.type = "string" == typeof t3.type ? t3.type.toLowerCase() : "", t3.tag = "string" == typeof t3.tag ? t3.tag.toLowerCase() : "";
        const r3 = (u3 = false) => {
          const D3 = this._lastLogCount - this._throttleMin;
          if (this._lastLog && D3 > 0) {
            const u4 = [...this._lastLog.args];
            D3 > 1 && u4.push(`(repeated ${D3} times)`), this._log({ ...this._lastLog, args: u4 }), this._lastLogCount = 1;
          }
          if (u3) {
            if (this._lastLog = t3, this._async)
              return this._logAsync(t3);
            this._log(t3);
          }
        };
        clearTimeout(this._throttleTimeout);
        const n2 = this._lastLogTime ? t3.date - this._lastLogTime : 0;
        if (this._lastLogTime = t3.date, n2 < this._throttle)
          try {
            const u3 = JSON.stringify([t3.type, t3.tag, t3.args]), D3 = this._lastLogSerialized === u3;
            if (this._lastLogSerialized = u3, D3 && (this._lastLogCount++, this._lastLogCount > this._throttleMin))
              return void (this._throttleTimeout = setTimeout(r3, this._throttle));
          } catch (u3) {
          }
        r3(true);
      }
      _log(u2) {
        for (const D2 of this._reporters)
          D2.log(u2, { async: false, stdout: this.stdout, stderr: this.stderr });
      }
      _logAsync(u2) {
        return Promise.all(this._reporters.map((D2) => D2.log(u2, { async: true, stdout: this.stdout, stderr: this.stderr })));
      }
    };
    function A2(u2) {
      const D2 = process.cwd() + e2.sep;
      return u2.split("\n").splice(1).map((u3) => u3.trim().replace("file://", "").replace(D2, ""));
    }
    _.prototype.add = _.prototype.addReporter, _.prototype.remove = _.prototype.removeReporter, _.prototype.clear = _.prototype.removeReporter, _.prototype.withScope = _.prototype.withTag, _.prototype.mock = _.prototype.mockTypes, _.prototype.pause = _.prototype.pauseLogs, _.prototype.resume = _.prototype.resumeLogs;
    var w = s2(function(u2, D2) {
      u2.exports = function() {
        var u3 = "millisecond", D3 = "second", e3 = "minute", t3 = "hour", r3 = "day", n2 = "week", s3 = "month", o2 = "quarter", i3 = "year", a2 = /^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/, l2 = /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, c2 = function(u4, D4, e4) {
          var t4 = String(u4);
          return !t4 || t4.length >= D4 ? u4 : "" + Array(D4 + 1 - t4.length).join(e4) + u4;
        }, h3 = { s: c2, z: function(u4) {
          var D4 = -u4.utcOffset(), e4 = Math.abs(D4), t4 = Math.floor(e4 / 60), r4 = e4 % 60;
          return (D4 <= 0 ? "+" : "-") + c2(t4, 2, "0") + ":" + c2(r4, 2, "0");
        }, m: function(u4, D4) {
          var e4 = 12 * (D4.year() - u4.year()) + (D4.month() - u4.month()), t4 = u4.clone().add(e4, s3), r4 = D4 - t4 < 0, n3 = u4.clone().add(e4 + (r4 ? -1 : 1), s3);
          return Number(-(e4 + (D4 - t4) / (r4 ? t4 - n3 : n3 - t4)) || 0);
        }, a: function(u4) {
          return u4 < 0 ? Math.ceil(u4) || 0 : Math.floor(u4);
        }, p: function(a3) {
          return { M: s3, y: i3, w: n2, d: r3, D: "date", h: t3, m: e3, s: D3, ms: u3, Q: o2 }[a3] || String(a3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(u4) {
          return void 0 === u4;
        } }, F3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, C2 = "en", f4 = {};
        f4[C2] = F3;
        var E2 = function(u4) {
          return u4 instanceof m3;
        }, g2 = function(u4, D4, e4) {
          var t4;
          if (!u4)
            return C2;
          if ("string" == typeof u4)
            f4[u4] && (t4 = u4), D4 && (f4[u4] = D4, t4 = u4);
          else {
            var r4 = u4.name;
            f4[r4] = u4, t4 = r4;
          }
          return !e4 && t4 && (C2 = t4), t4 || !e4 && C2;
        }, d2 = function(u4, D4) {
          if (E2(u4))
            return u4.clone();
          var e4 = "object" == typeof D4 ? D4 : {};
          return e4.date = u4, e4.args = arguments, new m3(e4);
        }, p2 = h3;
        p2.l = g2, p2.i = E2, p2.w = function(u4, D4) {
          return d2(u4, { locale: D4.$L, utc: D4.$u, $offset: D4.$offset });
        };
        var m3 = function() {
          function c3(u4) {
            this.$L = this.$L || g2(u4.locale, null, true), this.parse(u4);
          }
          var h4 = c3.prototype;
          return h4.parse = function(u4) {
            this.$d = function(u5) {
              var D4 = u5.date, e4 = u5.utc;
              if (null === D4)
                return /* @__PURE__ */ new Date(NaN);
              if (p2.u(D4))
                return /* @__PURE__ */ new Date();
              if (D4 instanceof Date)
                return new Date(D4);
              if ("string" == typeof D4 && !/Z$/i.test(D4)) {
                var t4 = D4.match(a2);
                if (t4)
                  return e4 ? new Date(Date.UTC(t4[1], t4[2] - 1, t4[3] || 1, t4[4] || 0, t4[5] || 0, t4[6] || 0, t4[7] || 0)) : new Date(t4[1], t4[2] - 1, t4[3] || 1, t4[4] || 0, t4[5] || 0, t4[6] || 0, t4[7] || 0);
              }
              return new Date(D4);
            }(u4), this.init();
          }, h4.init = function() {
            var u4 = this.$d;
            this.$y = u4.getFullYear(), this.$M = u4.getMonth(), this.$D = u4.getDate(), this.$W = u4.getDay(), this.$H = u4.getHours(), this.$m = u4.getMinutes(), this.$s = u4.getSeconds(), this.$ms = u4.getMilliseconds();
          }, h4.$utils = function() {
            return p2;
          }, h4.isValid = function() {
            return !("Invalid Date" === this.$d.toString());
          }, h4.isSame = function(u4, D4) {
            var e4 = d2(u4);
            return this.startOf(D4) <= e4 && e4 <= this.endOf(D4);
          }, h4.isAfter = function(u4, D4) {
            return d2(u4) < this.startOf(D4);
          }, h4.isBefore = function(u4, D4) {
            return this.endOf(D4) < d2(u4);
          }, h4.$g = function(u4, D4, e4) {
            return p2.u(u4) ? this[D4] : this.set(e4, u4);
          }, h4.year = function(u4) {
            return this.$g(u4, "$y", i3);
          }, h4.month = function(u4) {
            return this.$g(u4, "$M", s3);
          }, h4.day = function(u4) {
            return this.$g(u4, "$W", r3);
          }, h4.date = function(u4) {
            return this.$g(u4, "$D", "date");
          }, h4.hour = function(u4) {
            return this.$g(u4, "$H", t3);
          }, h4.minute = function(u4) {
            return this.$g(u4, "$m", e3);
          }, h4.second = function(u4) {
            return this.$g(u4, "$s", D3);
          }, h4.millisecond = function(D4) {
            return this.$g(D4, "$ms", u3);
          }, h4.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, h4.valueOf = function() {
            return this.$d.getTime();
          }, h4.startOf = function(u4, o3) {
            var a3 = this, l3 = !!p2.u(o3) || o3, c4 = p2.p(u4), h5 = function(u5, D4) {
              var e4 = p2.w(a3.$u ? Date.UTC(a3.$y, D4, u5) : new Date(a3.$y, D4, u5), a3);
              return l3 ? e4 : e4.endOf(r3);
            }, F4 = function(u5, D4) {
              return p2.w(a3.toDate()[u5].apply(a3.toDate("s"), (l3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(D4)), a3);
            }, C3 = this.$W, f5 = this.$M, E3 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
            switch (c4) {
              case i3:
                return l3 ? h5(1, 0) : h5(31, 11);
              case s3:
                return l3 ? h5(1, f5) : h5(0, f5 + 1);
              case n2:
                var d3 = this.$locale().weekStart || 0, m4 = (C3 < d3 ? C3 + 7 : C3) - d3;
                return h5(l3 ? E3 - m4 : E3 + (6 - m4), f5);
              case r3:
              case "date":
                return F4(g3 + "Hours", 0);
              case t3:
                return F4(g3 + "Minutes", 1);
              case e3:
                return F4(g3 + "Seconds", 2);
              case D3:
                return F4(g3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, h4.endOf = function(u4) {
            return this.startOf(u4, false);
          }, h4.$set = function(n3, o3) {
            var a3, l3 = p2.p(n3), c4 = "set" + (this.$u ? "UTC" : ""), h5 = (a3 = {}, a3.day = c4 + "Date", a3.date = c4 + "Date", a3[s3] = c4 + "Month", a3[i3] = c4 + "FullYear", a3[t3] = c4 + "Hours", a3[e3] = c4 + "Minutes", a3[D3] = c4 + "Seconds", a3[u3] = c4 + "Milliseconds", a3)[l3], F4 = l3 === r3 ? this.$D + (o3 - this.$W) : o3;
            if (l3 === s3 || l3 === i3) {
              var C3 = this.clone().set("date", 1);
              C3.$d[h5](F4), C3.init(), this.$d = C3.set("date", Math.min(this.$D, C3.daysInMonth())).toDate();
            } else
              h5 && this.$d[h5](F4);
            return this.init(), this;
          }, h4.set = function(u4, D4) {
            return this.clone().$set(u4, D4);
          }, h4.get = function(u4) {
            return this[p2.p(u4)]();
          }, h4.add = function(u4, o3) {
            var a3, l3 = this;
            u4 = Number(u4);
            var c4 = p2.p(o3), h5 = function(D4) {
              var e4 = d2(l3);
              return p2.w(e4.date(e4.date() + Math.round(D4 * u4)), l3);
            };
            if (c4 === s3)
              return this.set(s3, this.$M + u4);
            if (c4 === i3)
              return this.set(i3, this.$y + u4);
            if (c4 === r3)
              return h5(1);
            if (c4 === n2)
              return h5(7);
            var F4 = (a3 = {}, a3[e3] = 6e4, a3[t3] = 36e5, a3[D3] = 1e3, a3)[c4] || 1, C3 = this.$d.getTime() + u4 * F4;
            return p2.w(C3, this);
          }, h4.subtract = function(u4, D4) {
            return this.add(-1 * u4, D4);
          }, h4.format = function(u4) {
            var D4 = this;
            if (!this.isValid())
              return "Invalid Date";
            var e4 = u4 || "YYYY-MM-DDTHH:mm:ssZ", t4 = p2.z(this), r4 = this.$locale(), n3 = this.$H, s4 = this.$m, o3 = this.$M, i4 = r4.weekdays, a3 = r4.months, c4 = function(u5, t5, r5, n4) {
              return u5 && (u5[t5] || u5(D4, e4)) || r5[t5].substr(0, n4);
            }, h5 = function(u5) {
              return p2.s(n3 % 12 || 12, u5, "0");
            }, F4 = r4.meridiem || function(u5, D5, e5) {
              var t5 = u5 < 12 ? "AM" : "PM";
              return e5 ? t5.toLowerCase() : t5;
            }, C3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: o3 + 1, MM: p2.s(o3 + 1, 2, "0"), MMM: c4(r4.monthsShort, o3, a3, 3), MMMM: c4(a3, o3), D: this.$D, DD: p2.s(this.$D, 2, "0"), d: String(this.$W), dd: c4(r4.weekdaysMin, this.$W, i4, 2), ddd: c4(r4.weekdaysShort, this.$W, i4, 3), dddd: i4[this.$W], H: String(n3), HH: p2.s(n3, 2, "0"), h: h5(1), hh: h5(2), a: F4(n3, s4, true), A: F4(n3, s4, false), m: String(s4), mm: p2.s(s4, 2, "0"), s: String(this.$s), ss: p2.s(this.$s, 2, "0"), SSS: p2.s(this.$ms, 3, "0"), Z: t4 };
            return e4.replace(l2, function(u5, D5) {
              return D5 || C3[u5] || t4.replace(":", "");
            });
          }, h4.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, h4.diff = function(u4, r4, a3) {
            var l3, c4 = p2.p(r4), h5 = d2(u4), F4 = 6e4 * (h5.utcOffset() - this.utcOffset()), C3 = this - h5, f5 = p2.m(this, h5);
            return f5 = (l3 = {}, l3[i3] = f5 / 12, l3[s3] = f5, l3[o2] = f5 / 3, l3[n2] = (C3 - F4) / 6048e5, l3.day = (C3 - F4) / 864e5, l3[t3] = C3 / 36e5, l3[e3] = C3 / 6e4, l3[D3] = C3 / 1e3, l3)[c4] || C3, a3 ? f5 : p2.a(f5);
          }, h4.daysInMonth = function() {
            return this.endOf(s3).$D;
          }, h4.$locale = function() {
            return f4[this.$L];
          }, h4.locale = function(u4, D4) {
            if (!u4)
              return this.$L;
            var e4 = this.clone(), t4 = g2(u4, D4, true);
            return t4 && (e4.$L = t4), e4;
          }, h4.clone = function() {
            return p2.w(this.$d, this);
          }, h4.toDate = function() {
            return new Date(this.valueOf());
          }, h4.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, h4.toISOString = function() {
            return this.$d.toISOString();
          }, h4.toString = function() {
            return this.$d.toUTCString();
          }, c3;
        }();
        return d2.prototype = m3.prototype, d2.extend = function(u4, D4) {
          return u4(D4, m3, d2), d2;
        }, d2.locale = g2, d2.isDayjs = E2, d2.unix = function(u4) {
          return d2(1e3 * u4);
        }, d2.en = f4[C2], d2.Ls = f4, d2;
      }();
    });
    var O = { dateFormat: "HH:mm:ss", formatOptions: { date: true, colors: false, compact: true } };
    var M = (u2) => u2 ? `[${u2}]` : "";
    var S2 = class {
      constructor(u2) {
        this.options = Object.assign({}, O, u2);
      }
      formatStack(u2) {
        return "  " + A2(u2).join("\n  ");
      }
      formatArgs(u2) {
        const e3 = u2.map((u3) => u3 && "string" == typeof u3.stack ? u3.message + "\n" + this.formatStack(u3.stack) : u3);
        return "function" == typeof D.formatWithOptions ? D.formatWithOptions(this.options.formatOptions, ...e3) : D.format(...e3);
      }
      formatDate(u2) {
        return this.options.formatOptions.date ? function(u3, D2) {
          return w(D2).format(u3);
        }(this.options.dateFormat, u2) : "";
      }
      filterAndJoin(u2) {
        return u2.filter((u3) => u3).join(" ");
      }
      formatLogObj(u2) {
        const D2 = this.formatArgs(u2.args);
        return this.filterAndJoin([M(u2.type), M(u2.tag), D2]);
      }
      log(u2, { async: D2, stdout: e3, stderr: r3 } = {}) {
        return function(u3, D3, e4 = "default") {
          const r4 = D3.__write || D3.write;
          switch (e4) {
            case "async":
              return new Promise((e5) => {
                true === r4.call(D3, u3) ? e5() : D3.once("drain", () => {
                  e5();
                });
              });
            case "sync":
              return t2.writeSync(D3.fd, u3);
            default:
              return r4.call(D3, u3);
          }
        }(this.formatLogObj(u2, { width: e3.columns || 0 }) + "\n", u2.level < 2 ? r3 : e3, D2 ? "async" : "default");
      }
    };
    var I = (u2) => "string" == typeof u2 ? u2.replace((({ onlyFirst: u3 = false } = {}) => {
      const D2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(D2, u3 ? void 0 : "g");
    })(), "") : u2;
    var k = (u2) => !Number.isNaN(u2) && (u2 >= 4352 && (u2 <= 4447 || 9001 === u2 || 9002 === u2 || 11904 <= u2 && u2 <= 12871 && 12351 !== u2 || 12880 <= u2 && u2 <= 19903 || 19968 <= u2 && u2 <= 42182 || 43360 <= u2 && u2 <= 43388 || 44032 <= u2 && u2 <= 55203 || 63744 <= u2 && u2 <= 64255 || 65040 <= u2 && u2 <= 65049 || 65072 <= u2 && u2 <= 65131 || 65281 <= u2 && u2 <= 65376 || 65504 <= u2 && u2 <= 65510 || 110592 <= u2 && u2 <= 110593 || 127488 <= u2 && u2 <= 127569 || 131072 <= u2 && u2 <= 262141));
    var R = k;
    var T = k;
    R.default = T;
    var L = (u2) => {
      if ("string" != typeof (u2 = u2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === u2.length)
        return 0;
      u2 = I(u2);
      let D2 = 0;
      for (let e3 = 0; e3 < u2.length; e3++) {
        const t3 = u2.codePointAt(e3);
        t3 <= 31 || t3 >= 127 && t3 <= 159 || (t3 >= 768 && t3 <= 879 || (t3 > 65535 && e3++, D2 += R(t3) ? 2 : 1));
      }
      return D2;
    };
    var $ = L;
    var x2 = L;
    $.default = x2;
    var U = /[|\\{}()[\]^$+*?.]/g;
    var j = function(u2) {
      if ("string" != typeof u2)
        throw new TypeError("Expected a string");
      return u2.replace(U, "\\$&");
    };
    var { platform: P } = process;
    var N = { tick: "\u2714", cross: "\u2716", star: "\u2605", square: "\u2587", squareSmall: "\u25FB", squareSmallFilled: "\u25FC", play: "\u25B6", circle: "\u25EF", circleFilled: "\u25C9", circleDotted: "\u25CC", circleDouble: "\u25CE", circleCircle: "\u24DE", circleCross: "\u24E7", circlePipe: "\u24BE", circleQuestionMark: "?\u20DD", bullet: "\u25CF", dot: "\u2024", line: "\u2500", ellipsis: "\u2026", pointer: "\u276F", pointerSmall: "\u203A", info: "\u2139", warning: "\u26A0", hamburger: "\u2630", smiley: "\u32E1", mustache: "\u0DF4", heart: "\u2665", nodejs: "\u2B22", arrowUp: "\u2191", arrowDown: "\u2193", arrowLeft: "\u2190", arrowRight: "\u2192", radioOn: "\u25C9", radioOff: "\u25EF", checkboxOn: "\u2612", checkboxOff: "\u2610", checkboxCircleOn: "\u24E7", checkboxCircleOff: "\u24BE", questionMarkPrefix: "?\u20DD", oneHalf: "\xBD", oneThird: "\u2153", oneQuarter: "\xBC", oneFifth: "\u2155", oneSixth: "\u2159", oneSeventh: "\u2150", oneEighth: "\u215B", oneNinth: "\u2151", oneTenth: "\u2152", twoThirds: "\u2154", twoFifths: "\u2156", threeQuarters: "\xBE", threeFifths: "\u2157", threeEighths: "\u215C", fourFifths: "\u2158", fiveSixths: "\u215A", fiveEighths: "\u215D", sevenEighths: "\u215E" };
    var q = { tick: "\u221A", cross: "\xD7", star: "*", square: "\u2588", squareSmall: "[ ]", squareSmallFilled: "[\u2588]", play: "\u25BA", circle: "( )", circleFilled: "(*)", circleDotted: "( )", circleDouble: "( )", circleCircle: "(\u25CB)", circleCross: "(\xD7)", circlePipe: "(\u2502)", circleQuestionMark: "(?)", bullet: "*", dot: ".", line: "\u2500", ellipsis: "...", pointer: ">", pointerSmall: "\xBB", info: "i", warning: "\u203C", hamburger: "\u2261", smiley: "\u263A", mustache: "\u250C\u2500\u2510", heart: N.heart, nodejs: "\u2666", arrowUp: N.arrowUp, arrowDown: N.arrowDown, arrowLeft: N.arrowLeft, arrowRight: N.arrowRight, radioOn: "(*)", radioOff: "( )", checkboxOn: "[\xD7]", checkboxOff: "[ ]", checkboxCircleOn: "(\xD7)", checkboxCircleOff: "( )", questionMarkPrefix: "\uFF1F", oneHalf: "1/2", oneThird: "1/3", oneQuarter: "1/4", oneFifth: "1/5", oneSixth: "1/6", oneSeventh: "1/7", oneEighth: "1/8", oneNinth: "1/9", oneTenth: "1/10", twoThirds: "2/3", twoFifths: "2/5", threeQuarters: "3/4", threeFifths: "3/5", threeEighths: "3/8", fourFifths: "4/5", fiveSixths: "5/6", fiveEighths: "5/8", sevenEighths: "7/8" };
    "linux" === P && (N.questionMarkPrefix = "?");
    var Y = "win32" === P ? q : N;
    var H = Object.assign((u2) => {
      if (Y === N)
        return u2;
      for (const [D2, e3] of Object.entries(N))
        e3 !== Y[D2] && (u2 = u2.replace(new RegExp(j(e3), "g"), Y[D2]));
      return u2;
    }, Y);
    var V = N;
    var W = q;
    H.main = V, H.windows = W;
    var G = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    var z2 = {};
    for (const u2 of Object.keys(G))
      z2[G[u2]] = u2;
    var Q = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
    var J = Q;
    for (const u2 of Object.keys(Q)) {
      if (!("channels" in Q[u2]))
        throw new Error("missing channels property: " + u2);
      if (!("labels" in Q[u2]))
        throw new Error("missing channel labels property: " + u2);
      if (Q[u2].labels.length !== Q[u2].channels)
        throw new Error("channel and label counts mismatch: " + u2);
      const { channels: D2, labels: e3 } = Q[u2];
      delete Q[u2].channels, delete Q[u2].labels, Object.defineProperty(Q[u2], "channels", { value: D2 }), Object.defineProperty(Q[u2], "labels", { value: e3 });
    }
    function K(u2) {
      const D2 = function() {
        const u3 = {}, D3 = Object.keys(J);
        for (let e4 = D3.length, t3 = 0; t3 < e4; t3++)
          u3[D3[t3]] = { distance: -1, parent: null };
        return u3;
      }(), e3 = [u2];
      for (D2[u2].distance = 0; e3.length; ) {
        const u3 = e3.pop(), t3 = Object.keys(J[u3]);
        for (let r3 = t3.length, n2 = 0; n2 < r3; n2++) {
          const r4 = t3[n2], s3 = D2[r4];
          -1 === s3.distance && (s3.distance = D2[u3].distance + 1, s3.parent = u3, e3.unshift(r4));
        }
      }
      return D2;
    }
    function Z2(u2, D2) {
      return function(e3) {
        return D2(u2(e3));
      };
    }
    function X(u2, D2) {
      const e3 = [D2[u2].parent, u2];
      let t3 = J[D2[u2].parent][u2], r3 = D2[u2].parent;
      for (; D2[r3].parent; )
        e3.unshift(D2[r3].parent), t3 = Z2(J[D2[r3].parent][r3], t3), r3 = D2[r3].parent;
      return t3.conversion = e3, t3;
    }
    Q.rgb.hsl = function(u2) {
      const D2 = u2[0] / 255, e3 = u2[1] / 255, t3 = u2[2] / 255, r3 = Math.min(D2, e3, t3), n2 = Math.max(D2, e3, t3), s3 = n2 - r3;
      let o2, i3;
      n2 === r3 ? o2 = 0 : D2 === n2 ? o2 = (e3 - t3) / s3 : e3 === n2 ? o2 = 2 + (t3 - D2) / s3 : t3 === n2 && (o2 = 4 + (D2 - e3) / s3), o2 = Math.min(60 * o2, 360), o2 < 0 && (o2 += 360);
      const a2 = (r3 + n2) / 2;
      return i3 = n2 === r3 ? 0 : a2 <= 0.5 ? s3 / (n2 + r3) : s3 / (2 - n2 - r3), [o2, 100 * i3, 100 * a2];
    }, Q.rgb.hsv = function(u2) {
      let D2, e3, t3, r3, n2;
      const s3 = u2[0] / 255, o2 = u2[1] / 255, i3 = u2[2] / 255, a2 = Math.max(s3, o2, i3), l2 = a2 - Math.min(s3, o2, i3), c2 = function(u3) {
        return (a2 - u3) / 6 / l2 + 0.5;
      };
      return 0 === l2 ? (r3 = 0, n2 = 0) : (n2 = l2 / a2, D2 = c2(s3), e3 = c2(o2), t3 = c2(i3), s3 === a2 ? r3 = t3 - e3 : o2 === a2 ? r3 = 1 / 3 + D2 - t3 : i3 === a2 && (r3 = 2 / 3 + e3 - D2), r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1)), [360 * r3, 100 * n2, 100 * a2];
    }, Q.rgb.hwb = function(u2) {
      const D2 = u2[0], e3 = u2[1];
      let t3 = u2[2];
      const r3 = Q.rgb.hsl(u2)[0], n2 = 1 / 255 * Math.min(D2, Math.min(e3, t3));
      return t3 = 1 - 1 / 255 * Math.max(D2, Math.max(e3, t3)), [r3, 100 * n2, 100 * t3];
    }, Q.rgb.cmyk = function(u2) {
      const D2 = u2[0] / 255, e3 = u2[1] / 255, t3 = u2[2] / 255, r3 = Math.min(1 - D2, 1 - e3, 1 - t3);
      return [100 * ((1 - D2 - r3) / (1 - r3) || 0), 100 * ((1 - e3 - r3) / (1 - r3) || 0), 100 * ((1 - t3 - r3) / (1 - r3) || 0), 100 * r3];
    }, Q.rgb.keyword = function(u2) {
      const D2 = z2[u2];
      if (D2)
        return D2;
      let e3, t3 = 1 / 0;
      for (const D3 of Object.keys(G)) {
        const s3 = (n2 = G[D3], ((r3 = u2)[0] - n2[0]) ** 2 + (r3[1] - n2[1]) ** 2 + (r3[2] - n2[2]) ** 2);
        s3 < t3 && (t3 = s3, e3 = D3);
      }
      var r3, n2;
      return e3;
    }, Q.keyword.rgb = function(u2) {
      return G[u2];
    }, Q.rgb.xyz = function(u2) {
      let D2 = u2[0] / 255, e3 = u2[1] / 255, t3 = u2[2] / 255;
      D2 = D2 > 0.04045 ? ((D2 + 0.055) / 1.055) ** 2.4 : D2 / 12.92, e3 = e3 > 0.04045 ? ((e3 + 0.055) / 1.055) ** 2.4 : e3 / 12.92, t3 = t3 > 0.04045 ? ((t3 + 0.055) / 1.055) ** 2.4 : t3 / 12.92;
      return [100 * (0.4124 * D2 + 0.3576 * e3 + 0.1805 * t3), 100 * (0.2126 * D2 + 0.7152 * e3 + 0.0722 * t3), 100 * (0.0193 * D2 + 0.1192 * e3 + 0.9505 * t3)];
    }, Q.rgb.lab = function(u2) {
      const D2 = Q.rgb.xyz(u2);
      let e3 = D2[0], t3 = D2[1], r3 = D2[2];
      e3 /= 95.047, t3 /= 100, r3 /= 108.883, e3 = e3 > 8856e-6 ? e3 ** (1 / 3) : 7.787 * e3 + 16 / 116, t3 = t3 > 8856e-6 ? t3 ** (1 / 3) : 7.787 * t3 + 16 / 116, r3 = r3 > 8856e-6 ? r3 ** (1 / 3) : 7.787 * r3 + 16 / 116;
      return [116 * t3 - 16, 500 * (e3 - t3), 200 * (t3 - r3)];
    }, Q.hsl.rgb = function(u2) {
      const D2 = u2[0] / 360, e3 = u2[1] / 100, t3 = u2[2] / 100;
      let r3, n2, s3;
      if (0 === e3)
        return s3 = 255 * t3, [s3, s3, s3];
      r3 = t3 < 0.5 ? t3 * (1 + e3) : t3 + e3 - t3 * e3;
      const o2 = 2 * t3 - r3, i3 = [0, 0, 0];
      for (let u3 = 0; u3 < 3; u3++)
        n2 = D2 + 1 / 3 * -(u3 - 1), n2 < 0 && n2++, n2 > 1 && n2--, s3 = 6 * n2 < 1 ? o2 + 6 * (r3 - o2) * n2 : 2 * n2 < 1 ? r3 : 3 * n2 < 2 ? o2 + (r3 - o2) * (2 / 3 - n2) * 6 : o2, i3[u3] = 255 * s3;
      return i3;
    }, Q.hsl.hsv = function(u2) {
      const D2 = u2[0];
      let e3 = u2[1] / 100, t3 = u2[2] / 100, r3 = e3;
      const n2 = Math.max(t3, 0.01);
      t3 *= 2, e3 *= t3 <= 1 ? t3 : 2 - t3, r3 *= n2 <= 1 ? n2 : 2 - n2;
      return [D2, 100 * (0 === t3 ? 2 * r3 / (n2 + r3) : 2 * e3 / (t3 + e3)), 100 * ((t3 + e3) / 2)];
    }, Q.hsv.rgb = function(u2) {
      const D2 = u2[0] / 60, e3 = u2[1] / 100;
      let t3 = u2[2] / 100;
      const r3 = Math.floor(D2) % 6, n2 = D2 - Math.floor(D2), s3 = 255 * t3 * (1 - e3), o2 = 255 * t3 * (1 - e3 * n2), i3 = 255 * t3 * (1 - e3 * (1 - n2));
      switch (t3 *= 255, r3) {
        case 0:
          return [t3, i3, s3];
        case 1:
          return [o2, t3, s3];
        case 2:
          return [s3, t3, i3];
        case 3:
          return [s3, o2, t3];
        case 4:
          return [i3, s3, t3];
        case 5:
          return [t3, s3, o2];
      }
    }, Q.hsv.hsl = function(u2) {
      const D2 = u2[0], e3 = u2[1] / 100, t3 = u2[2] / 100, r3 = Math.max(t3, 0.01);
      let n2, s3;
      s3 = (2 - e3) * t3;
      const o2 = (2 - e3) * r3;
      return n2 = e3 * r3, n2 /= o2 <= 1 ? o2 : 2 - o2, n2 = n2 || 0, s3 /= 2, [D2, 100 * n2, 100 * s3];
    }, Q.hwb.rgb = function(u2) {
      const D2 = u2[0] / 360;
      let e3 = u2[1] / 100, t3 = u2[2] / 100;
      const r3 = e3 + t3;
      let n2;
      r3 > 1 && (e3 /= r3, t3 /= r3);
      const s3 = Math.floor(6 * D2), o2 = 1 - t3;
      n2 = 6 * D2 - s3, 0 != (1 & s3) && (n2 = 1 - n2);
      const i3 = e3 + n2 * (o2 - e3);
      let a2, l2, c2;
      switch (s3) {
        default:
        case 6:
        case 0:
          a2 = o2, l2 = i3, c2 = e3;
          break;
        case 1:
          a2 = i3, l2 = o2, c2 = e3;
          break;
        case 2:
          a2 = e3, l2 = o2, c2 = i3;
          break;
        case 3:
          a2 = e3, l2 = i3, c2 = o2;
          break;
        case 4:
          a2 = i3, l2 = e3, c2 = o2;
          break;
        case 5:
          a2 = o2, l2 = e3, c2 = i3;
      }
      return [255 * a2, 255 * l2, 255 * c2];
    }, Q.cmyk.rgb = function(u2) {
      const D2 = u2[0] / 100, e3 = u2[1] / 100, t3 = u2[2] / 100, r3 = u2[3] / 100;
      return [255 * (1 - Math.min(1, D2 * (1 - r3) + r3)), 255 * (1 - Math.min(1, e3 * (1 - r3) + r3)), 255 * (1 - Math.min(1, t3 * (1 - r3) + r3))];
    }, Q.xyz.rgb = function(u2) {
      const D2 = u2[0] / 100, e3 = u2[1] / 100, t3 = u2[2] / 100;
      let r3, n2, s3;
      return r3 = 3.2406 * D2 + -1.5372 * e3 + -0.4986 * t3, n2 = -0.9689 * D2 + 1.8758 * e3 + 0.0415 * t3, s3 = 0.0557 * D2 + -0.204 * e3 + 1.057 * t3, r3 = r3 > 31308e-7 ? 1.055 * r3 ** (1 / 2.4) - 0.055 : 12.92 * r3, n2 = n2 > 31308e-7 ? 1.055 * n2 ** (1 / 2.4) - 0.055 : 12.92 * n2, s3 = s3 > 31308e-7 ? 1.055 * s3 ** (1 / 2.4) - 0.055 : 12.92 * s3, r3 = Math.min(Math.max(0, r3), 1), n2 = Math.min(Math.max(0, n2), 1), s3 = Math.min(Math.max(0, s3), 1), [255 * r3, 255 * n2, 255 * s3];
    }, Q.xyz.lab = function(u2) {
      let D2 = u2[0], e3 = u2[1], t3 = u2[2];
      D2 /= 95.047, e3 /= 100, t3 /= 108.883, D2 = D2 > 8856e-6 ? D2 ** (1 / 3) : 7.787 * D2 + 16 / 116, e3 = e3 > 8856e-6 ? e3 ** (1 / 3) : 7.787 * e3 + 16 / 116, t3 = t3 > 8856e-6 ? t3 ** (1 / 3) : 7.787 * t3 + 16 / 116;
      return [116 * e3 - 16, 500 * (D2 - e3), 200 * (e3 - t3)];
    }, Q.lab.xyz = function(u2) {
      let D2, e3, t3;
      e3 = (u2[0] + 16) / 116, D2 = u2[1] / 500 + e3, t3 = e3 - u2[2] / 200;
      const r3 = e3 ** 3, n2 = D2 ** 3, s3 = t3 ** 3;
      return e3 = r3 > 8856e-6 ? r3 : (e3 - 16 / 116) / 7.787, D2 = n2 > 8856e-6 ? n2 : (D2 - 16 / 116) / 7.787, t3 = s3 > 8856e-6 ? s3 : (t3 - 16 / 116) / 7.787, D2 *= 95.047, e3 *= 100, t3 *= 108.883, [D2, e3, t3];
    }, Q.lab.lch = function(u2) {
      const D2 = u2[0], e3 = u2[1], t3 = u2[2];
      let r3;
      r3 = 360 * Math.atan2(t3, e3) / 2 / Math.PI, r3 < 0 && (r3 += 360);
      return [D2, Math.sqrt(e3 * e3 + t3 * t3), r3];
    }, Q.lch.lab = function(u2) {
      const D2 = u2[0], e3 = u2[1], t3 = u2[2] / 360 * 2 * Math.PI;
      return [D2, e3 * Math.cos(t3), e3 * Math.sin(t3)];
    }, Q.rgb.ansi16 = function(u2, D2 = null) {
      const [e3, t3, r3] = u2;
      let n2 = null === D2 ? Q.rgb.hsv(u2)[2] : D2;
      if (n2 = Math.round(n2 / 50), 0 === n2)
        return 30;
      let s3 = 30 + (Math.round(r3 / 255) << 2 | Math.round(t3 / 255) << 1 | Math.round(e3 / 255));
      return 2 === n2 && (s3 += 60), s3;
    }, Q.hsv.ansi16 = function(u2) {
      return Q.rgb.ansi16(Q.hsv.rgb(u2), u2[2]);
    }, Q.rgb.ansi256 = function(u2) {
      const D2 = u2[0], e3 = u2[1], t3 = u2[2];
      if (D2 === e3 && e3 === t3)
        return D2 < 8 ? 16 : D2 > 248 ? 231 : Math.round((D2 - 8) / 247 * 24) + 232;
      return 16 + 36 * Math.round(D2 / 255 * 5) + 6 * Math.round(e3 / 255 * 5) + Math.round(t3 / 255 * 5);
    }, Q.ansi16.rgb = function(u2) {
      let D2 = u2 % 10;
      if (0 === D2 || 7 === D2)
        return u2 > 50 && (D2 += 3.5), D2 = D2 / 10.5 * 255, [D2, D2, D2];
      const e3 = 0.5 * (1 + ~~(u2 > 50));
      return [(1 & D2) * e3 * 255, (D2 >> 1 & 1) * e3 * 255, (D2 >> 2 & 1) * e3 * 255];
    }, Q.ansi256.rgb = function(u2) {
      if (u2 >= 232) {
        const D3 = 10 * (u2 - 232) + 8;
        return [D3, D3, D3];
      }
      let D2;
      u2 -= 16;
      return [Math.floor(u2 / 36) / 5 * 255, Math.floor((D2 = u2 % 36) / 6) / 5 * 255, D2 % 6 / 5 * 255];
    }, Q.rgb.hex = function(u2) {
      const D2 = (((255 & Math.round(u2[0])) << 16) + ((255 & Math.round(u2[1])) << 8) + (255 & Math.round(u2[2]))).toString(16).toUpperCase();
      return "000000".substring(D2.length) + D2;
    }, Q.hex.rgb = function(u2) {
      const D2 = u2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!D2)
        return [0, 0, 0];
      let e3 = D2[0];
      3 === D2[0].length && (e3 = e3.split("").map((u3) => u3 + u3).join(""));
      const t3 = parseInt(e3, 16);
      return [t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3];
    }, Q.rgb.hcg = function(u2) {
      const D2 = u2[0] / 255, e3 = u2[1] / 255, t3 = u2[2] / 255, r3 = Math.max(Math.max(D2, e3), t3), n2 = Math.min(Math.min(D2, e3), t3), s3 = r3 - n2;
      let o2, i3;
      return o2 = s3 < 1 ? n2 / (1 - s3) : 0, i3 = s3 <= 0 ? 0 : r3 === D2 ? (e3 - t3) / s3 % 6 : r3 === e3 ? 2 + (t3 - D2) / s3 : 4 + (D2 - e3) / s3, i3 /= 6, i3 %= 1, [360 * i3, 100 * s3, 100 * o2];
    }, Q.hsl.hcg = function(u2) {
      const D2 = u2[1] / 100, e3 = u2[2] / 100, t3 = e3 < 0.5 ? 2 * D2 * e3 : 2 * D2 * (1 - e3);
      let r3 = 0;
      return t3 < 1 && (r3 = (e3 - 0.5 * t3) / (1 - t3)), [u2[0], 100 * t3, 100 * r3];
    }, Q.hsv.hcg = function(u2) {
      const D2 = u2[1] / 100, e3 = u2[2] / 100, t3 = D2 * e3;
      let r3 = 0;
      return t3 < 1 && (r3 = (e3 - t3) / (1 - t3)), [u2[0], 100 * t3, 100 * r3];
    }, Q.hcg.rgb = function(u2) {
      const D2 = u2[0] / 360, e3 = u2[1] / 100, t3 = u2[2] / 100;
      if (0 === e3)
        return [255 * t3, 255 * t3, 255 * t3];
      const r3 = [0, 0, 0], n2 = D2 % 1 * 6, s3 = n2 % 1, o2 = 1 - s3;
      let i3 = 0;
      switch (Math.floor(n2)) {
        case 0:
          r3[0] = 1, r3[1] = s3, r3[2] = 0;
          break;
        case 1:
          r3[0] = o2, r3[1] = 1, r3[2] = 0;
          break;
        case 2:
          r3[0] = 0, r3[1] = 1, r3[2] = s3;
          break;
        case 3:
          r3[0] = 0, r3[1] = o2, r3[2] = 1;
          break;
        case 4:
          r3[0] = s3, r3[1] = 0, r3[2] = 1;
          break;
        default:
          r3[0] = 1, r3[1] = 0, r3[2] = o2;
      }
      return i3 = (1 - e3) * t3, [255 * (e3 * r3[0] + i3), 255 * (e3 * r3[1] + i3), 255 * (e3 * r3[2] + i3)];
    }, Q.hcg.hsv = function(u2) {
      const D2 = u2[1] / 100, e3 = D2 + u2[2] / 100 * (1 - D2);
      let t3 = 0;
      return e3 > 0 && (t3 = D2 / e3), [u2[0], 100 * t3, 100 * e3];
    }, Q.hcg.hsl = function(u2) {
      const D2 = u2[1] / 100, e3 = u2[2] / 100 * (1 - D2) + 0.5 * D2;
      let t3 = 0;
      return e3 > 0 && e3 < 0.5 ? t3 = D2 / (2 * e3) : e3 >= 0.5 && e3 < 1 && (t3 = D2 / (2 * (1 - e3))), [u2[0], 100 * t3, 100 * e3];
    }, Q.hcg.hwb = function(u2) {
      const D2 = u2[1] / 100, e3 = D2 + u2[2] / 100 * (1 - D2);
      return [u2[0], 100 * (e3 - D2), 100 * (1 - e3)];
    }, Q.hwb.hcg = function(u2) {
      const D2 = u2[1] / 100, e3 = 1 - u2[2] / 100, t3 = e3 - D2;
      let r3 = 0;
      return t3 < 1 && (r3 = (e3 - t3) / (1 - t3)), [u2[0], 100 * t3, 100 * r3];
    }, Q.apple.rgb = function(u2) {
      return [u2[0] / 65535 * 255, u2[1] / 65535 * 255, u2[2] / 65535 * 255];
    }, Q.rgb.apple = function(u2) {
      return [u2[0] / 255 * 65535, u2[1] / 255 * 65535, u2[2] / 255 * 65535];
    }, Q.gray.rgb = function(u2) {
      return [u2[0] / 100 * 255, u2[0] / 100 * 255, u2[0] / 100 * 255];
    }, Q.gray.hsl = function(u2) {
      return [0, 0, u2[0]];
    }, Q.gray.hsv = Q.gray.hsl, Q.gray.hwb = function(u2) {
      return [0, 100, u2[0]];
    }, Q.gray.cmyk = function(u2) {
      return [0, 0, 0, u2[0]];
    }, Q.gray.lab = function(u2) {
      return [u2[0], 0, 0];
    }, Q.gray.hex = function(u2) {
      const D2 = 255 & Math.round(u2[0] / 100 * 255), e3 = ((D2 << 16) + (D2 << 8) + D2).toString(16).toUpperCase();
      return "000000".substring(e3.length) + e3;
    }, Q.rgb.gray = function(u2) {
      return [(u2[0] + u2[1] + u2[2]) / 3 / 255 * 100];
    };
    var uu = {};
    Object.keys(J).forEach((u2) => {
      uu[u2] = {}, Object.defineProperty(uu[u2], "channels", { value: J[u2].channels }), Object.defineProperty(uu[u2], "labels", { value: J[u2].labels });
      const D2 = function(u3) {
        const D3 = K(u3), e3 = {}, t3 = Object.keys(D3);
        for (let u4 = t3.length, r3 = 0; r3 < u4; r3++) {
          const u5 = t3[r3];
          null !== D3[u5].parent && (e3[u5] = X(u5, D3));
        }
        return e3;
      }(u2);
      Object.keys(D2).forEach((e3) => {
        const t3 = D2[e3];
        uu[u2][e3] = function(u3) {
          const D3 = function(...D4) {
            const e4 = D4[0];
            if (null == e4)
              return e4;
            e4.length > 1 && (D4 = e4);
            const t4 = u3(D4);
            if ("object" == typeof t4)
              for (let u4 = t4.length, D5 = 0; D5 < u4; D5++)
                t4[D5] = Math.round(t4[D5]);
            return t4;
          };
          return "conversion" in u3 && (D3.conversion = u3.conversion), D3;
        }(t3), uu[u2][e3].raw = function(u3) {
          const D3 = function(...D4) {
            const e4 = D4[0];
            return null == e4 ? e4 : (e4.length > 1 && (D4 = e4), u3(D4));
          };
          return "conversion" in u3 && (D3.conversion = u3.conversion), D3;
        }(t3);
      });
    });
    var Du = uu;
    var eu = s2(function(u2) {
      const D2 = (u3, D3) => (...e4) => `\x1B[${u3(...e4) + D3}m`, e3 = (u3, D3) => (...e4) => {
        const t4 = u3(...e4);
        return `\x1B[${38 + D3};5;${t4}m`;
      }, t3 = (u3, D3) => (...e4) => {
        const t4 = u3(...e4);
        return `\x1B[${38 + D3};2;${t4[0]};${t4[1]};${t4[2]}m`;
      }, r3 = (u3) => u3, n2 = (u3, D3, e4) => [u3, D3, e4], s3 = (u3, D3, e4) => {
        Object.defineProperty(u3, D3, { get: () => {
          const t4 = e4();
          return Object.defineProperty(u3, D3, { value: t4, enumerable: true, configurable: true }), t4;
        }, enumerable: true, configurable: true });
      };
      let o2;
      const i3 = (u3, D3, e4, t4) => {
        void 0 === o2 && (o2 = Du);
        const r4 = t4 ? 10 : 0, n3 = {};
        for (const [t5, s4] of Object.entries(o2)) {
          const o3 = "ansi16" === t5 ? "ansi" : t5;
          t5 === D3 ? n3[o3] = u3(e4, r4) : "object" == typeof s4 && (n3[o3] = u3(s4[D3], r4));
        }
        return n3;
      };
      Object.defineProperty(u2, "exports", { enumerable: true, get: function() {
        const u3 = /* @__PURE__ */ new Map(), o3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
        o3.color.gray = o3.color.blackBright, o3.bgColor.bgGray = o3.bgColor.bgBlackBright, o3.color.grey = o3.color.blackBright, o3.bgColor.bgGrey = o3.bgColor.bgBlackBright;
        for (const [D3, e4] of Object.entries(o3)) {
          for (const [D4, t4] of Object.entries(e4))
            o3[D4] = { open: `\x1B[${t4[0]}m`, close: `\x1B[${t4[1]}m` }, e4[D4] = o3[D4], u3.set(t4[0], t4[1]);
          Object.defineProperty(o3, D3, { value: e4, enumerable: false });
        }
        return Object.defineProperty(o3, "codes", { value: u3, enumerable: false }), o3.color.close = "\x1B[39m", o3.bgColor.close = "\x1B[49m", s3(o3.color, "ansi", () => i3(D2, "ansi16", r3, false)), s3(o3.color, "ansi256", () => i3(e3, "ansi256", r3, false)), s3(o3.color, "ansi16m", () => i3(t3, "rgb", n2, false)), s3(o3.bgColor, "ansi", () => i3(D2, "ansi16", r3, true)), s3(o3.bgColor, "ansi256", () => i3(e3, "ansi256", r3, true)), s3(o3.bgColor, "ansi16m", () => i3(t3, "rgb", n2, true)), o3;
      } });
    });
    var tu = (u2, D2 = process.argv) => {
      const e3 = u2.startsWith("-") ? "" : 1 === u2.length ? "-" : "--", t3 = D2.indexOf(e3 + u2), r3 = D2.indexOf("--");
      return -1 !== t3 && (-1 === r3 || t3 < r3);
    };
    var { env: ru } = process;
    var nu;
    function su(u2) {
      return 0 !== u2 && { level: u2, hasBasic: true, has256: u2 >= 2, has16m: u2 >= 3 };
    }
    function ou(u2, D2) {
      if (0 === nu)
        return 0;
      if (tu("color=16m") || tu("color=full") || tu("color=truecolor"))
        return 3;
      if (tu("color=256"))
        return 2;
      if (u2 && !D2 && void 0 === nu)
        return 0;
      const e3 = nu || 0;
      if ("dumb" === ru.TERM)
        return e3;
      if ("win32" === process.platform) {
        const u3 = r2.release().split(".");
        return Number(u3[0]) >= 10 && Number(u3[2]) >= 10586 ? Number(u3[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in ru)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((u3) => u3 in ru) || "codeship" === ru.CI_NAME ? 1 : e3;
      if ("TEAMCITY_VERSION" in ru)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ru.TEAMCITY_VERSION) ? 1 : 0;
      if ("GITHUB_ACTIONS" in ru)
        return 1;
      if ("truecolor" === ru.COLORTERM)
        return 3;
      if ("TERM_PROGRAM" in ru) {
        const u3 = parseInt((ru.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (ru.TERM_PROGRAM) {
          case "iTerm.app":
            return u3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(ru.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ru.TERM) || "COLORTERM" in ru ? 1 : e3;
    }
    tu("no-color") || tu("no-colors") || tu("color=false") || tu("color=never") ? nu = 0 : (tu("color") || tu("colors") || tu("color=true") || tu("color=always")) && (nu = 1), "FORCE_COLOR" in ru && (nu = "true" === ru.FORCE_COLOR ? 1 : "false" === ru.FORCE_COLOR ? 0 : 0 === ru.FORCE_COLOR.length ? 1 : Math.min(parseInt(ru.FORCE_COLOR, 10), 3));
    var iu = { supportsColor: function(u2) {
      return su(ou(u2, u2 && u2.isTTY));
    }, stdout: su(ou(true, n.isatty(1))), stderr: su(ou(true, n.isatty(2))) };
    var au = { stringReplaceAll: (u2, D2, e3) => {
      let t3 = u2.indexOf(D2);
      if (-1 === t3)
        return u2;
      const r3 = D2.length;
      let n2 = 0, s3 = "";
      do {
        s3 += u2.substr(n2, t3 - n2) + D2 + e3, n2 = t3 + r3, t3 = u2.indexOf(D2, n2);
      } while (-1 !== t3);
      return s3 += u2.substr(n2), s3;
    }, stringEncaseCRLFWithFirstIndex: (u2, D2, e3, t3) => {
      let r3 = 0, n2 = "";
      do {
        const s3 = "\r" === u2[t3 - 1];
        n2 += u2.substr(r3, (s3 ? t3 - 1 : t3) - r3) + D2 + (s3 ? "\r\n" : "\n") + e3, r3 = t3 + 1, t3 = u2.indexOf("\n", r3);
      } while (-1 !== t3);
      return n2 += u2.substr(r3), n2;
    } };
    var lu = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var cu = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var hu = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var Fu = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var Cu = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function fu(u2) {
      const D2 = "u" === u2[0], e3 = "{" === u2[1];
      return D2 && !e3 && 5 === u2.length || "x" === u2[0] && 3 === u2.length ? String.fromCharCode(parseInt(u2.slice(1), 16)) : D2 && e3 ? String.fromCodePoint(parseInt(u2.slice(2, -1), 16)) : Cu.get(u2) || u2;
    }
    function Eu(u2, D2) {
      const e3 = [], t3 = D2.trim().split(/\s*,\s*/g);
      let r3;
      for (const D3 of t3) {
        const t4 = Number(D3);
        if (Number.isNaN(t4)) {
          if (!(r3 = D3.match(hu)))
            throw new Error(`Invalid Chalk template style argument: ${D3} (in style '${u2}')`);
          e3.push(r3[2].replace(Fu, (u3, D4, e4) => D4 ? fu(D4) : e4));
        } else
          e3.push(t4);
      }
      return e3;
    }
    function gu(u2) {
      cu.lastIndex = 0;
      const D2 = [];
      let e3;
      for (; null !== (e3 = cu.exec(u2)); ) {
        const u3 = e3[1];
        if (e3[2]) {
          const t3 = Eu(u3, e3[2]);
          D2.push([u3].concat(t3));
        } else
          D2.push([u3]);
      }
      return D2;
    }
    function du(u2, D2) {
      const e3 = {};
      for (const u3 of D2)
        for (const D3 of u3.styles)
          e3[D3[0]] = u3.inverse ? null : D3.slice(1);
      let t3 = u2;
      for (const [u3, D3] of Object.entries(e3))
        if (Array.isArray(D3)) {
          if (!(u3 in t3))
            throw new Error("Unknown Chalk style: " + u3);
          t3 = D3.length > 0 ? t3[u3](...D3) : t3[u3];
        }
      return t3;
    }
    var pu = (u2, D2) => {
      const e3 = [], t3 = [];
      let r3 = [];
      if (D2.replace(lu, (D3, n2, s3, o2, i3, a2) => {
        if (n2)
          r3.push(fu(n2));
        else if (o2) {
          const D4 = r3.join("");
          r3 = [], t3.push(0 === e3.length ? D4 : du(u2, e3)(D4)), e3.push({ inverse: s3, styles: gu(o2) });
        } else if (i3) {
          if (0 === e3.length)
            throw new Error("Found extraneous } in Chalk template literal");
          t3.push(du(u2, e3)(r3.join(""))), r3 = [], e3.pop();
        } else
          r3.push(a2);
      }), t3.push(r3.join("")), e3.length > 0) {
        const u3 = `Chalk template literal is missing ${e3.length} closing bracket${1 === e3.length ? "" : "s"} (\`}\`)`;
        throw new Error(u3);
      }
      return t3.join("");
    };
    var { stdout: mu, stderr: bu } = iu;
    var { stringReplaceAll: yu, stringEncaseCRLFWithFirstIndex: Bu } = au;
    var vu = ["ansi", "ansi", "ansi256", "ansi16m"];
    var _u = /* @__PURE__ */ Object.create(null);
    var Au = class {
      constructor(u2) {
        return wu(u2);
      }
    };
    var wu = (u2) => {
      const D2 = {};
      return ((u3, D3 = {}) => {
        if (D3.level && !(Number.isInteger(D3.level) && D3.level >= 0 && D3.level <= 3))
          throw new Error("The `level` option should be an integer from 0 to 3");
        const e3 = mu ? mu.level : 0;
        u3.level = void 0 === D3.level ? e3 : D3.level;
      })(D2, u2), D2.template = (...u3) => Lu(D2.template, ...u3), Object.setPrototypeOf(D2, Ou.prototype), Object.setPrototypeOf(D2.template, D2), D2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      }, D2.template.Instance = Au, D2.template;
    };
    function Ou(u2) {
      return wu(u2);
    }
    for (const [u2, D2] of Object.entries(eu))
      _u[u2] = { get() {
        const e3 = ku(this, Iu(D2.open, D2.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, u2, { value: e3 }), e3;
      } };
    _u.visible = { get() {
      const u2 = ku(this, this._styler, true);
      return Object.defineProperty(this, "visible", { value: u2 }), u2;
    } };
    var Mu = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const u2 of Mu)
      _u[u2] = { get() {
        const { level: D2 } = this;
        return function(...e3) {
          const t3 = Iu(eu.color[vu[D2]][u2](...e3), eu.color.close, this._styler);
          return ku(this, t3, this._isEmpty);
        };
      } };
    for (const u2 of Mu) {
      _u["bg" + u2[0].toUpperCase() + u2.slice(1)] = { get() {
        const { level: D2 } = this;
        return function(...e3) {
          const t3 = Iu(eu.bgColor[vu[D2]][u2](...e3), eu.bgColor.close, this._styler);
          return ku(this, t3, this._isEmpty);
        };
      } };
    }
    var Su = Object.defineProperties(() => {
    }, { ..._u, level: { enumerable: true, get() {
      return this._generator.level;
    }, set(u2) {
      this._generator.level = u2;
    } } });
    var Iu = (u2, D2, e3) => {
      let t3, r3;
      return void 0 === e3 ? (t3 = u2, r3 = D2) : (t3 = e3.openAll + u2, r3 = D2 + e3.closeAll), { open: u2, close: D2, openAll: t3, closeAll: r3, parent: e3 };
    };
    var ku = (u2, D2, e3) => {
      const t3 = (...u3) => Ru(t3, 1 === u3.length ? "" + u3[0] : u3.join(" "));
      return Object.setPrototypeOf(t3, Su), t3._generator = u2, t3._styler = D2, t3._isEmpty = e3, t3;
    };
    var Ru = (u2, D2) => {
      if (u2.level <= 0 || !D2)
        return u2._isEmpty ? "" : D2;
      let e3 = u2._styler;
      if (void 0 === e3)
        return D2;
      const { openAll: t3, closeAll: r3 } = e3;
      if (-1 !== D2.indexOf("\x1B"))
        for (; void 0 !== e3; )
          D2 = yu(D2, e3.close, e3.open), e3 = e3.parent;
      const n2 = D2.indexOf("\n");
      return -1 !== n2 && (D2 = Bu(D2, r3, t3, n2)), t3 + D2 + r3;
    };
    var Tu;
    var Lu = (u2, ...D2) => {
      const [e3] = D2;
      if (!Array.isArray(e3))
        return D2.join(" ");
      const t3 = D2.slice(1), r3 = [e3.raw[0]];
      for (let u3 = 1; u3 < e3.length; u3++)
        r3.push(String(t3[u3 - 1]).replace(/[{}\\]/g, "\\$&"), String(e3.raw[u3]));
      return void 0 === Tu && (Tu = pu), Tu(u2, r3.join(""));
    };
    Object.defineProperties(Ou.prototype, _u);
    var $u = Ou();
    $u.supportsColor = mu, $u.stderr = Ou({ level: bu ? bu.level : 0 }), $u.stderr.supportsColor = bu;
    var xu = $u;
    var Uu = {};
    function ju(u2) {
      let D2 = Uu[u2];
      return D2 || (D2 = "#" === u2[0] ? xu.hex(u2) : xu[u2] || xu.keyword(u2), Uu[u2] = D2, D2);
    }
    var Pu = {};
    var Nu = { info: "cyan" };
    var qu = { 0: "red", 1: "yellow", 2: "white", 3: "green" };
    var Yu = { secondaryColor: "grey", formatOptions: { date: true, colors: true, compact: false } };
    var Hu = { info: H("\u2139"), success: H("\u2714"), debug: H("\u203A"), trace: H("\u203A"), log: "" };
    var Vu = class extends S2 {
      constructor(u2) {
        super(Object.assign({}, Yu, u2));
      }
      formatStack(u2) {
        const D2 = ju("grey"), e3 = ju("cyan");
        return "\n" + A2(u2).map((u3) => "  " + u3.replace(/^at +/, (u4) => D2(u4)).replace(/\((.+)\)/, (u4, D3) => `(${e3(D3)})`)).join("\n");
      }
      formatType(u2, D2) {
        const e3 = Nu[u2.type] || qu[u2.level] || this.options.secondaryColor;
        if (D2)
          return function(u3) {
            let D3 = Pu[u3];
            return D3 || (D3 = "#" === u3[0] ? xu.bgHex(u3) : xu["bg" + u3[0].toUpperCase() + u3.slice(1)] || xu.bgKeyword(u3), Pu[u3] = D3, D3);
          }(e3).black(` ${u2.type.toUpperCase()} `);
        const t3 = "string" == typeof Hu[u2.type] ? Hu[u2.type] : u2.icon || u2.type;
        return t3 ? ju(e3)(t3) : "";
      }
      formatLogObj(u2, { width: D2 }) {
        const [e3, ...t3] = this.formatArgs(u2.args).split("\n"), r3 = void 0 !== u2.badge ? Boolean(u2.badge) : u2.level < 2, n2 = ju(this.options.secondaryColor), s3 = this.formatDate(u2.date), o2 = s3 && n2(s3), i3 = this.formatType(u2, r3), a2 = u2.tag ? n2(u2.tag) : "", l2 = e3.replace(/`([^`]+)`/g, (u3, D3) => xu.cyan(D3));
        let c2;
        const h3 = this.filterAndJoin([i3, l2]), F3 = this.filterAndJoin([a2, o2]), C2 = D2 - $(h3) - $(F3) - 2;
        return c2 = C2 > 0 && D2 >= 80 ? h3 + " ".repeat(C2) + F3 : h3, c2 += t3.length ? "\n" + t3.join("\n") : "", r3 ? "\n" + c2 + "\n" : c2;
      }
    };
    var Wu = class {
      constructor({ stream: u2 } = {}) {
        this.stream = u2 || process.stdout;
      }
      log(u2) {
        this.stream.write(JSON.stringify(u2) + "\n");
      }
    };
    var Gu = "undefined" != typeof __non_webpack_require__ ? __non_webpack_require__ : __require;
    var zu = class {
      constructor(u2) {
        if (u2 && u2.log)
          this.logger = u2;
        else {
          const D2 = Gu("winston");
          this.logger = D2.createLogger(Object.assign({ level: "info", format: D2.format.simple(), transports: [new D2.transports.Console()] }, u2));
        }
      }
      log(u2) {
        const D2 = [].concat(u2.args), e3 = D2.shift();
        this.logger.log({ level: Qu[u2.level] || "info", label: u2.tag, message: e3, args: D2, timestamp: u2.date.getTime() / 1e3 });
      }
    };
    var Qu = { 0: "error", 1: "warn", 2: "info", 3: "verbose", 4: "debug", 5: "silly" };
    global.consola || (global.consola = function() {
      let u2 = p.debug ? 4 : 3;
      process.env.CONSOLA_LEVEL && (u2 = parseInt(process.env.CONSOLA_LEVEL) || u2);
      const D2 = new _({ level: u2, reporters: [p.ci || p.test ? new S2() : new Vu()] });
      return D2.Consola = _, D2.BasicReporter = S2, D2.FancyReporter = Vu, D2.JSONReporter = Wu, D2.WinstonReporter = zu, D2.LogLevel = m2, D2;
    }());
    var Ju = global.consola;
    module.exports = Ju;
  }
});

// ../../node_modules/ts-dedent/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/ts-dedent/dist/index.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dedent = void 0;
    function dedent5(templ) {
      var values = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
      }
      var strings = Array.from(typeof templ === "string" ? [templ] : templ);
      strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
      var indentLengths = strings.reduce(function(arr, str) {
        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
        if (matches) {
          return arr.concat(matches.map(function(match) {
            var _a, _b;
            return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
          }));
        }
        return arr;
      }, []);
      if (indentLengths.length) {
        var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
        strings = strings.map(function(str) {
          return str.replace(pattern_1, "\n");
        });
      }
      strings[0] = strings[0].replace(/^\r?\n/, "");
      var string = strings[0];
      values.forEach(function(value, i2) {
        var endentations = string.match(/(?:^|\n)( *)$/);
        var endentation = endentations ? endentations[1] : "";
        var indentedValue = value;
        if (typeof value === "string" && value.includes("\n")) {
          indentedValue = String(value).split("\n").map(function(str, i3) {
            return i3 === 0 ? str : "" + endentation + str;
          }).join("\n");
        }
        string += indentedValue + strings[i2 + 1];
      });
      return string;
    }
    exports.dedent = dedent5;
    exports.default = dedent5;
  }
});

// ../../node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, emailRegex, emojiRegex, ipv4Regex, ipv6Regex, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, custom, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib = __esm({
  "../../node_modules/zod/lib/index.mjs"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e2) {
          return obj[e2];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data, path: path4, errorMaps, issueData } = params;
      const fullPath = [...path4, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s2 of results) {
          if (s2.status === "aborted")
            return INVALID;
          if (s2.status === "dirty")
            status.dirty();
          arrayValue.push(s2.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (typeof value.value !== "undefined" || pair.alwaysSet) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x2) => x2.status === "aborted";
    isDirty = (x2) => x2.status === "dirty";
    isValid = (x2) => x2.status === "valid";
    isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent, value, path4, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path4;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[a-z][a-z0-9]*$/;
    ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
    uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
    emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
    ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    ZodString = class extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
        this.toLowerCase = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
        this.toUpperCase = () => new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx2,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types3, params) => {
      return new ZodUnion({
        options: types3,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    ZodDiscriminatedUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x2) => !!x2);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          return OK(async (...args) => {
            const error = new ZodError([]);
            const parsedArgs = await this._def.args.parseAsync(args, params).catch((e2) => {
              error.addIssue(makeArgsIssue(args, e2));
              throw error;
            });
            const result = await fn(...parsedArgs);
            const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e2) => {
              error.addIssue(makeReturnsIssue(result, e2));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          return OK((...args) => {
            const parsedArgs = this._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = fn(...parsedArgs.data);
            const parsedReturns = this._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum.create(values);
      }
      exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data);
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});

// ../../source-code-git/fs/dist/errors/FilesystemError.js
var init_FilesystemError = __esm({
  "../../source-code-git/fs/dist/errors/FilesystemError.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
  }
});

// ../../source-code-git/fs/dist/implementations/memoryFs.js
var init_memoryFs = __esm({
  "../../source-code-git/fs/dist/implementations/memoryFs.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_FilesystemError();
  }
});

// ../../source-code-git/fs/dist/utilities/normalizePath.js
function normalizePath(path4) {
  if (path4 === "\\" || path4 === "/")
    return "/";
  const len = path4.length;
  if (len <= 1)
    return path4;
  let prefix = "";
  if (len > 4 && path4[3] === "\\") {
    const ch = path4[2];
    if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
      path4 = path4.slice(2);
      prefix = "//";
    }
  }
  const segs = path4.split(/[/\\]+/);
  return prefix + segs.join("/");
}
var init_normalizePath = __esm({
  "../../source-code-git/fs/dist/utilities/normalizePath.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
  }
});

// ../../node_modules/outmatch/build/index.es.mjs
function handleNoCommaBraces(span) {
  if (span.length < 3) {
    return "{" + span + "}";
  }
  var separatorI = -1;
  for (var i2 = 2; i2 < span.length; i2++) {
    if (span[i2] === "." && span[i2 - 1] === "." && (i2 < 2 || span[i2 - 2] !== "\\")) {
      if (separatorI > -1) {
        return "{" + span + "}";
      }
      separatorI = i2 - 1;
    }
  }
  if (separatorI > -1) {
    var rangeStart = span.substr(0, separatorI);
    var rangeEnd = span.substr(separatorI + 2);
    if (rangeStart.length > 0 && rangeEnd.length > 0) {
      return "[" + span.substr(0, separatorI) + "-" + span.substr(separatorI + 2) + "]";
    }
  }
  return "{" + span + "}";
}
function expand(pattern) {
  if (typeof pattern !== "string") {
    throw new TypeError("A pattern must be a string, but " + typeof pattern + " given");
  }
  var scanning = false;
  var openingBraces = 0;
  var closingBraces = 0;
  var handledUntil = -1;
  var results = [""];
  var alternatives = [];
  var span;
  for (var i2 = 0; i2 < pattern.length; i2++) {
    var char = pattern[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === "{") {
      if (scanning) {
        openingBraces++;
      } else if (i2 > handledUntil && !openingBraces) {
        span = pattern.substring(handledUntil + 1, i2);
        for (var j = 0; j < results.length; j++) {
          results[j] += span;
        }
        alternatives = [];
        handledUntil = i2;
        scanning = true;
        openingBraces++;
      } else {
        openingBraces--;
      }
    } else if (char === "}") {
      if (scanning) {
        closingBraces++;
      } else if (closingBraces === 1) {
        span = pattern.substring(handledUntil + 1, i2);
        if (alternatives.length > 0) {
          var newResults = [];
          alternatives.push(expand(span));
          for (var j = 0; j < results.length; j++) {
            for (var k = 0; k < alternatives.length; k++) {
              for (var l = 0; l < alternatives[k].length; l++) {
                newResults.push(results[j] + alternatives[k][l]);
              }
            }
          }
          results = newResults;
        } else {
          span = handleNoCommaBraces(span);
          for (var j = 0; j < results.length; j++) {
            results[j] += span;
          }
        }
        handledUntil = i2;
        closingBraces--;
      } else {
        closingBraces--;
      }
    } else if (!scanning && char === "," && closingBraces - openingBraces === 1) {
      span = pattern.substring(handledUntil + 1, i2);
      alternatives.push(expand(span));
      handledUntil = i2;
    }
    if (scanning && (closingBraces === openingBraces || i2 === pattern.length - 1)) {
      scanning = false;
      i2 = handledUntil - 1;
    }
  }
  if (handledUntil === -1) {
    return [pattern];
  }
  var unhandledFrom = pattern[handledUntil] === "{" ? handledUntil : handledUntil + 1;
  if (unhandledFrom < pattern.length) {
    span = pattern.substr(unhandledFrom);
    for (var j = 0; j < results.length; j++) {
      results[j] += span;
    }
  }
  return results;
}
function negate(pattern, options) {
  var supportNegation = options["!"] !== false;
  var supportParens = options["()"] !== false;
  var isNegated = false;
  var i2;
  if (supportNegation) {
    for (i2 = 0; i2 < pattern.length && pattern[i2] === "!"; i2++) {
      if (supportParens && pattern[i2 + 1] === "(") {
        i2--;
        break;
      }
      isNegated = !isNegated;
    }
    if (i2 > 0) {
      pattern = pattern.substr(i2);
    }
  }
  return { pattern, isNegated };
}
function escapeRegExpChar(char) {
  if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") {
    return "\\" + char;
  } else {
    return char;
  }
}
function escapeRegExpString(str) {
  var result = "";
  for (var i2 = 0; i2 < str.length; i2++) {
    result += escapeRegExpChar(str[i2]);
  }
  return result;
}
function Pattern2(source, options, excludeDot) {
  var separator = typeof options.separator === "undefined" ? true : options.separator;
  var separatorSplitter = "";
  var separatorMatcher = "";
  var wildcard = ".";
  if (separator === true) {
    separatorSplitter = "/";
    separatorMatcher = "[/\\\\]";
    wildcard = "[^/\\\\]";
  } else if (separator) {
    separatorSplitter = separator;
    separatorMatcher = escapeRegExpString(separatorSplitter);
    if (separatorMatcher.length > 1) {
      separatorMatcher = "(?:" + separatorMatcher + ")";
      wildcard = "((?!" + separatorMatcher + ").)";
    } else {
      wildcard = "[^" + separatorMatcher + "]";
    }
  } else {
    wildcard = ".";
  }
  var requiredSeparator = separator ? separatorMatcher + "+?" : "";
  var optionalSeparator = separator ? separatorMatcher + "*?" : "";
  var segments = separator ? source.split(separatorSplitter) : [source];
  var support = {
    qMark: options["?"] !== false,
    star: options["*"] !== false,
    globstar: separator && options["**"] !== false,
    brackets: options["[]"] !== false,
    extglobs: options["()"] !== false,
    excludeDot: excludeDot && options.excludeDot !== false
  };
  return {
    source,
    segments,
    options,
    separator,
    separatorSplitter,
    separatorMatcher,
    optionalSeparator,
    requiredSeparator,
    wildcard,
    support
  };
}
function Segment(source, pattern, isFirst, isLast) {
  return {
    source,
    isFirst,
    isLast,
    end: source.length - 1
  };
}
function Result() {
  return {
    match: "",
    unmatch: "",
    useUnmatch: false
  };
}
function State(pattern, segment, result) {
  return {
    pattern,
    segment,
    result,
    openingBracket: segment.end + 1,
    closingBracket: -1,
    openingParens: 0,
    closingParens: 0,
    parensHandledUntil: -1,
    extglobModifiers: [],
    scanningForParens: false,
    escapeChar: false,
    addToMatch: true,
    addToUnmatch: pattern.support.extglobs,
    dotHandled: false,
    i: -1,
    char: "",
    nextChar: ""
  };
}
function add(state, addition, excludeDot) {
  if (state.addToUnmatch) {
    state.result.unmatch += addition;
  }
  if (state.addToMatch) {
    if (excludeDot && !state.dotHandled) {
      addition = EXCLUDE_DOT_PATTERN + addition;
    }
    state.dotHandled = true;
    state.result.match += addition;
  }
  return state.result;
}
function convertSegment(pattern, segment, result) {
  var support = pattern.support;
  var state = State(pattern, segment, result);
  var separatorMatcher = segment.isLast ? pattern.optionalSeparator : pattern.requiredSeparator;
  if (!support.excludeDot) {
    state.dotHandled = true;
  }
  if (segment.end === -1) {
    return segment.isLast && !segment.isFirst ? result : add(state, separatorMatcher);
  }
  if (support.globstar && segment.source === "**") {
    var prefix = !state.dotHandled ? EXCLUDE_DOT_PATTERN : "";
    var globstarSegment = prefix + pattern.wildcard + "*?" + separatorMatcher;
    return add(state, "(?:" + globstarSegment + ")*?");
  }
  while (++state.i <= segment.end) {
    state.char = state.segment.source[state.i];
    state.nextChar = state.i < segment.end ? segment.source[state.i + 1] : "";
    if (state.char === "\\") {
      if (state.i < state.segment.end) {
        state.escapeChar = true;
        continue;
      } else {
        state.char = "";
      }
    }
    var pattern = state.pattern, segment = state.segment, char = state.char, i2 = state.i;
    if (pattern.support.brackets && !state.scanningForParens) {
      if (i2 > state.openingBracket && i2 <= state.closingBracket) {
        if (state.escapeChar) {
          add(state, escapeRegExpChar(char));
        } else if (i2 === state.closingBracket) {
          add(state, "]");
          state.openingBracket = segment.source.length;
        } else if (char === "-" && i2 === state.closingBracket - 1) {
          add(state, "\\-");
        } else if (char === "!" && i2 === state.openingBracket + 1) {
          add(state, "^");
        } else if (char === "]") {
          add(state, "\\]");
        } else {
          add(state, char);
        }
        state.escapeChar = false;
        continue;
      }
      if (i2 > state.openingBracket) {
        if (char === "]" && !state.escapeChar && i2 > state.openingBracket + 1 && i2 > state.closingBracket) {
          state.closingBracket = i2;
          state.i = state.openingBracket;
          if (pattern.separator) {
            add(state, "(?!" + pattern.separatorMatcher + ")[", true);
          } else {
            add(state, "[", true);
          }
        } else if (i2 === segment.end) {
          add(state, "\\[");
          state.i = state.openingBracket;
          state.openingBracket = segment.source.length;
          state.closingBracket = segment.source.length;
        }
        state.escapeChar = false;
        continue;
      }
      if (char === "[" && !state.escapeChar && i2 > state.closingBracket && i2 < segment.end) {
        state.openingBracket = i2;
        state.escapeChar = false;
        continue;
      }
    }
    if (state.pattern.support.extglobs) {
      var extglobModifiers = state.extglobModifiers, char = state.char, nextChar = state.nextChar, i2 = state.i;
      if (nextChar === "(" && !state.escapeChar && (char === "@" || char === "?" || char === "*" || char === "+" || char === "!")) {
        if (state.scanningForParens) {
          state.openingParens++;
        } else if (i2 > state.parensHandledUntil && !state.closingParens) {
          state.parensHandledUntil = i2;
          state.scanningForParens = true;
          state.openingParens++;
        } else if (state.closingParens >= state.openingParens) {
          if (char === "!") {
            state.addToMatch = true;
            state.addToUnmatch = false;
            add(state, state.pattern.wildcard + "*?", true);
            state.addToMatch = false;
            state.addToUnmatch = true;
            state.result.useUnmatch = true;
          }
          extglobModifiers.push(char);
          add(state, "(?:", true);
          state.openingParens--;
          state.i++;
          continue;
        } else {
          state.openingParens--;
        }
      } else if (char === ")" && !state.escapeChar) {
        if (state.scanningForParens) {
          state.closingParens++;
        } else if (extglobModifiers.length) {
          var modifier_1 = extglobModifiers.pop();
          if (modifier_1 === "!" && extglobModifiers.indexOf("!") !== -1) {
            throw new Error("Nested negated extglobs aren't supported");
          }
          modifier_1 = modifier_1 === "!" || modifier_1 === "@" ? "" : modifier_1;
          add(state, ")" + modifier_1);
          state.addToMatch = true;
          state.addToUnmatch = true;
          state.closingParens--;
          continue;
        }
      } else if (char === "|" && state.closingParens && !state.scanningForParens && !state.escapeChar) {
        add(state, "|");
        continue;
      }
      if (state.scanningForParens) {
        if (state.closingParens === state.openingParens || i2 === state.segment.end) {
          state.scanningForParens = false;
          state.i = state.parensHandledUntil - 1;
        }
        state.escapeChar = false;
        continue;
      }
    }
    var pattern = state.pattern;
    var support = pattern.support;
    if (!state.escapeChar && support.star && state.char === "*") {
      if (state.i === state.segment.end || state.nextChar !== "*") {
        add(state, pattern.wildcard + "*?", true);
      }
    } else if (!state.escapeChar && support.qMark && state.char === "?") {
      add(state, pattern.wildcard, true);
    } else {
      add(state, escapeRegExpChar(state.char));
    }
    state.escapeChar = false;
  }
  return add(state, separatorMatcher);
}
function convert(source, options, excludeDot) {
  var pattern = Pattern2(source, options, excludeDot);
  var result = Result();
  var segments = pattern.segments;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = Segment(segments[i2], pattern, i2 === 0, i2 === segments.length - 1);
    convertSegment(pattern, segment, result);
  }
  if (result.useUnmatch) {
    return "(?!^" + result.unmatch + "$)" + result.match;
  } else {
    return result.match;
  }
}
function flatMap(array, predicate) {
  var results = [];
  for (var i2 = 0; i2 < array.length; i2++) {
    var mappedValue = predicate(array[i2]);
    for (var j = 0; j < mappedValue.length; j++) {
      results.push(mappedValue[j]);
    }
  }
  return results;
}
function compile(patterns, options) {
  patterns = Array.isArray(patterns) ? patterns : [patterns];
  if (options["{}"] !== false) {
    patterns = flatMap(patterns, expand);
  }
  var positiveResults = [];
  var negativeResults = [];
  var result = "";
  for (var i2 = 0; i2 < patterns.length; i2++) {
    var negatedPattern = negate(patterns[i2], options);
    var convertedPattern = convert(negatedPattern.pattern, options, !negatedPattern.isNegated);
    if (negatedPattern.isNegated) {
      negativeResults.push(convertedPattern);
    } else {
      positiveResults.push(convertedPattern);
    }
  }
  if (negativeResults.length) {
    result = "(?!(?:" + negativeResults.join("|") + ")$)";
  }
  if (positiveResults.length > 1) {
    result += "(?:" + positiveResults.join("|") + ")";
  } else if (positiveResults.length === 1) {
    result += positiveResults[0];
  } else if (result.length) {
    result += convert("**", options, true);
  }
  return "^" + result + "$";
}
function isMatch(regexp, sample) {
  if (typeof sample !== "string") {
    throw new TypeError("Sample must be a string, but " + typeof sample + " given");
  }
  return regexp.test(sample);
}
function outmatch(pattern, options) {
  if (typeof pattern !== "string" && !Array.isArray(pattern)) {
    throw new TypeError("The first argument must be a single pattern string or an array of patterns, but " + typeof pattern + " given");
  }
  if (typeof options === "string" || typeof options === "boolean") {
    options = { separator: options };
  }
  if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) {
    throw new TypeError("The second argument must be an options object or a string/boolean separator, but " + typeof options + " given");
  }
  options = options || {};
  if (options.separator === "\\") {
    throw new Error("\\ is not a valid separator");
  }
  var regexpPattern = compile(pattern, options);
  var regexp = new RegExp(regexpPattern, options.flags);
  var fn = isMatch.bind(null, regexp);
  fn.options = options;
  fn.pattern = pattern;
  fn.regexp = regexp;
  return fn;
}
var EXCLUDE_DOT_PATTERN, index_es_default;
var init_index_es = __esm({
  "../../node_modules/outmatch/build/index.es.mjs"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    EXCLUDE_DOT_PATTERN = "(?!\\.)";
    index_es_default = outmatch;
  }
});

// ../../source-code-git/fs/dist/utilities/assertIsAbsolutePath.js
function assertIsAbsolutePath(path4) {
  if ((path4.startsWith("/") || /^[A-Za-z]:[\\/]/.test(path4)) === false) {
    {
      throw new Error(`Path is not absolute: ${path4}. All paths should be absolute to avoid bugs.`);
    }
  }
}
var init_assertIsAbsolutePath = __esm({
  "../../source-code-git/fs/dist/utilities/assertIsAbsolutePath.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
  }
});

// ../../node_modules/js-base64/base64.mjs
var _hasbtoa, _hasBuffer, _TD, _TE, b64ch, b64chs, b64tab, _fromCC, _U8Afrom, _mkUriSafe, btoaPolyfill, _btoa, _fromUint8Array, cb_utob, re_utob, utob, _encode, encode;
var init_base64 = __esm({
  "../../node_modules/js-base64/base64.mjs"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    _hasbtoa = typeof btoa === "function";
    _hasBuffer = typeof Buffer === "function";
    _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    b64chs = Array.prototype.slice.call(b64ch);
    b64tab = ((a) => {
      let tab = {};
      a.forEach((c, i2) => tab[c] = i2);
      return tab;
    })(b64chs);
    _fromCC = String.fromCharCode.bind(String);
    _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
    _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
    btoaPolyfill = (bin) => {
      let u32, c0, c1, c2, asc = "";
      const pad = bin.length % 3;
      for (let i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
    _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
      const maxargs = 4096;
      let strs = [];
      for (let i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    cb_utob = (c) => {
      if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      } else {
        var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
        return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      }
    };
    re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    utob = (u) => u.replace(re_utob, cb_utob);
    _encode = _hasBuffer ? (s2) => Buffer.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
    encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
  }
});

// ../../source-code-git/fs/dist/utilities/toJson.js
async function toJson(args) {
  assertIsAbsolutePath(args.resolveFrom);
  let result = {};
  const isMatch2 = index_es_default(args.matchers);
  const files = await args.fs.readdir(args.resolveFrom);
  for (const file of files) {
    const fullPath = normalizePath(`${args.resolveFrom}/${file}`);
    let isDirectory = false;
    try {
      await args.fs.readFile(fullPath, { encoding: "binary" });
    } catch (error) {
      isDirectory = true;
    }
    if (isDirectory) {
      const subList = await toJson({ ...args, resolveFrom: fullPath });
      result = { ...result, ...subList };
    } else if (isMatch2(fullPath) === false) {
      continue;
    } else {
      const content = await args.fs.readFile(fullPath, { encoding: "binary" });
      if (!content)
        throw new Error(`${fullPath} does not exist.`);
      if (typeof content !== "string")
        throw new Error(`Badly behaved filesystem, expected string from readFile but got'${content.constructor.name}'.`);
      result[fullPath.slice(1)] = encode(content);
    }
  }
  return result;
}
var init_toJson = __esm({
  "../../source-code-git/fs/dist/utilities/toJson.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_index_es();
    init_normalizePath();
    init_assertIsAbsolutePath();
    init_base64();
  }
});

// ../../source-code-git/fs/dist/utilities/fromJson.js
var init_fromJson = __esm({
  "../../source-code-git/fs/dist/utilities/fromJson.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_assertIsAbsolutePath();
  }
});

// ../../source-code-git/fs/dist/index.js
var init_dist = __esm({
  "../../source-code-git/fs/dist/index.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_memoryFs();
    init_normalizePath();
    init_toJson();
    init_fromJson();
  }
});

// ../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseResolve = Promise.resolve.bind(originalPromise);
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      const queueMicrotask = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve2, reject) => {
          reader._closedPromise_resolve = resolve2;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      const PullSteps = SymbolPolyfill("[[PullSteps]]");
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        const buffer = TransferArrayBuffer(view.buffer);
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const buffer = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init3, context) {
        assertDictionary(init3, context);
        const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
        const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve2, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve2,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve2, reject) => {
          const closeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve2, reject) => {
          const writeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let writeAlgorithm = () => promiseResolvedWith(void 0);
        let closeAlgorithm = () => promiseResolvedWith(void 0);
        let abortAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve2, reject) => {
          writer._closedPromise_resolve = resolve2;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve2, reject) => {
          writer._readyPromise_resolve = resolve2;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve2, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = new DOMException$1("Aborted", "AbortError");
              const actions2 = [];
              if (!preventAbort) {
                actions2.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions2.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions2.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve2(void 0);
            }
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._errorSteps(e2);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._errorSteps(e2);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init3, context) {
        assertDictionary(init3, context);
        const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve2) => {
            startPromise_resolve = resolve2;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve2) => {
          stream._backpressureChangePromise_resolve = resolve2;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        let flushAlgorithm = () => promiseResolvedWith(void 0);
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r2) => {
          TransformStreamError(stream, r2);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports2.CountQueuingStrategy = CountQueuingStrategy;
      exports2.ReadableByteStreamController = ReadableByteStreamController;
      exports2.ReadableStream = ReadableStream2;
      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports2.TransformStream = TransformStream;
      exports2.TransformStreamDefaultController = TransformStreamDefaultController;
      exports2.WritableStream = WritableStream;
      exports2.WritableStreamDefaultController = WritableStreamDefaultController;
      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "../../node_modules/fetch-blob/streams.cjs"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = __require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, __require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob4 } = __require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// ../../node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm({
  "../../node_modules/fetch-blob/index.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    fetch_blob_default = Blob3;
  }
});

// ../../node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm({
  "../../node_modules/fetch-blob/file.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_fetch_blob();
    _File = class File extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File2 = _File;
    file_default = File2;
  }
});

// ../../node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData2;
var init_esm_min = __esm({
  "../../node_modules/formdata-polyfill/esm.min.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData2 = class FormData3 {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    };
  }
});

// ../../node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "../../node_modules/node-domexception/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module.exports = globalThis.DOMException;
  }
});

// ../../node_modules/fetch-blob/from.js
import { statSync, createReadStream, promises as fs3 } from "node:fs";
var import_node_domexception, stat, BlobDataItem;
var init_from = __esm({
  "../../node_modules/fetch-blob/from.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = fs3);
    BlobDataItem = class {
      #path;
      #start;
      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          size: end - start,
          start: this.#start + start
        });
      }
      async *stream() {
        const { mtimeMs } = await stat(this.#path);
        if (mtimeMs > this.lastModified) {
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        }
        yield* createReadStream(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData2();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// ../../node_modules/dotenv/package.json
var require_package = __commonJS({
  "../../node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "16.0.3",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          require: "./lib/main.js",
          types: "./lib/main.d.ts",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^17.0.9",
        decache: "^4.6.1",
        dtslint: "^3.7.0",
        sinon: "^12.0.1",
        standard: "^16.0.4",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.3.2",
        tap: "^15.1.6",
        tar: "^6.1.11",
        typescript: "^4.5.4"
      },
      engines: {
        node: ">=12"
      }
    };
  }
});

// ../../node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../../node_modules/dotenv/lib/main.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var fs7 = __require("fs");
    var path4 = __require("path");
    var os = __require("os");
    var packageJson = require_package();
    var version2 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _log(message) {
      console.log(`[dotenv@${version2}][DEBUG] ${message}`);
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path4.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config3(options) {
      let dotenvPath = path4.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs7.readFileSync(dotenvPath, { encoding }));
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else {
            if (override === true) {
              process.env[key] = parsed[key];
            }
            if (debug) {
              if (override === true) {
                _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
              } else {
                _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
              }
            }
          }
        });
        return { parsed };
      } catch (e2) {
        if (debug) {
          _log(`Failed to load ${dotenvPath} ${e2.message}`);
        }
        return { error: e2 };
      }
    }
    var DotenvModule = {
      config: config3,
      parse
    };
    module.exports.config = DotenvModule.config;
    module.exports.parse = DotenvModule.parse;
    module.exports = DotenvModule;
  }
});

// ../env-variables/dist/runtime/privateEnv.js
function getPrivateEnvVariables() {
  if (typeof process === "undefined") {
    return new Proxy(
      {},
      {
        get: () => {
          throw Error(
            "`process.env` is undefined. You are accessing private env variables in a non-node environment, likely the browser. Private env variables should never be exposed to the client. Use `publicEnv` instead."
          );
        }
      }
    );
  }
  const result = (0, import_dotenv.config)({ path: "/home/runner/work/inlang/inlang/.env" });
  if (result.error) {
    return process.env;
  }
  return { ...process.env, ...result.parsed };
}
var import_dotenv, privateEnv;
var init_privateEnv = __esm({
  "../env-variables/dist/runtime/privateEnv.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    import_dotenv = __toESM(require_main(), 1);
    privateEnv = getPrivateEnvVariables();
  }
});

// ../env-variables/dist/runtime/publicEnv.js
var define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default, publicEnv;
var init_publicEnv = __esm({
  "../env-variables/dist/runtime/publicEnv.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default = { PUBLIC_IS_DEV: "false", PUBLIC_POSTHOG_TOKEN: "phc_H3ojnOxJaC3YxBLvf7marnuUnZ2tMC35oEASdiiRupA", PUBLIC_SERVER_BASE_URL: "https://inlang.com", PUBLIC_GITHUB_APP_CLIENT_ID: "f43944a9079cff527c3e", PUBLIC_WEBSITE_SENTRY_DSN: "https://6ba3cb3bad464dd9a7f8700ed636c07a@o4504345873285120.ingest.sentry.io/4504346044006400", PUBLIC_GIT_PROXY_PATH: "/git-proxy/" };
    publicEnv = new Proxy({}, {
      get(target, prop) {
        if (typeof prop === "string" && prop.startsWith("PUBLIC_") === false) {
          throw new Error("Public env variables must start with PUBLIC_");
        } else if (typeof process !== "undefined" && (process == null ? void 0 : process.env[prop])) {
          return process.env[prop];
        } else if (
          // @ts-expect-error - ENV_DEFINED_IN_BUILD_STEP is defined in build step
          typeof define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default !== "undefined" && // @ts-expect-error - ENV_DEFINED_IN_BUILD_STEP is defined in build step
          define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default[prop]
        ) {
          return define_PUBLIC_ENV_DEFINED_IN_BUILD_STEP_default[prop];
        }
        return target[prop];
      }
    });
  }
});

// ../env-variables/dist/schema.js
var publicEnvVariablesSchema, privateEnvVariablesSchema;
var init_schema = __esm({
  "../env-variables/dist/schema.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_lib();
    publicEnvVariablesSchema = z.object({
      PUBLIC_GITHUB_APP_CLIENT_ID: z.string(),
      PUBLIC_GIT_PROXY_PATH: z.string().startsWith("/").endsWith("/").describe(`Must be a path like /git-proxy/`),
      PUBLIC_WEBSITE_SENTRY_DSN: z.string().optional().describe("DSN for Sentry (in the browser)"),
      PUBLIC_POSTHOG_TOKEN: z.string().optional(),
      PUBLIC_SERVER_BASE_URL: z.string().url().regex(/^(?!.*\/$).+$/, "Must not end with a slash").describe("The base url of the server e.g. https://inlang.com")
    });
    privateEnvVariablesSchema = z.object({
      SESSION_COOKIE_SECRET: z.string(),
      JWE_SECRET: z.string(),
      OPEN_AI_KEY: z.string().optional(),
      GOOGLE_TRANSLATE_API_KEY: z.string().optional(),
      SERVER_SENTRY_DSN: z.string().optional().describe("DSN for Sentry (on the server)"),
      // prefixed with INLANG_ because github doesn't allow env vars with GITHUB_ in ci/cd.
      INLANG_GITHUB_APP_CLIENT_SECRET: z.string()
    });
  }
});

// ../env-variables/dist/validateEnvVariables.js
var init_validateEnvVariables = __esm({
  "../env-variables/dist/validateEnvVariables.js"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_schema();
  }
});

// ../env-variables/dist/index.js
var init_dist2 = __esm({
  "../env-variables/dist/index.js"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_privateEnv();
    init_publicEnv();
    init_validateEnvVariables();
  }
});

// ../../node_modules/typed-rpc/lib/client.js
var require_client = __commonJS({
  "../../node_modules/typed-rpc/lib/client.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpcClient = exports.RpcError = void 0;
    var RpcError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        Object.setPrototypeOf(this, RpcError.prototype);
      }
    };
    exports.RpcError = RpcError;
    function rpcClient2(url, options) {
      const request = async (method, params) => {
        const id = Date.now();
        const headers = (options == null ? void 0 : options.getHeaders) ? await options.getHeaders() : {};
        const res = await fetch(url, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            ...headers
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id,
            method,
            params: removeTrailingUndefs(params)
          }),
          credentials: options == null ? void 0 : options.credentials
        });
        if (!res.ok) {
          throw new RpcError(res.statusText, res.status);
        }
        const { result, error } = await res.json();
        if (error) {
          const { code, message, data } = error;
          throw new RpcError(message, code, data);
        }
        return result;
      };
      return new Proxy({}, {
        /* istanbul ignore next */
        get(target, prop, receiver) {
          if (isRemote(prop)) {
            return (...args) => request(prop.toString(), args);
          }
        }
      });
    }
    exports.rpcClient = rpcClient2;
    function isRemote(prop) {
      if (typeof prop === "symbol")
        return false;
      if (prop.startsWith("$"))
        return false;
      if (prop in Object.prototype)
        return false;
      if (prop === "toJSON")
        return false;
      return true;
    }
    function removeTrailingUndefs(values) {
      const a = [...values];
      while (a.length && a[a.length - 1] === void 0)
        a.length--;
      return a;
    }
  }
});

// ../rpc/src/functions/generateConfigFile.client.ts
var generateConfigFile_client_exports = {};
__export(generateConfigFile_client_exports, {
  generateConfigFileClient: () => generateConfigFileClient,
  withClientSidePatch: () => withClientSidePatch
});
async function generateConfigFileClient(args) {
  const filesystemAsJson = await toJson({
    fs: args.fs,
    resolveFrom: args.resolveFrom,
    // exclude files that are not relevant for the config file to reduce
    // bandwith and improve performance
    matchers: ["**/*", "!**/node_modules/**", "!**/dist/*"]
  });
  return await rpc.generateConfigFileServer({
    filesystemAsJson,
    applicationId: args.applicationId
  });
}
function withClientSidePatch(client) {
  return new Proxy(client, {
    // patching client side routes
    get(target, prop) {
      if (prop === "generateConfigFile") {
        return async (...args) => {
          const { generateConfigFileClient: generateConfigFileClient2 } = await Promise.resolve().then(() => (init_generateConfigFile_client(), generateConfigFile_client_exports));
          return generateConfigFileClient2(...args);
        };
      }
      return target[prop];
    }
  });
}
var init_generateConfigFile_client = __esm({
  "../rpc/src/functions/generateConfigFile.client.ts"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_client();
    init_dist();
  }
});

// ../rpc/src/client.ts
var import_typed_rpc, route, rpc;
var init_client = __esm({
  "../rpc/src/client.ts"() {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    init_dist2();
    import_typed_rpc = __toESM(require_client(), 1);
    route = "/_rpc";
    rpc = new Proxy(
      (0, import_typed_rpc.rpcClient)(publicEnv.PUBLIC_SERVER_BASE_URL + route),
      {
        // patching client side routes
        get(target, prop) {
          if (prop === "generateConfigFile") {
            return async (...args) => {
              const { generateConfigFileClient: generateConfigFileClient2 } = await Promise.resolve().then(() => (init_generateConfigFile_client(), generateConfigFile_client_exports));
              return generateConfigFileClient2(...args);
            };
          }
          return target[prop];
        }
      }
    );
  }
});

// ../../node_modules/mute-stream/mute.js
var require_mute = __commonJS({
  "../../node_modules/mute-stream/mute.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var Stream3 = __require("stream");
    module.exports = MuteStream;
    function MuteStream(opts) {
      Stream3.apply(this);
      opts = opts || {};
      this.writable = this.readable = true;
      this.muted = false;
      this.on("pipe", this._onpipe);
      this.replace = opts.replace;
      this._prompt = opts.prompt || null;
      this._hadControl = false;
    }
    MuteStream.prototype = Object.create(Stream3.prototype);
    Object.defineProperty(MuteStream.prototype, "constructor", {
      value: MuteStream,
      enumerable: false
    });
    MuteStream.prototype.mute = function() {
      this.muted = true;
    };
    MuteStream.prototype.unmute = function() {
      this.muted = false;
    };
    Object.defineProperty(MuteStream.prototype, "_onpipe", {
      value: onPipe,
      enumerable: false,
      writable: true,
      configurable: true
    });
    function onPipe(src) {
      this._src = src;
    }
    Object.defineProperty(MuteStream.prototype, "isTTY", {
      get: getIsTTY,
      set: setIsTTY,
      enumerable: true,
      configurable: true
    });
    function getIsTTY() {
      return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : false;
    }
    function setIsTTY(isTTY) {
      Object.defineProperty(this, "isTTY", {
        value: isTTY,
        enumerable: true,
        writable: true,
        configurable: true
      });
    }
    Object.defineProperty(MuteStream.prototype, "rows", {
      get: function() {
        return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MuteStream.prototype, "columns", {
      get: function() {
        return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
      },
      enumerable: true,
      configurable: true
    });
    MuteStream.prototype.pipe = function(dest, options) {
      this._dest = dest;
      return Stream3.prototype.pipe.call(this, dest, options);
    };
    MuteStream.prototype.pause = function() {
      if (this._src)
        return this._src.pause();
    };
    MuteStream.prototype.resume = function() {
      if (this._src)
        return this._src.resume();
    };
    MuteStream.prototype.write = function(c) {
      if (this.muted) {
        if (!this.replace)
          return true;
        if (c.match(/^\u001b/)) {
          if (c.indexOf(this._prompt) === 0) {
            c = c.substr(this._prompt.length);
            c = c.replace(/./g, this.replace);
            c = this._prompt + c;
          }
          this._hadControl = true;
          return this.emit("data", c);
        } else {
          if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
            this._hadControl = false;
            this.emit("data", this._prompt);
            c = c.substr(this._prompt.length);
          }
          c = c.toString().replace(/./g, this.replace);
        }
      }
      this.emit("data", c);
    };
    MuteStream.prototype.end = function(c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace);
        } else {
          c = null;
        }
      }
      if (c)
        this.emit("data", c);
      this.emit("end");
    };
    function proxy(fn) {
      return function() {
        var d = this._dest;
        var s2 = this._src;
        if (d && d[fn])
          d[fn].apply(d, arguments);
        if (s2 && s2[fn])
          s2[fn].apply(s2, arguments);
      };
    }
    MuteStream.prototype.destroy = proxy("destroy");
    MuteStream.prototype.destroySoon = proxy("destroySoon");
    MuteStream.prototype.close = proxy("close");
  }
});

// ../../node_modules/read/lib/read.js
var require_read = __commonJS({
  "../../node_modules/read/lib/read.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = read;
    var readline = __require("readline");
    var Mute = require_mute();
    function read(opts, cb) {
      if (opts.num) {
        throw new Error("read() no longer accepts a char number limit");
      }
      if (typeof opts.default !== "undefined" && typeof opts.default !== "string" && typeof opts.default !== "number") {
        throw new Error("default value must be string or number");
      }
      var input = opts.input || process.stdin;
      var output = opts.output || process.stdout;
      var prompt = (opts.prompt || "").trim() + " ";
      var silent = opts.silent;
      var editDef = false;
      var timeout = opts.timeout;
      var def = opts.default || "";
      if (def) {
        if (silent) {
          prompt += "(<default hidden>) ";
        } else if (opts.edit) {
          editDef = true;
        } else {
          prompt += "(" + def + ") ";
        }
      }
      var terminal = !!(opts.terminal || output.isTTY);
      var m2 = new Mute({ replace: opts.replace, prompt });
      m2.pipe(output, { end: false });
      output = m2;
      var rlOpts = { input, output, terminal };
      if (process.version.match(/^v0\.6/)) {
        var rl = readline.createInterface(rlOpts.input, rlOpts.output);
      } else {
        var rl = readline.createInterface(rlOpts);
      }
      output.unmute();
      rl.setPrompt(prompt);
      rl.prompt();
      if (silent) {
        output.mute();
      } else if (editDef) {
        rl.line = def;
        rl.cursor = def.length;
        rl._refreshLine();
      }
      var called = false;
      rl.on("line", onLine);
      rl.on("error", onError);
      rl.on("SIGINT", function() {
        rl.close();
        onError(new Error("canceled"));
      });
      var timer;
      if (timeout) {
        timer = setTimeout(function() {
          onError(new Error("timed out"));
        }, timeout);
      }
      function done() {
        called = true;
        rl.close();
        if (process.version.match(/^v0\.6/)) {
          rl.input.removeAllListeners("data");
          rl.input.removeAllListeners("keypress");
          rl.input.pause();
        }
        clearTimeout(timer);
        output.mute();
        output.end();
      }
      function onError(er) {
        if (called)
          return;
        done();
        return cb(er);
      }
      function onLine(line) {
        if (called)
          return;
        if (silent && terminal) {
          output.unmute();
          output.write("\r\n");
        }
        done();
        line = line.replace(/\r?\n$/, "");
        var isDefault = !!(editDef && line === def);
        if (def && !line) {
          isDefault = true;
          line = def;
        }
        cb(null, line, isDefault);
      }
    }
  }
});

// ../../node_modules/promptly/lib/prompt.js
var require_prompt3 = __commonJS({
  "../../node_modules/promptly/lib/prompt.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { EOL } = __require("os");
    var { promisify: promisify2 } = __require("util");
    var read = promisify2(require_read());
    async function prompt(message, options) {
      let value;
      try {
        value = await read({
          prompt: message,
          silent: options.silent,
          replace: options.replace,
          input: options.input,
          output: options.output,
          timeout: options.timeout
        });
      } catch (err) {
        if (err.message !== "timed out" || options.default === void 0 || !options.useDefaultOnTimeout) {
          throw Object.assign(new Error(err.message), { code: "TIMEDOUT" });
        }
        value = options.default;
      }
      if (options.trim) {
        value = value.trim();
      }
      if (!value) {
        if (options.default === void 0) {
          return prompt(message, options);
        }
        value = options.default;
      }
      try {
        for (const i2 in options.validator) {
          value = await options.validator[i2](value);
        }
      } catch (err) {
        if (options.retry) {
          err.message && options.output.write(err.message + EOL);
          return prompt(message, options);
        }
        throw err;
      }
      return value;
    }
    module.exports = prompt;
  }
});

// ../../node_modules/promptly/lib/getOptions.js
var require_getOptions = __commonJS({
  "../../node_modules/promptly/lib/getOptions.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function getOptions(options) {
      options = {
        // Own options
        validator: void 0,
        retry: true,
        trim: true,
        default: void 0,
        useDefaultOnTimeout: false,
        // `read` package options
        silent: false,
        replace: "",
        input: process.stdin,
        output: process.stdout,
        timeout: 0,
        ...options
      };
      if (options.default !== void 0 && typeof options.default !== "string") {
        throw new Error("The default option value must be a string");
      }
      if (!Array.isArray(options.validator)) {
        options.validator = options.validator ? [options.validator] : [];
      }
      return options;
    }
    module.exports = getOptions;
  }
});

// ../../node_modules/promptly/index.js
var require_promptly = __commonJS({
  "../../node_modules/promptly/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var prompt = require_prompt3();
    var getOptions = require_getOptions();
    var promptly = module.exports;
    promptly.prompt = (message, options) => {
      options = getOptions(options);
      return prompt(message, options);
    };
    promptly.password = (message, options) => {
      options = getOptions({
        silent: true,
        // Hide password chars
        trim: false,
        // Do not trim so that spaces can be part of the password
        default: "",
        // Allow empty passwords
        ...options
      });
      return prompt(message, options);
    };
    promptly.confirm = (message, options) => {
      options = getOptions({
        trim: false,
        // Do not trim so that only exact matches pass the validator
        ...options
      });
      options.validator.unshift((value) => {
        value = value.toLowerCase();
        switch (value) {
          case "y":
          case "yes":
          case "1":
            return true;
          case "n":
          case "no":
          case "0":
            return false;
          default:
            throw new Error(`Invalid choice: ${value}`);
        }
      });
      return prompt(message, options);
    };
    promptly.choose = (message, choices, options) => {
      options = getOptions({
        trim: false,
        // Do not trim so that only exact matches pass the validator
        ...options
      });
      options.validator.unshift((value) => {
        const index = choices.findIndex((choice) => value == choice);
        if (index === -1) {
          throw new Error(`Invalid choice: ${value}`);
        }
        return choices[index];
      });
      return prompt(message, options);
    };
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/is.js
var require_is = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/is.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var objectToString = Object.prototype.toString;
    function isError(wat) {
      switch (objectToString.call(wat)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    function isBuiltin(wat, className) {
      return objectToString.call(wat) === `[object ${className}]`;
    }
    function isErrorEvent(wat) {
      return isBuiltin(wat, "ErrorEvent");
    }
    function isDOMError(wat) {
      return isBuiltin(wat, "DOMError");
    }
    function isDOMException(wat) {
      return isBuiltin(wat, "DOMException");
    }
    function isString(wat) {
      return isBuiltin(wat, "String");
    }
    function isPrimitive(wat) {
      return wat === null || typeof wat !== "object" && typeof wat !== "function";
    }
    function isPlainObject(wat) {
      return isBuiltin(wat, "Object");
    }
    function isEvent(wat) {
      return typeof Event !== "undefined" && isInstanceOf(wat, Event);
    }
    function isElement(wat) {
      return typeof Element !== "undefined" && isInstanceOf(wat, Element);
    }
    function isRegExp(wat) {
      return isBuiltin(wat, "RegExp");
    }
    function isThenable(wat) {
      return Boolean(wat && wat.then && typeof wat.then === "function");
    }
    function isSyntheticEvent(wat) {
      return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
    }
    function isNaN2(wat) {
      return typeof wat === "number" && wat !== wat;
    }
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      } catch (_e) {
        return false;
      }
    }
    exports.isDOMError = isDOMError;
    exports.isDOMException = isDOMException;
    exports.isElement = isElement;
    exports.isError = isError;
    exports.isErrorEvent = isErrorEvent;
    exports.isEvent = isEvent;
    exports.isInstanceOf = isInstanceOf;
    exports.isNaN = isNaN2;
    exports.isPlainObject = isPlainObject;
    exports.isPrimitive = isPrimitive;
    exports.isRegExp = isRegExp;
    exports.isString = isString;
    exports.isSyntheticEvent = isSyntheticEvent;
    exports.isThenable = isThenable;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/worldwide.js
var require_worldwide = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/worldwide.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isGlobalObj(obj) {
      return obj && obj.Math == Math ? obj : void 0;
    }
    var GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
    typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || function() {
      return this;
    }() || {};
    function getGlobalObject() {
      return GLOBAL_OBJ;
    }
    function getGlobalSingleton(name, creator, obj) {
      const gbl = obj || GLOBAL_OBJ;
      const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
      const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
      return singleton;
    }
    exports.GLOBAL_OBJ = GLOBAL_OBJ;
    exports.getGlobalObject = getGlobalObject;
    exports.getGlobalSingleton = getGlobalSingleton;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/browser.js
var require_browser = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/browser.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    var DEFAULT_MAX_STRING_LENGTH = 80;
    function htmlTreeAsString(elem, options = {}) {
      try {
        let currentElem = elem;
        const MAX_TRAVERSE_HEIGHT = 5;
        const out = [];
        let height = 0;
        let len = 0;
        const separator = " > ";
        const sepLength = separator.length;
        let nextStr;
        const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
        const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function _htmlElementAsString(el, keyAttrs) {
      const elem = el;
      const out = [];
      let className;
      let classes;
      let key;
      let attr;
      let i2;
      if (!elem || !elem.tagName) {
        return "";
      }
      out.push(elem.tagName.toLowerCase());
      const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
      if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach((keyAttrPair) => {
          out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
        });
      } else {
        if (elem.id) {
          out.push(`#${elem.id}`);
        }
        className = elem.className;
        if (className && is.isString(className)) {
          classes = className.split(/\s+/);
          for (i2 = 0; i2 < classes.length; i2++) {
            out.push(`.${classes[i2]}`);
          }
        }
      }
      const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
      for (i2 = 0; i2 < allowedAttrs.length; i2++) {
        key = allowedAttrs[i2];
        attr = elem.getAttribute(key);
        if (attr) {
          out.push(`[${key}="${attr}"]`);
        }
      }
      return out.join("");
    }
    function getLocationHref() {
      try {
        return WINDOW.document.location.href;
      } catch (oO) {
        return "";
      }
    }
    function getDomElement(selector) {
      if (WINDOW.document && WINDOW.document.querySelector) {
        return WINDOW.document.querySelector(selector);
      }
      return null;
    }
    exports.getDomElement = getDomElement;
    exports.getLocationHref = getLocationHref;
    exports.htmlTreeAsString = htmlTreeAsString;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/error.js
var require_error2 = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/error.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SentryError = class extends Error {
      /** Display name of this error instance. */
      constructor(message, logLevel = "warn") {
        super(message);
        this.message = message;
        this.name = new.target.prototype.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
        this.logLevel = logLevel;
      }
    };
    exports.SentryError = SentryError;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/dsn.js
var require_dsn = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/dsn.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var error = require_error2();
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function isValidProtocol(protocol) {
      return protocol === "http" || protocol === "https";
    }
    function dsnToString(dsn, withPassword = false) {
      const { host, path: path4, pass, port, projectId, protocol, publicKey } = dsn;
      return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path4 ? `${path4}/` : path4}${projectId}`;
    }
    function dsnFromString(str) {
      const match = DSN_REGEX.exec(str);
      if (!match) {
        throw new error.SentryError(`Invalid Sentry Dsn: ${str}`);
      }
      const [protocol, publicKey, pass = "", host, port = "", lastPath] = match.slice(1);
      let path4 = "";
      let projectId = lastPath;
      const split = projectId.split("/");
      if (split.length > 1) {
        path4 = split.slice(0, -1).join("/");
        projectId = split.pop();
      }
      if (projectId) {
        const projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      return dsnFromComponents({ host, pass, path: path4, projectId, port, protocol, publicKey });
    }
    function dsnFromComponents(components) {
      return {
        protocol: components.protocol,
        publicKey: components.publicKey || "",
        pass: components.pass || "",
        host: components.host,
        port: components.port || "",
        path: components.path || "",
        projectId: components.projectId
      };
    }
    function validateDsn(dsn) {
      if (!(typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__)) {
        return;
      }
      const { port, projectId, protocol } = dsn;
      const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
      requiredComponents.forEach((component) => {
        if (!dsn[component]) {
          throw new error.SentryError(`Invalid Sentry Dsn: ${component} missing`);
        }
      });
      if (!projectId.match(/^\d+$/)) {
        throw new error.SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
      }
      if (!isValidProtocol(protocol)) {
        throw new error.SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
      }
      if (port && isNaN(parseInt(port, 10))) {
        throw new error.SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);
      }
      return true;
    }
    function makeDsn(from) {
      const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
      validateDsn(components);
      return components;
    }
    exports.dsnFromString = dsnFromString;
    exports.dsnToString = dsnToString;
    exports.makeDsn = makeDsn;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/logger.js
var require_logger = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/logger.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var PREFIX = "Sentry Logger ";
    var CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert", "trace"];
    function consoleSandbox(callback) {
      if (!("console" in worldwide.GLOBAL_OBJ)) {
        return callback();
      }
      const originalConsole = worldwide.GLOBAL_OBJ.console;
      const wrappedLevels = {};
      CONSOLE_LEVELS.forEach((level) => {
        const originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
        if (level in originalConsole && originalWrappedFunc) {
          wrappedLevels[level] = originalConsole[level];
          originalConsole[level] = originalWrappedFunc;
        }
      });
      try {
        return callback();
      } finally {
        Object.keys(wrappedLevels).forEach((level) => {
          originalConsole[level] = wrappedLevels[level];
        });
      }
    }
    function makeLogger() {
      let enabled = false;
      const logger = {
        enable: () => {
          enabled = true;
        },
        disable: () => {
          enabled = false;
        }
      };
      if (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) {
        CONSOLE_LEVELS.forEach((name) => {
          logger[name] = (...args) => {
            if (enabled) {
              consoleSandbox(() => {
                worldwide.GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
              });
            }
          };
        });
      } else {
        CONSOLE_LEVELS.forEach((name) => {
          logger[name] = () => void 0;
        });
      }
      return logger;
    }
    exports.logger = void 0;
    if (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) {
      exports.logger = worldwide.getGlobalSingleton("logger", makeLogger);
    } else {
      exports.logger = makeLogger();
    }
    exports.CONSOLE_LEVELS = CONSOLE_LEVELS;
    exports.consoleSandbox = consoleSandbox;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/string.js
var require_string = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/string.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    function truncate(str, max = 0) {
      if (typeof str !== "string" || max === 0) {
        return str;
      }
      return str.length <= max ? str : `${str.slice(0, max)}...`;
    }
    function snipLine(line, colno) {
      let newLine = line;
      const lineLength = newLine.length;
      if (lineLength <= 150) {
        return newLine;
      }
      if (colno > lineLength) {
        colno = lineLength;
      }
      let start = Math.max(colno - 60, 0);
      if (start < 5) {
        start = 0;
      }
      let end = Math.min(start + 140, lineLength);
      if (end > lineLength - 5) {
        end = lineLength;
      }
      if (end === lineLength) {
        start = Math.max(end - 140, 0);
      }
      newLine = newLine.slice(start, end);
      if (start > 0) {
        newLine = `'{snip} ${newLine}`;
      }
      if (end < lineLength) {
        newLine += " {snip}";
      }
      return newLine;
    }
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return "";
      }
      const output = [];
      for (let i2 = 0; i2 < input.length; i2++) {
        const value = input[i2];
        try {
          output.push(String(value));
        } catch (e2) {
          output.push("[value cannot be serialized]");
        }
      }
      return output.join(delimiter);
    }
    function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
      if (!is.isString(value)) {
        return false;
      }
      if (is.isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (is.isString(pattern)) {
        return requireExactStringMatch ? value === pattern : value.includes(pattern);
      }
      return false;
    }
    function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
      return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
    }
    exports.isMatchingPattern = isMatchingPattern;
    exports.safeJoin = safeJoin;
    exports.snipLine = snipLine;
    exports.stringMatchesSomePattern = stringMatchesSomePattern;
    exports.truncate = truncate;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/object.js
var require_object = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/object.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var browser = require_browser();
    var is = require_is();
    var string = require_string();
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }
      const original = source[name];
      const wrapped = replacementFactory(original);
      if (typeof wrapped === "function") {
        try {
          markFunctionWrapped(wrapped, original);
        } catch (_Oo) {
        }
      }
      source[name] = wrapped;
    }
    function addNonEnumerableProperty(obj, name, value) {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value,
        writable: true,
        configurable: true
      });
    }
    function markFunctionWrapped(wrapped, original) {
      const proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    }
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }
    function urlEncode(object) {
      return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
    }
    function convertToPlainObject(value) {
      if (is.isError(value)) {
        return {
          message: value.message,
          name: value.name,
          stack: value.stack,
          ...getOwnProperties(value)
        };
      } else if (is.isEvent(value)) {
        const newObj = {
          type: value.type,
          target: serializeEventTarget(value.target),
          currentTarget: serializeEventTarget(value.currentTarget),
          ...getOwnProperties(value)
        };
        if (typeof CustomEvent !== "undefined" && is.isInstanceOf(value, CustomEvent)) {
          newObj.detail = value.detail;
        }
        return newObj;
      } else {
        return value;
      }
    }
    function serializeEventTarget(target) {
      try {
        return is.isElement(target) ? browser.htmlTreeAsString(target) : Object.prototype.toString.call(target);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function getOwnProperties(obj) {
      if (typeof obj === "object" && obj !== null) {
        const extractedProps = {};
        for (const property in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = obj[property];
          }
        }
        return extractedProps;
      } else {
        return {};
      }
    }
    function extractExceptionKeysForMessage(exception, maxLength = 40) {
      const keys = Object.keys(convertToPlainObject(exception));
      keys.sort();
      if (!keys.length) {
        return "[object has no keys]";
      }
      if (keys[0].length >= maxLength) {
        return string.truncate(keys[0], maxLength);
      }
      for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        const serialized = keys.slice(0, includedKeys).join(", ");
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return string.truncate(serialized, maxLength);
      }
      return "";
    }
    function dropUndefinedKeys(inputValue) {
      const memoizationMap = /* @__PURE__ */ new Map();
      return _dropUndefinedKeys(inputValue, memoizationMap);
    }
    function _dropUndefinedKeys(inputValue, memoizationMap) {
      if (is.isPlainObject(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = {};
        memoizationMap.set(inputValue, returnValue);
        for (const key of Object.keys(inputValue)) {
          if (typeof inputValue[key] !== "undefined") {
            returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
          }
        }
        return returnValue;
      }
      if (Array.isArray(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = [];
        memoizationMap.set(inputValue, returnValue);
        inputValue.forEach((item) => {
          returnValue.push(_dropUndefinedKeys(item, memoizationMap));
        });
        return returnValue;
      }
      return inputValue;
    }
    function objectify(wat) {
      let objectified;
      switch (true) {
        case (wat === void 0 || wat === null):
          objectified = new String(wat);
          break;
        case (typeof wat === "symbol" || typeof wat === "bigint"):
          objectified = Object(wat);
          break;
        case is.isPrimitive(wat):
          objectified = new wat.constructor(wat);
          break;
        default:
          objectified = wat;
          break;
      }
      return objectified;
    }
    exports.addNonEnumerableProperty = addNonEnumerableProperty;
    exports.convertToPlainObject = convertToPlainObject;
    exports.dropUndefinedKeys = dropUndefinedKeys;
    exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
    exports.fill = fill;
    exports.getOriginalFunction = getOriginalFunction;
    exports.markFunctionWrapped = markFunctionWrapped;
    exports.objectify = objectify;
    exports.urlEncode = urlEncode;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/node-stack-trace.js
var require_node_stack_trace = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/node-stack-trace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function node(getModule) {
      const FILENAME_MATCH = /^\s*[-]{4,}$/;
      const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
      return (line) => {
        const lineMatch = line.match(FULL_MATCH);
        if (lineMatch) {
          let object;
          let method;
          let functionName;
          let typeName;
          let methodName;
          if (lineMatch[1]) {
            functionName = lineMatch[1];
            let methodStart = functionName.lastIndexOf(".");
            if (functionName[methodStart - 1] === ".") {
              methodStart--;
            }
            if (methodStart > 0) {
              object = functionName.slice(0, methodStart);
              method = functionName.slice(methodStart + 1);
              const objectEnd = object.indexOf(".Module");
              if (objectEnd > 0) {
                functionName = functionName.slice(objectEnd + 1);
                object = object.slice(0, objectEnd);
              }
            }
            typeName = void 0;
          }
          if (method) {
            typeName = object;
            methodName = method;
          }
          if (method === "<anonymous>") {
            methodName = void 0;
            functionName = void 0;
          }
          if (functionName === void 0) {
            methodName = methodName || "<anonymous>";
            functionName = typeName ? `${typeName}.${methodName}` : methodName;
          }
          let filename = lineMatch[2] && lineMatch[2].startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
          const isNative = lineMatch[5] === "native";
          if (!filename && lineMatch[5] && !isNative) {
            filename = lineMatch[5];
          }
          const isInternal = isNative || filename && // It's not internal if it's an absolute linux path
          !filename.startsWith("/") && // It's not internal if it's an absolute windows path
          !filename.includes(":\\") && // It's not internal if the path is starting with a dot
          !filename.startsWith(".") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack
          !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
          const in_app = !isInternal && filename !== void 0 && !filename.includes("node_modules/");
          return {
            filename,
            module: getModule ? getModule(filename) : void 0,
            function: functionName,
            lineno: parseInt(lineMatch[3], 10) || void 0,
            colno: parseInt(lineMatch[4], 10) || void 0,
            in_app
          };
        }
        if (line.match(FILENAME_MATCH)) {
          return {
            filename: line
          };
        }
        return void 0;
      };
    }
    exports.node = node;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/stacktrace.js
var require_stacktrace = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/stacktrace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var nodeStackTrace = require_node_stack_trace();
    var STACKTRACE_FRAME_LIMIT = 50;
    var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
    function createStackParser(...parsers) {
      const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
      return (stack, skipFirst = 0) => {
        const frames = [];
        const lines = stack.split("\n");
        for (let i2 = skipFirst; i2 < lines.length; i2++) {
          const line = lines[i2];
          if (line.length > 1024) {
            continue;
          }
          const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
          if (cleanedLine.match(/\S*Error: /)) {
            continue;
          }
          for (const parser of sortedParsers) {
            const frame = parser(cleanedLine);
            if (frame) {
              frames.push(frame);
              break;
            }
          }
          if (frames.length >= STACKTRACE_FRAME_LIMIT) {
            break;
          }
        }
        return stripSentryFramesAndReverse(frames);
      };
    }
    function stackParserFromStackParserOptions(stackParser) {
      if (Array.isArray(stackParser)) {
        return createStackParser(...stackParser);
      }
      return stackParser;
    }
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }
      const localStack = stack.slice(0, STACKTRACE_FRAME_LIMIT);
      const lastFrameFunction = localStack[localStack.length - 1].function;
      if (lastFrameFunction && /sentryWrapped/.test(lastFrameFunction)) {
        localStack.pop();
      }
      localStack.reverse();
      const firstFrameFunction = localStack[localStack.length - 1].function;
      if (firstFrameFunction && /captureMessage|captureException/.test(firstFrameFunction)) {
        localStack.pop();
      }
      return localStack.map((frame) => ({
        ...frame,
        filename: frame.filename || localStack[localStack.length - 1].filename,
        function: frame.function || "?"
      }));
    }
    var defaultFunctionName = "<anonymous>";
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== "function") {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e2) {
        return defaultFunctionName;
      }
    }
    function nodeStackLineParser(getModule) {
      return [90, nodeStackTrace.node(getModule)];
    }
    exports.createStackParser = createStackParser;
    exports.getFunctionName = getFunctionName;
    exports.nodeStackLineParser = nodeStackLineParser;
    exports.stackParserFromStackParserOptions = stackParserFromStackParserOptions;
    exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/supports.js
var require_supports = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/supports.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger = require_logger();
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    function supportsErrorEvent() {
      try {
        new ErrorEvent("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsDOMError() {
      try {
        new DOMError("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsDOMException() {
      try {
        new DOMException("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsFetch() {
      if (!("fetch" in WINDOW)) {
        return false;
      }
      try {
        new Headers();
        new Request("http://www.example.com");
        new Response();
        return true;
      } catch (e2) {
        return false;
      }
    }
    function isNativeFetch(func) {
      return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    function supportsNativeFetch() {
      if (!supportsFetch()) {
        return false;
      }
      if (isNativeFetch(WINDOW.fetch)) {
        return true;
      }
      let result = false;
      const doc = WINDOW.document;
      if (doc && typeof doc.createElement === "function") {
        try {
          const sandbox = doc.createElement("iframe");
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            result = isNativeFetch(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
        }
      }
      return result;
    }
    function supportsReportingObserver() {
      return "ReportingObserver" in WINDOW;
    }
    function supportsReferrerPolicy() {
      if (!supportsFetch()) {
        return false;
      }
      try {
        new Request("_", {
          referrerPolicy: "origin"
        });
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.isNativeFetch = isNativeFetch;
    exports.supportsDOMError = supportsDOMError;
    exports.supportsDOMException = supportsDOMException;
    exports.supportsErrorEvent = supportsErrorEvent;
    exports.supportsFetch = supportsFetch;
    exports.supportsNativeFetch = supportsNativeFetch;
    exports.supportsReferrerPolicy = supportsReferrerPolicy;
    exports.supportsReportingObserver = supportsReportingObserver;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/vendor/supportsHistory.js
var require_supportsHistory = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/vendor/supportsHistory.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    function supportsHistory() {
      const chrome = WINDOW.chrome;
      const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
      const hasHistoryApi = "history" in WINDOW && !!WINDOW.history.pushState && !!WINDOW.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    exports.supportsHistory = supportsHistory;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/instrument.js
var require_instrument = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/instrument.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var logger = require_logger();
    var object = require_object();
    var stacktrace = require_stacktrace();
    var supports = require_supports();
    var worldwide = require_worldwide();
    var supportsHistory = require_supportsHistory();
    var WINDOW = worldwide.getGlobalObject();
    var SENTRY_XHR_DATA_KEY = "__sentry_xhr_v2__";
    var handlers = {};
    var instrumented = {};
    function instrument(type) {
      if (instrumented[type]) {
        return;
      }
      instrumented[type] = true;
      switch (type) {
        case "console":
          instrumentConsole();
          break;
        case "dom":
          instrumentDOM();
          break;
        case "xhr":
          instrumentXHR();
          break;
        case "fetch":
          instrumentFetch();
          break;
        case "history":
          instrumentHistory();
          break;
        case "error":
          instrumentError();
          break;
        case "unhandledrejection":
          instrumentUnhandledRejection();
          break;
        default:
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.warn("unknown instrumentation type:", type);
          return;
      }
    }
    function addInstrumentationHandler(type, callback) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(callback);
      instrument(type);
    }
    function triggerHandlers(type, data) {
      if (!type || !handlers[type]) {
        return;
      }
      for (const handler of handlers[type] || []) {
        try {
          handler(data);
        } catch (e2) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.error(
            `Error while triggering instrumentation handler.
Type: ${type}
Name: ${stacktrace.getFunctionName(handler)}
Error:`,
            e2
          );
        }
      }
    }
    function instrumentConsole() {
      if (!("console" in WINDOW)) {
        return;
      }
      logger.CONSOLE_LEVELS.forEach(function(level) {
        if (!(level in WINDOW.console)) {
          return;
        }
        object.fill(WINDOW.console, level, function(originalConsoleMethod) {
          return function(...args) {
            triggerHandlers("console", { args, level });
            if (originalConsoleMethod) {
              originalConsoleMethod.apply(WINDOW.console, args);
            }
          };
        });
      });
    }
    function instrumentFetch() {
      if (!supports.supportsNativeFetch()) {
        return;
      }
      object.fill(WINDOW, "fetch", function(originalFetch) {
        return function(...args) {
          const { method, url } = parseFetchArgs(args);
          const handlerData = {
            args,
            fetchData: {
              method,
              url
            },
            startTimestamp: Date.now()
          };
          triggerHandlers("fetch", {
            ...handlerData
          });
          return originalFetch.apply(WINDOW, args).then(
            (response) => {
              triggerHandlers("fetch", {
                ...handlerData,
                endTimestamp: Date.now(),
                response
              });
              return response;
            },
            (error) => {
              triggerHandlers("fetch", {
                ...handlerData,
                endTimestamp: Date.now(),
                error
              });
              throw error;
            }
          );
        };
      });
    }
    function hasProp(obj, prop) {
      return !!obj && typeof obj === "object" && !!obj[prop];
    }
    function getUrlFromResource(resource) {
      if (typeof resource === "string") {
        return resource;
      }
      if (!resource) {
        return "";
      }
      if (hasProp(resource, "url")) {
        return resource.url;
      }
      if (resource.toString) {
        return resource.toString();
      }
      return "";
    }
    function parseFetchArgs(fetchArgs) {
      if (fetchArgs.length === 0) {
        return { method: "GET", url: "" };
      }
      if (fetchArgs.length === 2) {
        const [url, options] = fetchArgs;
        return {
          url: getUrlFromResource(url),
          method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
        };
      }
      const arg = fetchArgs[0];
      return {
        url: getUrlFromResource(arg),
        method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
      };
    }
    function instrumentXHR() {
      if (!("XMLHttpRequest" in WINDOW)) {
        return;
      }
      const xhrproto = XMLHttpRequest.prototype;
      object.fill(xhrproto, "open", function(originalOpen) {
        return function(...args) {
          const url = args[1];
          const xhrInfo = this[SENTRY_XHR_DATA_KEY] = {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            method: is.isString(args[0]) ? args[0].toUpperCase() : args[0],
            url: args[1],
            request_headers: {}
          };
          if (is.isString(url) && xhrInfo.method === "POST" && url.match(/sentry_key/)) {
            this.__sentry_own_request__ = true;
          }
          const onreadystatechangeHandler = () => {
            const xhrInfo2 = this[SENTRY_XHR_DATA_KEY];
            if (!xhrInfo2) {
              return;
            }
            if (this.readyState === 4) {
              try {
                xhrInfo2.status_code = this.status;
              } catch (e2) {
              }
              triggerHandlers("xhr", {
                args,
                endTimestamp: Date.now(),
                startTimestamp: Date.now(),
                xhr: this
              });
            }
          };
          if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
            object.fill(this, "onreadystatechange", function(original) {
              return function(...readyStateArgs) {
                onreadystatechangeHandler();
                return original.apply(this, readyStateArgs);
              };
            });
          } else {
            this.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          object.fill(this, "setRequestHeader", function(original) {
            return function(...setRequestHeaderArgs) {
              const [header, value] = setRequestHeaderArgs;
              const xhrInfo2 = this[SENTRY_XHR_DATA_KEY];
              if (xhrInfo2) {
                xhrInfo2.request_headers[header.toLowerCase()] = value;
              }
              return original.apply(this, setRequestHeaderArgs);
            };
          });
          return originalOpen.apply(this, args);
        };
      });
      object.fill(xhrproto, "send", function(originalSend) {
        return function(...args) {
          const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
          if (sentryXhrData && args[0] !== void 0) {
            sentryXhrData.body = args[0];
          }
          triggerHandlers("xhr", {
            args,
            startTimestamp: Date.now(),
            xhr: this
          });
          return originalSend.apply(this, args);
        };
      });
    }
    var lastHref;
    function instrumentHistory() {
      if (!supportsHistory.supportsHistory()) {
        return;
      }
      const oldOnPopState = WINDOW.onpopstate;
      WINDOW.onpopstate = function(...args) {
        const to = WINDOW.location.href;
        const from = lastHref;
        lastHref = to;
        triggerHandlers("history", {
          from,
          to
        });
        if (oldOnPopState) {
          try {
            return oldOnPopState.apply(this, args);
          } catch (_oO) {
          }
        }
      };
      function historyReplacementFunction(originalHistoryFunction) {
        return function(...args) {
          const url = args.length > 2 ? args[2] : void 0;
          if (url) {
            const from = lastHref;
            const to = String(url);
            lastHref = to;
            triggerHandlers("history", {
              from,
              to
            });
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      object.fill(WINDOW.history, "pushState", historyReplacementFunction);
      object.fill(WINDOW.history, "replaceState", historyReplacementFunction);
    }
    var debounceDuration = 1e3;
    var debounceTimerID;
    var lastCapturedEvent;
    function shouldShortcircuitPreviousDebounce(previous, current) {
      if (!previous) {
        return true;
      }
      if (previous.type !== current.type) {
        return true;
      }
      try {
        if (previous.target !== current.target) {
          return true;
        }
      } catch (e2) {
      }
      return false;
    }
    function shouldSkipDOMEvent(event) {
      if (event.type !== "keypress") {
        return false;
      }
      try {
        const target = event.target;
        if (!target || !target.tagName) {
          return true;
        }
        if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
          return false;
        }
      } catch (e2) {
      }
      return true;
    }
    function makeDOMEventHandler(handler, globalListener = false) {
      return (event) => {
        if (!event || lastCapturedEvent === event) {
          return;
        }
        if (shouldSkipDOMEvent(event)) {
          return;
        }
        const name = event.type === "keypress" ? "input" : event.type;
        if (debounceTimerID === void 0) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        }
        clearTimeout(debounceTimerID);
        debounceTimerID = WINDOW.setTimeout(() => {
          debounceTimerID = void 0;
        }, debounceDuration);
      };
    }
    function instrumentDOM() {
      if (!("document" in WINDOW)) {
        return;
      }
      const triggerDOMHandler = triggerHandlers.bind(null, "dom");
      const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      WINDOW.document.addEventListener("click", globalDOMEventHandler, false);
      WINDOW.document.addEventListener("keypress", globalDOMEventHandler, false);
      ["EventTarget", "Node"].forEach((target) => {
        const proto = WINDOW[target] && WINDOW[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
          return;
        }
        object.fill(proto, "addEventListener", function(originalAddEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el = this;
                const handlers2 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
                if (!handlerForType.handler) {
                  const handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount++;
              } catch (e2) {
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        object.fill(
          proto,
          "removeEventListener",
          function(originalRemoveEventListener) {
            return function(type, listener, options) {
              if (type === "click" || type == "keypress") {
                try {
                  const el = this;
                  const handlers2 = el.__sentry_instrumentation_handlers__ || {};
                  const handlerForType = handlers2[type];
                  if (handlerForType) {
                    handlerForType.refCount--;
                    if (handlerForType.refCount <= 0) {
                      originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                      handlerForType.handler = void 0;
                      delete handlers2[type];
                    }
                    if (Object.keys(handlers2).length === 0) {
                      delete el.__sentry_instrumentation_handlers__;
                    }
                  }
                } catch (e2) {
                }
              }
              return originalRemoveEventListener.call(this, type, listener, options);
            };
          }
        );
      });
    }
    var _oldOnErrorHandler = null;
    function instrumentError() {
      _oldOnErrorHandler = WINDOW.onerror;
      WINDOW.onerror = function(msg, url, line, column, error) {
        triggerHandlers("error", {
          column,
          error,
          line,
          msg,
          url
        });
        if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
      WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;
    }
    var _oldOnUnhandledRejectionHandler = null;
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;
      WINDOW.onunhandledrejection = function(e2) {
        triggerHandlers("unhandledrejection", e2);
        if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
      WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
    }
    exports.SENTRY_XHR_DATA_KEY = SENTRY_XHR_DATA_KEY;
    exports.addInstrumentationHandler = addInstrumentationHandler;
    exports.parseFetchArgs = parseFetchArgs;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/memo.js
var require_memo = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/memo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoBuilder() {
      const hasWeakSet = typeof WeakSet === "function";
      const inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
      function memoize(obj) {
        if (hasWeakSet) {
          if (inner.has(obj)) {
            return true;
          }
          inner.add(obj);
          return false;
        }
        for (let i2 = 0; i2 < inner.length; i2++) {
          const value = inner[i2];
          if (value === obj) {
            return true;
          }
        }
        inner.push(obj);
        return false;
      }
      function unmemoize(obj) {
        if (hasWeakSet) {
          inner.delete(obj);
        } else {
          for (let i2 = 0; i2 < inner.length; i2++) {
            if (inner[i2] === obj) {
              inner.splice(i2, 1);
              break;
            }
          }
        }
      }
      return [memoize, unmemoize];
    }
    exports.memoBuilder = memoBuilder;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/misc.js
var require_misc = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/misc.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var object = require_object();
    var string = require_string();
    var worldwide = require_worldwide();
    function uuid4() {
      const gbl = worldwide.GLOBAL_OBJ;
      const crypto2 = gbl.crypto || gbl.msCrypto;
      if (crypto2 && crypto2.randomUUID) {
        return crypto2.randomUUID().replace(/-/g, "");
      }
      const getRandomByte = crypto2 && crypto2.getRandomValues ? () => crypto2.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
      return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
        /[018]/g,
        (c) => (
          // eslint-disable-next-line no-bitwise
          (c ^ (getRandomByte() & 15) >> c / 4).toString(16)
        )
      );
    }
    function getFirstException(event) {
      return event.exception && event.exception.values ? event.exception.values[0] : void 0;
    }
    function getEventDescription(event) {
      const { message, event_id: eventId } = event;
      if (message) {
        return message;
      }
      const firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return `${firstException.type}: ${firstException.value}`;
        }
        return firstException.type || firstException.value || eventId || "<unknown>";
      }
      return eventId || "<unknown>";
    }
    function addExceptionTypeValue(event, value, type) {
      const exception = event.exception = event.exception || {};
      const values = exception.values = exception.values || [];
      const firstException = values[0] = values[0] || {};
      if (!firstException.value) {
        firstException.value = value || "";
      }
      if (!firstException.type) {
        firstException.type = type || "Error";
      }
    }
    function addExceptionMechanism(event, newMechanism) {
      const firstException = getFirstException(event);
      if (!firstException) {
        return;
      }
      const defaultMechanism = { type: "generic", handled: true };
      const currentMechanism = firstException.mechanism;
      firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
      if (newMechanism && "data" in newMechanism) {
        const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
        firstException.mechanism.data = mergedData;
      }
    }
    var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    function parseSemver(input) {
      const match = input.match(SEMVER_REGEXP) || [];
      const major = parseInt(match[1], 10);
      const minor = parseInt(match[2], 10);
      const patch = parseInt(match[3], 10);
      return {
        buildmetadata: match[5],
        major: isNaN(major) ? void 0 : major,
        minor: isNaN(minor) ? void 0 : minor,
        patch: isNaN(patch) ? void 0 : patch,
        prerelease: match[4]
      };
    }
    function addContextToFrame(lines, frame, linesOfContext = 5) {
      if (frame.lineno === void 0) {
        return;
      }
      const maxLines = lines.length;
      const sourceLine = Math.max(Math.min(maxLines, frame.lineno - 1), 0);
      frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map((line) => string.snipLine(line, 0));
      frame.context_line = string.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
      frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map((line) => string.snipLine(line, 0));
    }
    function checkOrSetAlreadyCaught(exception) {
      if (exception && exception.__sentry_captured__) {
        return true;
      }
      try {
        object.addNonEnumerableProperty(exception, "__sentry_captured__", true);
      } catch (err) {
      }
      return false;
    }
    function arrayify(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
    }
    exports.addContextToFrame = addContextToFrame;
    exports.addExceptionMechanism = addExceptionMechanism;
    exports.addExceptionTypeValue = addExceptionTypeValue;
    exports.arrayify = arrayify;
    exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
    exports.getEventDescription = getEventDescription;
    exports.parseSemver = parseSemver;
    exports.uuid4 = uuid4;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/env.js
var require_env = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/env.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBrowserBundle() {
      return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
    }
    function getSDKSource() {
      return "npm";
    }
    exports.getSDKSource = getSDKSource;
    exports.isBrowserBundle = isBrowserBundle;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/node.js
var require_node = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/node.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var env = require_env();
    function isNodeEnv() {
      return !env.isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    }
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    function loadModule(moduleName) {
      let mod;
      try {
        mod = dynamicRequire(module, moduleName);
      } catch (e2) {
      }
      try {
        const { cwd } = dynamicRequire(module, "process");
        mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`);
      } catch (e2) {
      }
      return mod;
    }
    exports.dynamicRequire = dynamicRequire;
    exports.isNodeEnv = isNodeEnv;
    exports.loadModule = loadModule;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/normalize.js
var require_normalize = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/normalize.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var memo = require_memo();
    var object = require_object();
    var stacktrace = require_stacktrace();
    function normalize(input, depth = 100, maxProperties = Infinity) {
      try {
        return visit("", input, depth, maxProperties);
      } catch (err) {
        return { ERROR: `**non-serializable** (${err})` };
      }
    }
    function normalizeToSize(object2, depth = 3, maxSize = 100 * 1024) {
      const normalized = normalize(object2, depth);
      if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object2, depth - 1, maxSize);
      }
      return normalized;
    }
    function visit(key, value, depth = Infinity, maxProperties = Infinity, memo$1 = memo.memoBuilder()) {
      const [memoize, unmemoize] = memo$1;
      if (value == null || // this matches null and undefined -> eqeq not eqeqeq
      ["number", "boolean", "string"].includes(typeof value) && !is.isNaN(value)) {
        return value;
      }
      const stringified = stringifyValue(key, value);
      if (!stringified.startsWith("[object ")) {
        return stringified;
      }
      if (value["__sentry_skip_normalization__"]) {
        return value;
      }
      const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
      if (remainingDepth === 0) {
        return stringified.replace("object ", "");
      }
      if (memoize(value)) {
        return "[Circular ~]";
      }
      const valueWithToJSON = value;
      if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
        try {
          const jsonValue = valueWithToJSON.toJSON();
          return visit("", jsonValue, remainingDepth - 1, maxProperties, memo$1);
        } catch (err) {
        }
      }
      const normalized = Array.isArray(value) ? [] : {};
      let numAdded = 0;
      const visitable = object.convertToPlainObject(value);
      for (const visitKey in visitable) {
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
          continue;
        }
        if (numAdded >= maxProperties) {
          normalized[visitKey] = "[MaxProperties ~]";
          break;
        }
        const visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo$1);
        numAdded++;
      }
      unmemoize(value);
      return normalized;
    }
    function stringifyValue(key, value) {
      try {
        if (key === "domain" && value && typeof value === "object" && value._events) {
          return "[Domain]";
        }
        if (key === "domainEmitter") {
          return "[DomainEmitter]";
        }
        if (typeof global !== "undefined" && value === global) {
          return "[Global]";
        }
        if (typeof window !== "undefined" && value === window) {
          return "[Window]";
        }
        if (typeof document !== "undefined" && value === document) {
          return "[Document]";
        }
        if (is.isSyntheticEvent(value)) {
          return "[SyntheticEvent]";
        }
        if (typeof value === "number" && value !== value) {
          return "[NaN]";
        }
        if (typeof value === "function") {
          return `[Function: ${stacktrace.getFunctionName(value)}]`;
        }
        if (typeof value === "symbol") {
          return `[${String(value)}]`;
        }
        if (typeof value === "bigint") {
          return `[BigInt: ${String(value)}]`;
        }
        const objName = getConstructorName(value);
        if (/^HTML(\w*)Element$/.test(objName)) {
          return `[HTMLElement: ${objName}]`;
        }
        return `[object ${objName}]`;
      } catch (err) {
        return `**non-serializable** (${err})`;
      }
    }
    function getConstructorName(value) {
      const prototype = Object.getPrototypeOf(value);
      return prototype ? prototype.constructor.name : "null prototype";
    }
    function utf8Length(value) {
      return ~-encodeURI(value).split(/%..|./).length;
    }
    function jsonSize(value) {
      return utf8Length(JSON.stringify(value));
    }
    exports.normalize = normalize;
    exports.normalizeToSize = normalizeToSize;
    exports.walk = visit;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/path.js
var require_path = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/path.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeArray(parts, allowAboveRoot) {
      let up = 0;
      for (let i2 = parts.length - 1; i2 >= 0; i2--) {
        const last = parts[i2];
        if (last === ".") {
          parts.splice(i2, 1);
        } else if (last === "..") {
          parts.splice(i2, 1);
          up++;
        } else if (up) {
          parts.splice(i2, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift("..");
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
    function splitPath(filename) {
      const parts = splitPathRe.exec(filename);
      return parts ? parts.slice(1) : [];
    }
    function resolve2(...args) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i2 = args.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        const path4 = i2 >= 0 ? args[i2] : "/";
        if (!path4) {
          continue;
        }
        resolvedPath = `${path4}/${resolvedPath}`;
        resolvedAbsolute = path4.charAt(0) === "/";
      }
      resolvedPath = normalizeArray(
        resolvedPath.split("/").filter((p) => !!p),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }
    function trim(arr) {
      let start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") {
          break;
        }
      }
      let end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") {
          break;
        }
      }
      if (start > end) {
        return [];
      }
      return arr.slice(start, end - start + 1);
    }
    function relative(from, to) {
      from = resolve2(from).slice(1);
      to = resolve2(to).slice(1);
      const fromParts = trim(from.split("/"));
      const toParts = trim(to.split("/"));
      const length = Math.min(fromParts.length, toParts.length);
      let samePartsLength = length;
      for (let i2 = 0; i2 < length; i2++) {
        if (fromParts[i2] !== toParts[i2]) {
          samePartsLength = i2;
          break;
        }
      }
      let outputParts = [];
      for (let i2 = samePartsLength; i2 < fromParts.length; i2++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
    function normalizePath2(path4) {
      const isPathAbsolute = isAbsolute(path4);
      const trailingSlash = path4.slice(-1) === "/";
      let normalizedPath = normalizeArray(
        path4.split("/").filter((p) => !!p),
        !isPathAbsolute
      ).join("/");
      if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = ".";
      }
      if (normalizedPath && trailingSlash) {
        normalizedPath += "/";
      }
      return (isPathAbsolute ? "/" : "") + normalizedPath;
    }
    function isAbsolute(path4) {
      return path4.charAt(0) === "/";
    }
    function join(...args) {
      return normalizePath2(args.join("/"));
    }
    function dirname2(path4) {
      const result = splitPath(path4);
      const root = result[0];
      let dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, dir.length - 1);
      }
      return root + dir;
    }
    function basename(path4, ext) {
      let f3 = splitPath(path4)[2];
      if (ext && f3.slice(ext.length * -1) === ext) {
        f3 = f3.slice(0, f3.length - ext.length);
      }
      return f3;
    }
    exports.basename = basename;
    exports.dirname = dirname2;
    exports.isAbsolute = isAbsolute;
    exports.join = join;
    exports.normalizePath = normalizePath2;
    exports.relative = relative;
    exports.resolve = resolve2;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/syncpromise.js
var require_syncpromise = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/syncpromise.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var States;
    (function(States2) {
      const PENDING = 0;
      States2[States2["PENDING"] = PENDING] = "PENDING";
      const RESOLVED = 1;
      States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
      const REJECTED = 2;
      States2[States2["REJECTED"] = REJECTED] = "REJECTED";
    })(States || (States = {}));
    function resolvedSyncPromise(value) {
      return new SyncPromise((resolve2) => {
        resolve2(value);
      });
    }
    function rejectedSyncPromise(reason) {
      return new SyncPromise((_, reject) => {
        reject(reason);
      });
    }
    var SyncPromise = class {
      __init() {
        this._state = States.PENDING;
      }
      __init2() {
        this._handlers = [];
      }
      constructor(executor) {
        SyncPromise.prototype.__init.call(this);
        SyncPromise.prototype.__init2.call(this);
        SyncPromise.prototype.__init3.call(this);
        SyncPromise.prototype.__init4.call(this);
        SyncPromise.prototype.__init5.call(this);
        SyncPromise.prototype.__init6.call(this);
        try {
          executor(this._resolve, this._reject);
        } catch (e2) {
          this._reject(e2);
        }
      }
      /** JSDoc */
      then(onfulfilled, onrejected) {
        return new SyncPromise((resolve2, reject) => {
          this._handlers.push([
            false,
            (result) => {
              if (!onfulfilled) {
                resolve2(result);
              } else {
                try {
                  resolve2(onfulfilled(result));
                } catch (e2) {
                  reject(e2);
                }
              }
            },
            (reason) => {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve2(onrejected(reason));
                } catch (e2) {
                  reject(e2);
                }
              }
            }
          ]);
          this._executeHandlers();
        });
      }
      /** JSDoc */
      catch(onrejected) {
        return this.then((val) => val, onrejected);
      }
      /** JSDoc */
      finally(onfinally) {
        return new SyncPromise((resolve2, reject) => {
          let val;
          let isRejected;
          return this.then(
            (value) => {
              isRejected = false;
              val = value;
              if (onfinally) {
                onfinally();
              }
            },
            (reason) => {
              isRejected = true;
              val = reason;
              if (onfinally) {
                onfinally();
              }
            }
          ).then(() => {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve2(val);
          });
        });
      }
      /** JSDoc */
      __init3() {
        this._resolve = (value) => {
          this._setResult(States.RESOLVED, value);
        };
      }
      /** JSDoc */
      __init4() {
        this._reject = (reason) => {
          this._setResult(States.REJECTED, reason);
        };
      }
      /** JSDoc */
      __init5() {
        this._setResult = (state, value) => {
          if (this._state !== States.PENDING) {
            return;
          }
          if (is.isThenable(value)) {
            void value.then(this._resolve, this._reject);
            return;
          }
          this._state = state;
          this._value = value;
          this._executeHandlers();
        };
      }
      /** JSDoc */
      __init6() {
        this._executeHandlers = () => {
          if (this._state === States.PENDING) {
            return;
          }
          const cachedHandlers = this._handlers.slice();
          this._handlers = [];
          cachedHandlers.forEach((handler) => {
            if (handler[0]) {
              return;
            }
            if (this._state === States.RESOLVED) {
              handler[1](this._value);
            }
            if (this._state === States.REJECTED) {
              handler[2](this._value);
            }
            handler[0] = true;
          });
        };
      }
    };
    exports.SyncPromise = SyncPromise;
    exports.rejectedSyncPromise = rejectedSyncPromise;
    exports.resolvedSyncPromise = resolvedSyncPromise;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/promisebuffer.js
var require_promisebuffer = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/promisebuffer.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var error = require_error2();
    var syncpromise = require_syncpromise();
    function makePromiseBuffer(limit) {
      const buffer = [];
      function isReady() {
        return limit === void 0 || buffer.length < limit;
      }
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
      }
      function add2(taskProducer) {
        if (!isReady()) {
          return syncpromise.rejectedSyncPromise(new error.SentryError("Not adding Promise because buffer limit was reached."));
        }
        const task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task.then(() => remove(task)).then(
          null,
          () => remove(task).then(null, () => {
          })
        );
        return task;
      }
      function drain(timeout) {
        return new syncpromise.SyncPromise((resolve2, reject) => {
          let counter = buffer.length;
          if (!counter) {
            return resolve2(true);
          }
          const capturedSetTimeout = setTimeout(() => {
            if (timeout && timeout > 0) {
              resolve2(false);
            }
          }, timeout);
          buffer.forEach((item) => {
            void syncpromise.resolvedSyncPromise(item).then(() => {
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve2(true);
              }
            }, reject);
          });
        });
      }
      return {
        $: buffer,
        add: add2,
        drain
      };
    }
    exports.makePromiseBuffer = makePromiseBuffer;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/url.js
var require_url = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/url.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function parseUrl(url) {
      if (!url) {
        return {};
      }
      const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match) {
        return {};
      }
      const query2 = match[6] || "";
      const fragment = match[8] || "";
      return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        search: query2,
        hash: fragment,
        relative: match[5] + query2 + fragment
        // everything minus origin
      };
    }
    function stripUrlQueryAndFragment(urlPath) {
      return urlPath.split(/[\?#]/, 1)[0];
    }
    function getNumberOfUrlSegments(url) {
      return url.split(/\\?\//).filter((s2) => s2.length > 0 && s2 !== ",").length;
    }
    function getSanitizedUrlString(url) {
      const { protocol, host, path: path4 } = url;
      const filteredHost = host && host.replace(/^.*@/, "[filtered]:[filtered]@").replace(":80", "").replace(":443", "") || "";
      return `${protocol ? `${protocol}://` : ""}${filteredHost}${path4}`;
    }
    exports.getNumberOfUrlSegments = getNumberOfUrlSegments;
    exports.getSanitizedUrlString = getSanitizedUrlString;
    exports.parseUrl = parseUrl;
    exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/requestdata.js
var require_requestdata = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/requestdata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var normalize = require_normalize();
    var url = require_url();
    var DEFAULT_INCLUDES = {
      ip: false,
      request: true,
      transaction: true,
      user: true
    };
    var DEFAULT_REQUEST_INCLUDES = ["cookies", "data", "headers", "method", "query_string", "url"];
    var DEFAULT_USER_INCLUDES = ["id", "username", "email"];
    function addRequestDataToTransaction(transaction, req, deps) {
      if (!transaction)
        return;
      if (!transaction.metadata.source || transaction.metadata.source === "url") {
        transaction.setName(...extractPathForTransaction(req, { path: true, method: true }));
      }
      transaction.setData("url", req.originalUrl || req.url);
      if (req.baseUrl) {
        transaction.setData("baseUrl", req.baseUrl);
      }
      transaction.setData("query", extractQueryParams(req, deps));
    }
    function extractPathForTransaction(req, options = {}) {
      const method = req.method && req.method.toUpperCase();
      let path4 = "";
      let source = "url";
      if (options.customRoute || req.route) {
        path4 = options.customRoute || `${req.baseUrl || ""}${req.route && req.route.path}`;
        source = "route";
      } else if (req.originalUrl || req.url) {
        path4 = url.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
      }
      let name = "";
      if (options.method && method) {
        name += method;
      }
      if (options.method && options.path) {
        name += " ";
      }
      if (options.path && path4) {
        name += path4;
      }
      return [name, source];
    }
    function extractTransaction(req, type) {
      switch (type) {
        case "path": {
          return extractPathForTransaction(req, { path: true })[0];
        }
        case "handler": {
          return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || "<anonymous>";
        }
        case "methodPath":
        default: {
          return extractPathForTransaction(req, { path: true, method: true })[0];
        }
      }
    }
    function extractUserData(user, keys) {
      const extractedUser = {};
      const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;
      attributes.forEach((key) => {
        if (user && key in user) {
          extractedUser[key] = user[key];
        }
      });
      return extractedUser;
    }
    function extractRequestData(req, options) {
      const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};
      const requestData = {};
      const headers = req.headers || {};
      const method = req.method;
      const host = req.hostname || req.host || headers.host || "<no host>";
      const protocol = req.protocol === "https" || req.socket && req.socket.encrypted ? "https" : "http";
      const originalUrl = req.originalUrl || req.url || "";
      const absoluteUrl = `${protocol}://${host}${originalUrl}`;
      include.forEach((key) => {
        switch (key) {
          case "headers": {
            requestData.headers = headers;
            break;
          }
          case "method": {
            requestData.method = method;
            break;
          }
          case "url": {
            requestData.url = absoluteUrl;
            break;
          }
          case "cookies": {
            requestData.cookies = // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can
            // come off in v8
            req.cookies || headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie) || {};
            break;
          }
          case "query_string": {
            requestData.query_string = extractQueryParams(req, deps);
            break;
          }
          case "data": {
            if (method === "GET" || method === "HEAD") {
              break;
            }
            if (req.body !== void 0) {
              requestData.data = is.isString(req.body) ? req.body : JSON.stringify(normalize.normalize(req.body));
            }
            break;
          }
          default: {
            if ({}.hasOwnProperty.call(req, key)) {
              requestData[key] = req[key];
            }
          }
        }
      });
      return requestData;
    }
    function addRequestDataToEvent(event, req, options) {
      const include = {
        ...DEFAULT_INCLUDES,
        ...options && options.include
      };
      if (include.request) {
        const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, { include: include.request, deps: options && options.deps }) : extractRequestData(req, { deps: options && options.deps });
        event.request = {
          ...event.request,
          ...extractedRequestData
        };
      }
      if (include.user) {
        const extractedUser = req.user && is.isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};
        if (Object.keys(extractedUser).length) {
          event.user = {
            ...event.user,
            ...extractedUser
          };
        }
      }
      if (include.ip) {
        const ip = req.ip || req.socket && req.socket.remoteAddress;
        if (ip) {
          event.user = {
            ...event.user,
            ip_address: ip
          };
        }
      }
      if (include.transaction && !event.transaction) {
        event.transaction = extractTransaction(req, include.transaction);
      }
      return event;
    }
    function extractQueryParams(req, deps) {
      let originalUrl = req.originalUrl || req.url || "";
      if (!originalUrl) {
        return;
      }
      if (originalUrl.startsWith("/")) {
        originalUrl = `http://dogs.are.great${originalUrl}`;
      }
      return req.query || typeof URL !== void 0 && new URL(originalUrl).search.replace("?", "") || // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node
      deps && deps.url && deps.url.parse(originalUrl).query || void 0;
    }
    exports.addRequestDataToEvent = addRequestDataToEvent;
    exports.addRequestDataToTransaction = addRequestDataToTransaction;
    exports.extractPathForTransaction = extractPathForTransaction;
    exports.extractRequestData = extractRequestData;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/severity.js
var require_severity = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/severity.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
    function severityFromString(level) {
      return severityLevelFromString(level);
    }
    function severityLevelFromString(level) {
      return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
    }
    exports.severityFromString = severityFromString;
    exports.severityLevelFromString = severityLevelFromString;
    exports.validSeverityLevels = validSeverityLevels;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/time.js
var require_time = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/time.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var node = require_node();
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    var dateTimestampSource = {
      nowSeconds: () => Date.now() / 1e3
    };
    function getBrowserPerformance() {
      const { performance: performance2 } = WINDOW;
      if (!performance2 || !performance2.now) {
        return void 0;
      }
      const timeOrigin = Date.now() - performance2.now();
      return {
        now: () => performance2.now(),
        timeOrigin
      };
    }
    function getNodePerformance() {
      try {
        const perfHooks = node.dynamicRequire(module, "perf_hooks");
        return perfHooks.performance;
      } catch (_) {
        return void 0;
      }
    }
    var platformPerformance = node.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
    var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
      nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3
    };
    var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
    var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
    var timestampWithMs = timestampInSeconds;
    var usingPerformanceAPI = platformPerformance !== void 0;
    exports._browserPerformanceTimeOriginMode = void 0;
    var browserPerformanceTimeOrigin = (() => {
      const { performance: performance2 } = WINDOW;
      if (!performance2 || !performance2.now) {
        exports._browserPerformanceTimeOriginMode = "none";
        return void 0;
      }
      const threshold = 3600 * 1e3;
      const performanceNow = performance2.now();
      const dateNow = Date.now();
      const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
      const timeOriginIsReliable = timeOriginDelta < threshold;
      const navigationStart = performance2.timing && performance2.timing.navigationStart;
      const hasNavigationStart = typeof navigationStart === "number";
      const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
      const navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        if (timeOriginDelta <= navigationStartDelta) {
          exports._browserPerformanceTimeOriginMode = "timeOrigin";
          return performance2.timeOrigin;
        } else {
          exports._browserPerformanceTimeOriginMode = "navigationStart";
          return navigationStart;
        }
      }
      exports._browserPerformanceTimeOriginMode = "dateNow";
      return dateNow;
    })();
    exports.browserPerformanceTimeOrigin = browserPerformanceTimeOrigin;
    exports.dateTimestampInSeconds = dateTimestampInSeconds;
    exports.timestampInSeconds = timestampInSeconds;
    exports.timestampWithMs = timestampWithMs;
    exports.usingPerformanceAPI = usingPerformanceAPI;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/tracing.js
var require_tracing = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/tracing.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var TRACEPARENT_REGEXP = new RegExp(
      "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
      // whitespace
    );
    function extractTraceparentData(traceparent) {
      const matches = traceparent.match(TRACEPARENT_REGEXP);
      if (!traceparent || !matches) {
        return void 0;
      }
      let parentSampled;
      if (matches[3] === "1") {
        parentSampled = true;
      } else if (matches[3] === "0") {
        parentSampled = false;
      }
      return {
        traceId: matches[1],
        parentSampled,
        parentSpanId: matches[2]
      };
    }
    exports.TRACEPARENT_REGEXP = TRACEPARENT_REGEXP;
    exports.extractTraceparentData = extractTraceparentData;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/envelope.js
var require_envelope = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/envelope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var dsn = require_dsn();
    var normalize = require_normalize();
    var object = require_object();
    function createEnvelope(headers, items = []) {
      return [headers, items];
    }
    function addItemToEnvelope(envelope, newItem) {
      const [headers, items] = envelope;
      return [headers, [...items, newItem]];
    }
    function forEachEnvelopeItem(envelope, callback) {
      const envelopeItems = envelope[1];
      for (const envelopeItem of envelopeItems) {
        const envelopeItemType = envelopeItem[0].type;
        const result = callback(envelopeItem, envelopeItemType);
        if (result) {
          return true;
        }
      }
      return false;
    }
    function envelopeContainsItemType(envelope, types3) {
      return forEachEnvelopeItem(envelope, (_, type) => types3.includes(type));
    }
    function encodeUTF8(input, textEncoder) {
      const utf8 = textEncoder || new TextEncoder();
      return utf8.encode(input);
    }
    function serializeEnvelope(envelope, textEncoder) {
      const [envHeaders, items] = envelope;
      let parts = JSON.stringify(envHeaders);
      function append(next) {
        if (typeof parts === "string") {
          parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
        } else {
          parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
        }
      }
      for (const item of items) {
        const [itemHeaders, payload] = item;
        append(`
${JSON.stringify(itemHeaders)}
`);
        if (typeof payload === "string" || payload instanceof Uint8Array) {
          append(payload);
        } else {
          let stringifiedPayload;
          try {
            stringifiedPayload = JSON.stringify(payload);
          } catch (e2) {
            stringifiedPayload = JSON.stringify(normalize.normalize(payload));
          }
          append(stringifiedPayload);
        }
      }
      return typeof parts === "string" ? parts : concatBuffers(parts);
    }
    function concatBuffers(buffers) {
      const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
      const merged = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        merged.set(buffer, offset);
        offset += buffer.length;
      }
      return merged;
    }
    function parseEnvelope(env, textEncoder, textDecoder) {
      let buffer = typeof env === "string" ? textEncoder.encode(env) : env;
      function readBinary(length) {
        const bin = buffer.subarray(0, length);
        buffer = buffer.subarray(length + 1);
        return bin;
      }
      function readJson() {
        let i2 = buffer.indexOf(10);
        if (i2 < 0) {
          i2 = buffer.length;
        }
        return JSON.parse(textDecoder.decode(readBinary(i2)));
      }
      const envelopeHeader = readJson();
      const items = [];
      while (buffer.length) {
        const itemHeader = readJson();
        const binaryLength = typeof itemHeader.length === "number" ? itemHeader.length : void 0;
        items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);
      }
      return [envelopeHeader, items];
    }
    function createAttachmentEnvelopeItem(attachment, textEncoder) {
      const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
      return [
        object.dropUndefinedKeys({
          type: "attachment",
          length: buffer.length,
          filename: attachment.filename,
          content_type: attachment.contentType,
          attachment_type: attachment.attachmentType
        }),
        buffer
      ];
    }
    var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
      session: "session",
      sessions: "session",
      attachment: "attachment",
      transaction: "transaction",
      event: "error",
      client_report: "internal",
      user_report: "default",
      profile: "profile",
      replay_event: "replay",
      replay_recording: "replay",
      check_in: "monitor"
    };
    function envelopeItemTypeToDataCategory(type) {
      return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
    }
    function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
      if (!metadataOrEvent || !metadataOrEvent.sdk) {
        return;
      }
      const { name, version: version2 } = metadataOrEvent.sdk;
      return { name, version: version2 };
    }
    function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn$1) {
      const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
      return {
        event_id: event.event_id,
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && { dsn: dsn.dsnToString(dsn$1) },
        ...dynamicSamplingContext && {
          trace: object.dropUndefinedKeys({ ...dynamicSamplingContext })
        }
      };
    }
    exports.addItemToEnvelope = addItemToEnvelope;
    exports.createAttachmentEnvelopeItem = createAttachmentEnvelopeItem;
    exports.createEnvelope = createEnvelope;
    exports.createEventEnvelopeHeaders = createEventEnvelopeHeaders;
    exports.envelopeContainsItemType = envelopeContainsItemType;
    exports.envelopeItemTypeToDataCategory = envelopeItemTypeToDataCategory;
    exports.forEachEnvelopeItem = forEachEnvelopeItem;
    exports.getSdkMetadataForEnvelopeHeader = getSdkMetadataForEnvelopeHeader;
    exports.parseEnvelope = parseEnvelope;
    exports.serializeEnvelope = serializeEnvelope;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/clientreport.js
var require_clientreport = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/clientreport.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var envelope = require_envelope();
    var time = require_time();
    function createClientReportEnvelope(discarded_events, dsn, timestamp) {
      const clientReportItem = [
        { type: "client_report" },
        {
          timestamp: timestamp || time.dateTimestampInSeconds(),
          discarded_events
        }
      ];
      return envelope.createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
    }
    exports.createClientReportEnvelope = createClientReportEnvelope;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/ratelimit.js
var require_ratelimit = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/ratelimit.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_RETRY_AFTER = 60 * 1e3;
    function parseRetryAfterHeader(header, now = Date.now()) {
      const headerDelay = parseInt(`${header}`, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1e3;
      }
      const headerDate = Date.parse(`${header}`);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return DEFAULT_RETRY_AFTER;
    }
    function disabledUntil(limits, category) {
      return limits[category] || limits.all || 0;
    }
    function isRateLimited(limits, category, now = Date.now()) {
      return disabledUntil(limits, category) > now;
    }
    function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
      const updatedRateLimits = {
        ...limits
      };
      const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
      const retryAfterHeader = headers && headers["retry-after"];
      if (rateLimitHeader) {
        for (const limit of rateLimitHeader.trim().split(",")) {
          const [retryAfter, categories] = limit.split(":", 2);
          const headerDelay = parseInt(retryAfter, 10);
          const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
          if (!categories) {
            updatedRateLimits.all = now + delay;
          } else {
            for (const category of categories.split(";")) {
              updatedRateLimits[category] = now + delay;
            }
          }
        }
      } else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
      } else if (statusCode === 429) {
        updatedRateLimits.all = now + 60 * 1e3;
      }
      return updatedRateLimits;
    }
    exports.DEFAULT_RETRY_AFTER = DEFAULT_RETRY_AFTER;
    exports.disabledUntil = disabledUntil;
    exports.isRateLimited = isRateLimited;
    exports.parseRetryAfterHeader = parseRetryAfterHeader;
    exports.updateRateLimits = updateRateLimits;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/baggage.js
var require_baggage = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/baggage.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var logger = require_logger();
    var BAGGAGE_HEADER_NAME = "baggage";
    var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
    var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
    var MAX_BAGGAGE_STRING_LENGTH = 8192;
    function baggageHeaderToDynamicSamplingContext(baggageHeader) {
      if (!is.isString(baggageHeader) && !Array.isArray(baggageHeader)) {
        return void 0;
      }
      let baggageObject = {};
      if (Array.isArray(baggageHeader)) {
        baggageObject = baggageHeader.reduce((acc, curr) => {
          const currBaggageObject = baggageHeaderToObject(curr);
          return {
            ...acc,
            ...currBaggageObject
          };
        }, {});
      } else {
        if (!baggageHeader) {
          return void 0;
        }
        baggageObject = baggageHeaderToObject(baggageHeader);
      }
      const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
        if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
          const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
          acc[nonPrefixedKey] = value;
        }
        return acc;
      }, {});
      if (Object.keys(dynamicSamplingContext).length > 0) {
        return dynamicSamplingContext;
      } else {
        return void 0;
      }
    }
    function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
      const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(
        (acc, [dscKey, dscValue]) => {
          if (dscValue) {
            acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
          }
          return acc;
        },
        {}
      );
      return objectToBaggageHeader(sentryPrefixedDSC);
    }
    function baggageHeaderToObject(baggageHeader) {
      return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {});
    }
    function objectToBaggageHeader(object) {
      if (Object.keys(object).length === 0) {
        return void 0;
      }
      return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
        const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
        const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
        if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.warn(
            `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`
          );
          return baggageHeader;
        } else {
          return newBaggageHeader;
        }
      }, "");
    }
    exports.BAGGAGE_HEADER_NAME = BAGGAGE_HEADER_NAME;
    exports.MAX_BAGGAGE_STRING_LENGTH = MAX_BAGGAGE_STRING_LENGTH;
    exports.SENTRY_BAGGAGE_KEY_PREFIX = SENTRY_BAGGAGE_KEY_PREFIX;
    exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
    exports.baggageHeaderToDynamicSamplingContext = baggageHeaderToDynamicSamplingContext;
    exports.dynamicSamplingContextToSentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/userIntegrations.js
var require_userIntegrations = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/userIntegrations.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function setNestedKey(obj, keyPath, value) {
      const match = keyPath.match(/([a-z_]+)\.(.*)/i);
      if (match === null) {
        obj[keyPath] = value;
      } else {
        const innerObj = obj[match[1]];
        setNestedKey(innerObj, match[2], value);
      }
    }
    function addOrUpdateIntegration(defaultIntegrationInstance, userIntegrations, forcedOptions = {}) {
      return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(
        defaultIntegrationInstance,
        // Somehow TS can't figure out that not being an array makes this necessarily a function
        userIntegrations,
        forcedOptions
      );
    }
    function addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) {
      const userInstance = userIntegrations.find((integration) => integration.name === defaultIntegrationInstance.name);
      if (userInstance) {
        for (const [keyPath, value] of Object.entries(forcedOptions)) {
          setNestedKey(userInstance, keyPath, value);
        }
        return userIntegrations;
      }
      return [...userIntegrations, defaultIntegrationInstance];
    }
    function addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {
      const wrapper = (defaultIntegrations) => {
        const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);
        if (defaultIntegrationInstance.allowExclusionByUser) {
          const userFinalInstance = userFinalIntegrations.find(
            (integration) => integration.name === defaultIntegrationInstance.name
          );
          if (!userFinalInstance) {
            return userFinalIntegrations;
          }
        }
        return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);
      };
      return wrapper;
    }
    exports.addOrUpdateIntegration = addOrUpdateIntegration;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/vendor/escapeStringForRegex.js
var require_escapeStringForRegex = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/vendor/escapeStringForRegex.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function escapeStringForRegex(regexString) {
      return regexString.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports.escapeStringForRegex = escapeStringForRegex;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var browser = require_browser();
    var dsn = require_dsn();
    var error = require_error2();
    var worldwide = require_worldwide();
    var instrument = require_instrument();
    var is = require_is();
    var logger = require_logger();
    var memo = require_memo();
    var misc = require_misc();
    var node = require_node();
    var normalize = require_normalize();
    var object = require_object();
    var path4 = require_path();
    var promisebuffer = require_promisebuffer();
    var requestdata = require_requestdata();
    var severity = require_severity();
    var stacktrace = require_stacktrace();
    var string = require_string();
    var supports = require_supports();
    var syncpromise = require_syncpromise();
    var time = require_time();
    var tracing = require_tracing();
    var env = require_env();
    var envelope = require_envelope();
    var clientreport = require_clientreport();
    var ratelimit = require_ratelimit();
    var baggage = require_baggage();
    var url = require_url();
    var userIntegrations = require_userIntegrations();
    var escapeStringForRegex = require_escapeStringForRegex();
    var supportsHistory = require_supportsHistory();
    exports.getDomElement = browser.getDomElement;
    exports.getLocationHref = browser.getLocationHref;
    exports.htmlTreeAsString = browser.htmlTreeAsString;
    exports.dsnFromString = dsn.dsnFromString;
    exports.dsnToString = dsn.dsnToString;
    exports.makeDsn = dsn.makeDsn;
    exports.SentryError = error.SentryError;
    exports.GLOBAL_OBJ = worldwide.GLOBAL_OBJ;
    exports.getGlobalObject = worldwide.getGlobalObject;
    exports.getGlobalSingleton = worldwide.getGlobalSingleton;
    exports.SENTRY_XHR_DATA_KEY = instrument.SENTRY_XHR_DATA_KEY;
    exports.addInstrumentationHandler = instrument.addInstrumentationHandler;
    exports.parseFetchArgs = instrument.parseFetchArgs;
    exports.isDOMError = is.isDOMError;
    exports.isDOMException = is.isDOMException;
    exports.isElement = is.isElement;
    exports.isError = is.isError;
    exports.isErrorEvent = is.isErrorEvent;
    exports.isEvent = is.isEvent;
    exports.isInstanceOf = is.isInstanceOf;
    exports.isNaN = is.isNaN;
    exports.isPlainObject = is.isPlainObject;
    exports.isPrimitive = is.isPrimitive;
    exports.isRegExp = is.isRegExp;
    exports.isString = is.isString;
    exports.isSyntheticEvent = is.isSyntheticEvent;
    exports.isThenable = is.isThenable;
    exports.CONSOLE_LEVELS = logger.CONSOLE_LEVELS;
    exports.consoleSandbox = logger.consoleSandbox;
    Object.defineProperty(exports, "logger", {
      enumerable: true,
      get: () => logger.logger
    });
    exports.memoBuilder = memo.memoBuilder;
    exports.addContextToFrame = misc.addContextToFrame;
    exports.addExceptionMechanism = misc.addExceptionMechanism;
    exports.addExceptionTypeValue = misc.addExceptionTypeValue;
    exports.arrayify = misc.arrayify;
    exports.checkOrSetAlreadyCaught = misc.checkOrSetAlreadyCaught;
    exports.getEventDescription = misc.getEventDescription;
    exports.parseSemver = misc.parseSemver;
    exports.uuid4 = misc.uuid4;
    exports.dynamicRequire = node.dynamicRequire;
    exports.isNodeEnv = node.isNodeEnv;
    exports.loadModule = node.loadModule;
    exports.normalize = normalize.normalize;
    exports.normalizeToSize = normalize.normalizeToSize;
    exports.walk = normalize.walk;
    exports.addNonEnumerableProperty = object.addNonEnumerableProperty;
    exports.convertToPlainObject = object.convertToPlainObject;
    exports.dropUndefinedKeys = object.dropUndefinedKeys;
    exports.extractExceptionKeysForMessage = object.extractExceptionKeysForMessage;
    exports.fill = object.fill;
    exports.getOriginalFunction = object.getOriginalFunction;
    exports.markFunctionWrapped = object.markFunctionWrapped;
    exports.objectify = object.objectify;
    exports.urlEncode = object.urlEncode;
    exports.basename = path4.basename;
    exports.dirname = path4.dirname;
    exports.isAbsolute = path4.isAbsolute;
    exports.join = path4.join;
    exports.normalizePath = path4.normalizePath;
    exports.relative = path4.relative;
    exports.resolve = path4.resolve;
    exports.makePromiseBuffer = promisebuffer.makePromiseBuffer;
    exports.addRequestDataToEvent = requestdata.addRequestDataToEvent;
    exports.addRequestDataToTransaction = requestdata.addRequestDataToTransaction;
    exports.extractPathForTransaction = requestdata.extractPathForTransaction;
    exports.extractRequestData = requestdata.extractRequestData;
    exports.severityFromString = severity.severityFromString;
    exports.severityLevelFromString = severity.severityLevelFromString;
    exports.validSeverityLevels = severity.validSeverityLevels;
    exports.createStackParser = stacktrace.createStackParser;
    exports.getFunctionName = stacktrace.getFunctionName;
    exports.nodeStackLineParser = stacktrace.nodeStackLineParser;
    exports.stackParserFromStackParserOptions = stacktrace.stackParserFromStackParserOptions;
    exports.stripSentryFramesAndReverse = stacktrace.stripSentryFramesAndReverse;
    exports.isMatchingPattern = string.isMatchingPattern;
    exports.safeJoin = string.safeJoin;
    exports.snipLine = string.snipLine;
    exports.stringMatchesSomePattern = string.stringMatchesSomePattern;
    exports.truncate = string.truncate;
    exports.isNativeFetch = supports.isNativeFetch;
    exports.supportsDOMError = supports.supportsDOMError;
    exports.supportsDOMException = supports.supportsDOMException;
    exports.supportsErrorEvent = supports.supportsErrorEvent;
    exports.supportsFetch = supports.supportsFetch;
    exports.supportsNativeFetch = supports.supportsNativeFetch;
    exports.supportsReferrerPolicy = supports.supportsReferrerPolicy;
    exports.supportsReportingObserver = supports.supportsReportingObserver;
    exports.SyncPromise = syncpromise.SyncPromise;
    exports.rejectedSyncPromise = syncpromise.rejectedSyncPromise;
    exports.resolvedSyncPromise = syncpromise.resolvedSyncPromise;
    Object.defineProperty(exports, "_browserPerformanceTimeOriginMode", {
      enumerable: true,
      get: () => time._browserPerformanceTimeOriginMode
    });
    exports.browserPerformanceTimeOrigin = time.browserPerformanceTimeOrigin;
    exports.dateTimestampInSeconds = time.dateTimestampInSeconds;
    exports.timestampInSeconds = time.timestampInSeconds;
    exports.timestampWithMs = time.timestampWithMs;
    exports.usingPerformanceAPI = time.usingPerformanceAPI;
    exports.TRACEPARENT_REGEXP = tracing.TRACEPARENT_REGEXP;
    exports.extractTraceparentData = tracing.extractTraceparentData;
    exports.getSDKSource = env.getSDKSource;
    exports.isBrowserBundle = env.isBrowserBundle;
    exports.addItemToEnvelope = envelope.addItemToEnvelope;
    exports.createAttachmentEnvelopeItem = envelope.createAttachmentEnvelopeItem;
    exports.createEnvelope = envelope.createEnvelope;
    exports.createEventEnvelopeHeaders = envelope.createEventEnvelopeHeaders;
    exports.envelopeContainsItemType = envelope.envelopeContainsItemType;
    exports.envelopeItemTypeToDataCategory = envelope.envelopeItemTypeToDataCategory;
    exports.forEachEnvelopeItem = envelope.forEachEnvelopeItem;
    exports.getSdkMetadataForEnvelopeHeader = envelope.getSdkMetadataForEnvelopeHeader;
    exports.parseEnvelope = envelope.parseEnvelope;
    exports.serializeEnvelope = envelope.serializeEnvelope;
    exports.createClientReportEnvelope = clientreport.createClientReportEnvelope;
    exports.DEFAULT_RETRY_AFTER = ratelimit.DEFAULT_RETRY_AFTER;
    exports.disabledUntil = ratelimit.disabledUntil;
    exports.isRateLimited = ratelimit.isRateLimited;
    exports.parseRetryAfterHeader = ratelimit.parseRetryAfterHeader;
    exports.updateRateLimits = ratelimit.updateRateLimits;
    exports.BAGGAGE_HEADER_NAME = baggage.BAGGAGE_HEADER_NAME;
    exports.MAX_BAGGAGE_STRING_LENGTH = baggage.MAX_BAGGAGE_STRING_LENGTH;
    exports.SENTRY_BAGGAGE_KEY_PREFIX = baggage.SENTRY_BAGGAGE_KEY_PREFIX;
    exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = baggage.SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
    exports.baggageHeaderToDynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext;
    exports.dynamicSamplingContextToSentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader;
    exports.getNumberOfUrlSegments = url.getNumberOfUrlSegments;
    exports.getSanitizedUrlString = url.getSanitizedUrlString;
    exports.parseUrl = url.parseUrl;
    exports.stripUrlQueryAndFragment = url.stripUrlQueryAndFragment;
    exports.addOrUpdateIntegration = userIntegrations.addOrUpdateIntegration;
    exports.escapeStringForRegex = escapeStringForRegex.escapeStringForRegex;
    exports.supportsHistory = supportsHistory.supportsHistory;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/constants.js
var require_constants = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/constants.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_ENVIRONMENT = "production";
    exports.DEFAULT_ENVIRONMENT = DEFAULT_ENVIRONMENT;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/session.js
var require_session = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/session.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function makeSession(context) {
      const startingTime = utils.timestampInSeconds();
      const session = {
        sid: utils.uuid4(),
        init: true,
        timestamp: startingTime,
        started: startingTime,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: false,
        toJSON: () => sessionToJSON(session)
      };
      if (context) {
        updateSession(session, context);
      }
      return session;
    }
    function updateSession(session, context = {}) {
      if (context.user) {
        if (!session.ipAddress && context.user.ip_address) {
          session.ipAddress = context.user.ip_address;
        }
        if (!session.did && !context.did) {
          session.did = context.user.id || context.user.email || context.user.username;
        }
      }
      session.timestamp = context.timestamp || utils.timestampInSeconds();
      if (context.ignoreDuration) {
        session.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        session.sid = context.sid.length === 32 ? context.sid : utils.uuid4();
      }
      if (context.init !== void 0) {
        session.init = context.init;
      }
      if (!session.did && context.did) {
        session.did = `${context.did}`;
      }
      if (typeof context.started === "number") {
        session.started = context.started;
      }
      if (session.ignoreDuration) {
        session.duration = void 0;
      } else if (typeof context.duration === "number") {
        session.duration = context.duration;
      } else {
        const duration = session.timestamp - session.started;
        session.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        session.release = context.release;
      }
      if (context.environment) {
        session.environment = context.environment;
      }
      if (!session.ipAddress && context.ipAddress) {
        session.ipAddress = context.ipAddress;
      }
      if (!session.userAgent && context.userAgent) {
        session.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        session.errors = context.errors;
      }
      if (context.status) {
        session.status = context.status;
      }
    }
    function closeSession(session, status) {
      let context = {};
      if (status) {
        context = { status };
      } else if (session.status === "ok") {
        context = { status: "exited" };
      }
      updateSession(session, context);
    }
    function sessionToJSON(session) {
      return utils.dropUndefinedKeys({
        sid: `${session.sid}`,
        init: session.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(session.started * 1e3).toISOString(),
        timestamp: new Date(session.timestamp * 1e3).toISOString(),
        status: session.status,
        errors: session.errors,
        did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
        duration: session.duration,
        attrs: {
          release: session.release,
          environment: session.environment,
          ip_address: session.ipAddress,
          user_agent: session.userAgent
        }
      });
    }
    exports.closeSession = closeSession;
    exports.makeSession = makeSession;
    exports.updateSession = updateSession;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/scope.js
var require_scope = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/scope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var session = require_session();
    var DEFAULT_MAX_BREADCRUMBS = 100;
    var Scope = class {
      /** Flag if notifying is happening. */
      /** Callback for client to receive scope changes. */
      /** Callback list that will be called after {@link applyToEvent}. */
      /** Array of breadcrumbs. */
      /** User */
      /** Tags */
      /** Extra */
      /** Contexts */
      /** Attachments */
      /**
       * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
       * sent to Sentry
       */
      /** Fingerprint */
      /** Severity */
      // eslint-disable-next-line deprecation/deprecation
      /** Transaction Name */
      /** Span */
      /** Session */
      /** Request Mode Session Status */
      // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
      constructor() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._attachments = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
      }
      /**
       * Inherit values from the parent scope.
       * @param scope to clone.
       */
      static clone(scope) {
        const newScope = new Scope();
        if (scope) {
          newScope._breadcrumbs = [...scope._breadcrumbs];
          newScope._tags = { ...scope._tags };
          newScope._extra = { ...scope._extra };
          newScope._contexts = { ...scope._contexts };
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = [...scope._eventProcessors];
          newScope._requestSession = scope._requestSession;
          newScope._attachments = [...scope._attachments];
          newScope._sdkProcessingMetadata = { ...scope._sdkProcessingMetadata };
        }
        return newScope;
      }
      /**
       * Add internal on change listener. Used for sub SDKs that need to store the scope.
       * @hidden
       */
      addScopeListener(callback) {
        this._scopeListeners.push(callback);
      }
      /**
       * @inheritDoc
       */
      addEventProcessor(callback) {
        this._eventProcessors.push(callback);
        return this;
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
        this._user = user || {};
        if (this._session) {
          session.updateSession(this._session, { user });
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getUser() {
        return this._user;
      }
      /**
       * @inheritDoc
       */
      getRequestSession() {
        return this._requestSession;
      }
      /**
       * @inheritDoc
       */
      setRequestSession(requestSession) {
        this._requestSession = requestSession;
        return this;
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
        this._tags = {
          ...this._tags,
          ...tags
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
        this._tags = { ...this._tags, [key]: value };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtras(extras) {
        this._extra = {
          ...this._extra,
          ...extras
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtra(key, extra) {
        this._extra = { ...this._extra, [key]: extra };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setFingerprint(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setLevel(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setTransactionName(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setContext(key, context) {
        if (context === null) {
          delete this._contexts[key];
        } else {
          this._contexts[key] = context;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setSpan(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getSpan() {
        return this._span;
      }
      /**
       * @inheritDoc
       */
      getTransaction() {
        const span = this.getSpan();
        return span && span.transaction;
      }
      /**
       * @inheritDoc
       */
      setSession(session2) {
        if (!session2) {
          delete this._session;
        } else {
          this._session = session2;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getSession() {
        return this._session;
      }
      /**
       * @inheritDoc
       */
      update(captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === "function") {
          const updatedScope = captureContext(this);
          return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
          this._tags = { ...this._tags, ...captureContext._tags };
          this._extra = { ...this._extra, ...captureContext._extra };
          this._contexts = { ...this._contexts, ...captureContext._contexts };
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        } else if (utils.isPlainObject(captureContext)) {
          captureContext = captureContext;
          this._tags = { ...this._tags, ...captureContext.tags };
          this._extra = { ...this._extra, ...captureContext.extra };
          this._contexts = { ...this._contexts, ...captureContext.contexts };
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      }
      /**
       * @inheritDoc
       */
      clear() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        this._attachments = [];
        return this;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, maxBreadcrumbs) {
        const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        const mergedBreadcrumb = {
          timestamp: utils.dateTimestampInSeconds(),
          ...breadcrumb
        };
        this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }
      /**
       * @inheritDoc
       */
      clearBreadcrumbs() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      addAttachment(attachment) {
        this._attachments.push(attachment);
        return this;
      }
      /**
       * @inheritDoc
       */
      getAttachments() {
        return this._attachments;
      }
      /**
       * @inheritDoc
       */
      clearAttachments() {
        this._attachments = [];
        return this;
      }
      /**
       * Applies data from the scope to the event and runs all event processors on it.
       *
       * @param event Event
       * @param hint Object containing additional information about the original exception, for use by the event processors.
       * @hidden
       */
      applyToEvent(event, hint = {}) {
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = { ...this._extra, ...event.extra };
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = { ...this._tags, ...event.tags };
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = { ...this._user, ...event.user };
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = { ...this._contexts, ...event.contexts };
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        if (this._span) {
          event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };
          const transaction = this._span.transaction;
          if (transaction) {
            event.sdkProcessingMetadata = {
              dynamicSamplingContext: transaction.getDynamicSamplingContext(),
              ...event.sdkProcessingMetadata
            };
            const transactionName = transaction.name;
            if (transactionName) {
              event.tags = { transaction: transactionName, ...event.tags };
            }
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = [...event.breadcrumbs || [], ...this._breadcrumbs];
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
        event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };
        return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);
      }
      /**
       * Add data which will be accessible during event processing but won't get sent to Sentry
       */
      setSDKProcessingMetadata(newData) {
        this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
        return this;
      }
      /**
       * This will be called after {@link applyToEvent} is finished.
       */
      _notifyEventProcessors(processors, event, hint, index = 0) {
        return new utils.SyncPromise((resolve2, reject) => {
          const processor = processors[index];
          if (event === null || typeof processor !== "function") {
            resolve2(event);
          } else {
            const result = processor({ ...event }, hint);
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && processor.id && result === null && utils.logger.log(`Event processor "${processor.id}" dropped event`);
            if (utils.isThenable(result)) {
              void result.then((final) => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve2)).then(null, reject);
            } else {
              void this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve2).then(null, reject);
            }
          }
        });
      }
      /**
       * This will be called on every set call.
       */
      _notifyScopeListeners() {
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach((callback) => {
            callback(this);
          });
          this._notifyingListeners = false;
        }
      }
      /**
       * Applies fingerprint from the scope to the event if there's one,
       * uses message if there's one instead or get rid of empty fingerprint
       */
      _applyFingerprint(event) {
        event.fingerprint = event.fingerprint ? utils.arrayify(event.fingerprint) : [];
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      }
    };
    function getGlobalEventProcessors() {
      return utils.getGlobalSingleton("globalEventProcessors", () => []);
    }
    function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
    }
    exports.Scope = Scope;
    exports.addGlobalEventProcessor = addGlobalEventProcessor;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/hub.js
var require_hub = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/hub.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants2 = require_constants();
    var scope = require_scope();
    var session = require_session();
    var API_VERSION = 4;
    var DEFAULT_BREADCRUMBS = 100;
    var Hub = class {
      /** Is a {@link Layer}[] containing the client and scope */
      /** Contains the last event id of a captured event.  */
      /**
       * Creates a new instance of the hub, will push one {@link Layer} into the
       * internal stack on creation.
       *
       * @param client bound to the hub.
       * @param scope bound to the hub.
       * @param version number, higher number means higher priority.
       */
      constructor(client, scope$1 = new scope.Scope(), _version = API_VERSION) {
        this._version = _version;
        this._stack = [{ scope: scope$1 }];
        if (client) {
          this.bindClient(client);
        }
      }
      /**
       * @inheritDoc
       */
      isOlderThan(version2) {
        return this._version < version2;
      }
      /**
       * @inheritDoc
       */
      bindClient(client) {
        const top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      }
      /**
       * @inheritDoc
       */
      pushScope() {
        const scope$1 = scope.Scope.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope: scope$1
        });
        return scope$1;
      }
      /**
       * @inheritDoc
       */
      popScope() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      }
      /**
       * @inheritDoc
       */
      withScope(callback) {
        const scope2 = this.pushScope();
        try {
          callback(scope2);
        } finally {
          this.popScope();
        }
      }
      /**
       * @inheritDoc
       */
      getClient() {
        return this.getStackTop().client;
      }
      /** Returns the scope of the top stack. */
      getScope() {
        return this.getStackTop().scope;
      }
      /** Returns the scope stack for domains or the process. */
      getStack() {
        return this._stack;
      }
      /** Returns the topmost scope layer in the order domain > local > process. */
      getStackTop() {
        return this._stack[this._stack.length - 1];
      }
      /**
       * @inheritDoc
       */
      captureException(exception, hint) {
        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        const syntheticException = new Error("Sentry syntheticException");
        this._withClient((client, scope2) => {
          client.captureException(
            exception,
            {
              originalException: exception,
              syntheticException,
              ...hint,
              event_id: eventId
            },
            scope2
          );
        });
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message, level, hint) {
        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        const syntheticException = new Error(message);
        this._withClient((client, scope2) => {
          client.captureMessage(
            message,
            level,
            {
              originalException: message,
              syntheticException,
              ...hint,
              event_id: eventId
            },
            scope2
          );
        });
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        if (!event.type) {
          this._lastEventId = eventId;
        }
        this._withClient((client, scope2) => {
          client.captureEvent(event, { ...hint, event_id: eventId }, scope2);
        });
        return eventId;
      }
      /**
       * @inheritDoc
       */
      lastEventId() {
        return this._lastEventId;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, hint) {
        const { scope: scope2, client } = this.getStackTop();
        if (!client)
          return;
        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
        if (maxBreadcrumbs <= 0)
          return;
        const timestamp = utils.dateTimestampInSeconds();
        const mergedBreadcrumb = { timestamp, ...breadcrumb };
        const finalBreadcrumb = beforeBreadcrumb ? utils.consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        if (client.emit) {
          client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
        }
        scope2.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
        this.getScope().setUser(user);
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
        this.getScope().setTags(tags);
      }
      /**
       * @inheritDoc
       */
      setExtras(extras) {
        this.getScope().setExtras(extras);
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
        this.getScope().setTag(key, value);
      }
      /**
       * @inheritDoc
       */
      setExtra(key, extra) {
        this.getScope().setExtra(key, extra);
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setContext(name, context) {
        this.getScope().setContext(name, context);
      }
      /**
       * @inheritDoc
       */
      configureScope(callback) {
        const { scope: scope2, client } = this.getStackTop();
        if (client) {
          callback(scope2);
        }
      }
      /**
       * @inheritDoc
       */
      run(callback) {
        const oldHub = makeMain(this);
        try {
          callback(this);
        } finally {
          makeMain(oldHub);
        }
      }
      /**
       * @inheritDoc
       */
      getIntegration(integration) {
        const client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
          return null;
        }
      }
      /**
       * @inheritDoc
       */
      startTransaction(context, customSamplingContext) {
        const result = this._callExtensionMethod("startTransaction", context, customSamplingContext);
        if ((typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && !result) {
          console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
        }
        return result;
      }
      /**
       * @inheritDoc
       */
      traceHeaders() {
        return this._callExtensionMethod("traceHeaders");
      }
      /**
       * @inheritDoc
       */
      captureSession(endSession = false) {
        if (endSession) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      }
      /**
       * @inheritDoc
       */
      endSession() {
        const layer = this.getStackTop();
        const scope2 = layer.scope;
        const session$1 = scope2.getSession();
        if (session$1) {
          session.closeSession(session$1);
        }
        this._sendSessionUpdate();
        scope2.setSession();
      }
      /**
       * @inheritDoc
       */
      startSession(context) {
        const { scope: scope2, client } = this.getStackTop();
        const { release, environment = constants2.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
        const { userAgent } = utils.GLOBAL_OBJ.navigator || {};
        const session$1 = session.makeSession({
          release,
          environment,
          user: scope2.getUser(),
          ...userAgent && { userAgent },
          ...context
        });
        const currentSession = scope2.getSession && scope2.getSession();
        if (currentSession && currentSession.status === "ok") {
          session.updateSession(currentSession, { status: "exited" });
        }
        this.endSession();
        scope2.setSession(session$1);
        return session$1;
      }
      /**
       * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
       * when Tracing is used.
       */
      shouldSendDefaultPii() {
        const client = this.getClient();
        const options = client && client.getOptions();
        return Boolean(options && options.sendDefaultPii);
      }
      /**
       * Sends the current Session on the scope
       */
      _sendSessionUpdate() {
        const { scope: scope2, client } = this.getStackTop();
        const session2 = scope2.getSession();
        if (session2 && client && client.captureSession) {
          client.captureSession(session2);
        }
      }
      /**
       * Internal helper function to call a method on the top client if it exists.
       *
       * @param method The method to call on the client.
       * @param args Arguments to pass to the client function.
       */
      _withClient(callback) {
        const { scope: scope2, client } = this.getStackTop();
        if (client) {
          callback(client, scope2);
        }
      }
      /**
       * Calls global extension method and binding current instance to the function call
       */
      // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _callExtensionMethod(method, ...args) {
        const carrier = getMainCarrier();
        const sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
      }
    };
    function getMainCarrier() {
      utils.GLOBAL_OBJ.__SENTRY__ = utils.GLOBAL_OBJ.__SENTRY__ || {
        extensions: {},
        hub: void 0
      };
      return utils.GLOBAL_OBJ;
    }
    function makeMain(hub) {
      const registry = getMainCarrier();
      const oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
    }
    function getCurrentHub() {
      const registry = getMainCarrier();
      if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
        const hub = registry.__SENTRY__.acs.getCurrentHub();
        if (hub) {
          return hub;
        }
      }
      return getGlobalHub(registry);
    }
    function getGlobalHub(registry = getMainCarrier()) {
      if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
      }
      return getHubFromCarrier(registry);
    }
    function ensureHubOnCarrier(carrier, parent = getGlobalHub()) {
      if (!hasHubOnCarrier(carrier) || getHubFromCarrier(carrier).isOlderThan(API_VERSION)) {
        const globalHubTopStack = parent.getStackTop();
        setHubOnCarrier(carrier, new Hub(globalHubTopStack.client, scope.Scope.clone(globalHubTopStack.scope)));
      }
    }
    function setAsyncContextStrategy(strategy) {
      const registry = getMainCarrier();
      registry.__SENTRY__ = registry.__SENTRY__ || {};
      registry.__SENTRY__.acs = strategy;
    }
    function runWithAsyncContext(callback, options = {}) {
      const registry = getMainCarrier();
      if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
        return registry.__SENTRY__.acs.runWithAsyncContext(callback, options);
      }
      return callback();
    }
    function hasHubOnCarrier(carrier) {
      return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    function getHubFromCarrier(carrier) {
      return utils.getGlobalSingleton("hub", () => new Hub(), carrier);
    }
    function setHubOnCarrier(carrier, hub) {
      if (!carrier)
        return false;
      const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      __SENTRY__.hub = hub;
      return true;
    }
    exports.API_VERSION = API_VERSION;
    exports.Hub = Hub;
    exports.ensureHubOnCarrier = ensureHubOnCarrier;
    exports.getCurrentHub = getCurrentHub;
    exports.getHubFromCarrier = getHubFromCarrier;
    exports.getMainCarrier = getMainCarrier;
    exports.makeMain = makeMain;
    exports.runWithAsyncContext = runWithAsyncContext;
    exports.setAsyncContextStrategy = setAsyncContextStrategy;
    exports.setHubOnCarrier = setHubOnCarrier;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/utils/hasTracingEnabled.js
var require_hasTracingEnabled = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/utils/hasTracingEnabled.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub = require_hub();
    function hasTracingEnabled(maybeOptions) {
      if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
        return false;
      }
      const client = hub.getCurrentHub().getClient();
      const options = maybeOptions || client && client.getOptions();
      return !!options && (options.enableTracing || "tracesSampleRate" in options || "tracesSampler" in options);
    }
    exports.hasTracingEnabled = hasTracingEnabled;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/utils.js
var require_utils = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub = require_hub();
    var utils = require_cjs();
    function getActiveTransaction(maybeHub) {
      const hub$1 = maybeHub || hub.getCurrentHub();
      const scope = hub$1.getScope();
      return scope.getTransaction();
    }
    exports.TRACEPARENT_REGEXP = utils.TRACEPARENT_REGEXP;
    exports.extractTraceparentData = utils.extractTraceparentData;
    exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
    exports.getActiveTransaction = getActiveTransaction;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/errors.js
var require_errors = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/errors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var utils$1 = require_utils();
    var errorsInstrumented = false;
    function registerErrorInstrumentation() {
      if (errorsInstrumented) {
        return;
      }
      errorsInstrumented = true;
      utils.addInstrumentationHandler("error", errorCallback);
      utils.addInstrumentationHandler("unhandledrejection", errorCallback);
    }
    function errorCallback() {
      const activeTransaction = utils$1.getActiveTransaction();
      if (activeTransaction) {
        const status = "internal_error";
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);
        activeTransaction.setStatus(status);
      }
    }
    errorCallback.tag = "sentry_tracingErrorCallback";
    exports.registerErrorInstrumentation = registerErrorInstrumentation;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/span.js
var require_span = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/span.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var SpanRecorder = class {
      __init() {
        this.spans = [];
      }
      constructor(maxlen = 1e3) {
        SpanRecorder.prototype.__init.call(this);
        this._maxlen = maxlen;
      }
      /**
       * This is just so that we don't run out of memory while recording a lot
       * of spans. At some point we just stop and flush out the start of the
       * trace tree (i.e.the first n spans with the smallest
       * start_timestamp).
       */
      add(span) {
        if (this.spans.length > this._maxlen) {
          span.spanRecorder = void 0;
        } else {
          this.spans.push(span);
        }
      }
    };
    var Span = class {
      /**
       * @inheritDoc
       */
      __init2() {
        this.traceId = utils.uuid4();
      }
      /**
       * @inheritDoc
       */
      __init3() {
        this.spanId = utils.uuid4().substring(16);
      }
      /**
       * @inheritDoc
       */
      /**
       * Internal keeper of the status
       */
      /**
       * @inheritDoc
       */
      /**
       * Timestamp in seconds when the span was created.
       */
      __init4() {
        this.startTimestamp = utils.timestampInSeconds();
      }
      /**
       * Timestamp in seconds when the span ended.
       */
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      __init5() {
        this.tags = {};
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      __init6() {
        this.data = {};
      }
      /**
       * List of spans that were finalized
       */
      /**
       * @inheritDoc
       */
      /**
       * The instrumenter that created this span.
       */
      __init7() {
        this.instrumenter = "sentry";
      }
      /**
       * You should never call the constructor manually, always use `Sentry.startTransaction()`
       * or call `startChild()` on an existing span.
       * @internal
       * @hideconstructor
       * @hidden
       */
      constructor(spanContext) {
        Span.prototype.__init2.call(this);
        Span.prototype.__init3.call(this);
        Span.prototype.__init4.call(this);
        Span.prototype.__init5.call(this);
        Span.prototype.__init6.call(this);
        Span.prototype.__init7.call(this);
        if (!spanContext) {
          return this;
        }
        if (spanContext.traceId) {
          this.traceId = spanContext.traceId;
        }
        if (spanContext.spanId) {
          this.spanId = spanContext.spanId;
        }
        if (spanContext.parentSpanId) {
          this.parentSpanId = spanContext.parentSpanId;
        }
        if ("sampled" in spanContext) {
          this.sampled = spanContext.sampled;
        }
        if (spanContext.op) {
          this.op = spanContext.op;
        }
        if (spanContext.description) {
          this.description = spanContext.description;
        }
        if (spanContext.data) {
          this.data = spanContext.data;
        }
        if (spanContext.tags) {
          this.tags = spanContext.tags;
        }
        if (spanContext.status) {
          this.status = spanContext.status;
        }
        if (spanContext.startTimestamp) {
          this.startTimestamp = spanContext.startTimestamp;
        }
        if (spanContext.endTimestamp) {
          this.endTimestamp = spanContext.endTimestamp;
        }
        if (spanContext.instrumenter) {
          this.instrumenter = spanContext.instrumenter;
        }
      }
      /**
       * @inheritDoc
       */
      startChild(spanContext) {
        const childSpan = new Span({
          ...spanContext,
          parentSpanId: this.spanId,
          sampled: this.sampled,
          traceId: this.traceId
        });
        childSpan.spanRecorder = this.spanRecorder;
        if (childSpan.spanRecorder) {
          childSpan.spanRecorder.add(childSpan);
        }
        childSpan.transaction = this.transaction;
        if ((typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && childSpan.transaction) {
          const opStr = spanContext && spanContext.op || "< unknown op >";
          const nameStr = childSpan.transaction.name || "< unknown name >";
          const idStr = childSpan.transaction.spanId;
          const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;
          childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };
          utils.logger.log(logMessage);
        }
        return childSpan;
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
        this.tags = { ...this.tags, [key]: value };
        return this;
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      setData(key, value) {
        this.data = { ...this.data, [key]: value };
        return this;
      }
      /**
       * @inheritDoc
       */
      setStatus(value) {
        this.status = value;
        return this;
      }
      /**
       * @inheritDoc
       */
      setHttpStatus(httpStatus) {
        this.setTag("http.status_code", String(httpStatus));
        const spanStatus = spanStatusfromHttpCode(httpStatus);
        if (spanStatus !== "unknown_error") {
          this.setStatus(spanStatus);
        }
        return this;
      }
      /**
       * @inheritDoc
       */
      isSuccess() {
        return this.status === "ok";
      }
      /**
       * @inheritDoc
       */
      finish(endTimestamp) {
        if ((typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && // Don't call this for transactions
        this.transaction && this.transaction.spanId !== this.spanId) {
          const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];
          if (logMessage) {
            utils.logger.log(logMessage.replace("Starting", "Finishing"));
          }
        }
        this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils.timestampInSeconds();
      }
      /**
       * @inheritDoc
       */
      toTraceparent() {
        let sampledString = "";
        if (this.sampled !== void 0) {
          sampledString = this.sampled ? "-1" : "-0";
        }
        return `${this.traceId}-${this.spanId}${sampledString}`;
      }
      /**
       * @inheritDoc
       */
      toContext() {
        return utils.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId
        });
      }
      /**
       * @inheritDoc
       */
      updateWithContext(spanContext) {
        this.data = spanContext.data || {};
        this.description = spanContext.description;
        this.endTimestamp = spanContext.endTimestamp;
        this.op = spanContext.op;
        this.parentSpanId = spanContext.parentSpanId;
        this.sampled = spanContext.sampled;
        this.spanId = spanContext.spanId || this.spanId;
        this.startTimestamp = spanContext.startTimestamp || this.startTimestamp;
        this.status = spanContext.status;
        this.tags = spanContext.tags || {};
        this.traceId = spanContext.traceId || this.traceId;
        return this;
      }
      /**
       * @inheritDoc
       */
      getTraceContext() {
        return utils.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          trace_id: this.traceId
        });
      }
      /**
       * @inheritDoc
       */
      toJSON() {
        return utils.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this.endTimestamp,
          trace_id: this.traceId
        });
      }
    };
    function spanStatusfromHttpCode(httpStatus) {
      if (httpStatus < 400 && httpStatus >= 100) {
        return "ok";
      }
      if (httpStatus >= 400 && httpStatus < 500) {
        switch (httpStatus) {
          case 401:
            return "unauthenticated";
          case 403:
            return "permission_denied";
          case 404:
            return "not_found";
          case 409:
            return "already_exists";
          case 413:
            return "failed_precondition";
          case 429:
            return "resource_exhausted";
          default:
            return "invalid_argument";
        }
      }
      if (httpStatus >= 500 && httpStatus < 600) {
        switch (httpStatus) {
          case 501:
            return "unimplemented";
          case 503:
            return "unavailable";
          case 504:
            return "deadline_exceeded";
          default:
            return "internal_error";
        }
      }
      return "unknown_error";
    }
    exports.Span = Span;
    exports.SpanRecorder = SpanRecorder;
    exports.spanStatusfromHttpCode = spanStatusfromHttpCode;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/transaction.js
var require_transaction = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/transaction.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants2 = require_constants();
    var hub = require_hub();
    var span = require_span();
    var Transaction = class extends span.Span {
      /**
       * The reference to the current hub.
       */
      __init() {
        this._measurements = {};
      }
      __init2() {
        this._contexts = {};
      }
      __init3() {
        this._frozenDynamicSamplingContext = void 0;
      }
      /**
       * This constructor should never be called manually. Those instrumenting tracing should use
       * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
       * @internal
       * @hideconstructor
       * @hidden
       */
      constructor(transactionContext, hub$1) {
        super(transactionContext);
        Transaction.prototype.__init.call(this);
        Transaction.prototype.__init2.call(this);
        Transaction.prototype.__init3.call(this);
        this._hub = hub$1 || hub.getCurrentHub();
        this._name = transactionContext.name || "";
        this.metadata = {
          source: "custom",
          ...transactionContext.metadata,
          spanMetadata: {}
        };
        this._trimEnd = transactionContext.trimEnd;
        this.transaction = this;
        const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;
        if (incomingDynamicSamplingContext) {
          this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };
        }
      }
      /** Getter for `name` property */
      get name() {
        return this._name;
      }
      /** Setter for `name` property, which also sets `source` as custom */
      set name(newName) {
        this.setName(newName);
      }
      /**
       * JSDoc
       */
      setName(name, source = "custom") {
        this._name = name;
        this.metadata.source = source;
      }
      /**
       * Attaches SpanRecorder to the span itself
       * @param maxlen maximum number of spans that can be recorded
       */
      initSpanRecorder(maxlen = 1e3) {
        if (!this.spanRecorder) {
          this.spanRecorder = new span.SpanRecorder(maxlen);
        }
        this.spanRecorder.add(this);
      }
      /**
       * @inheritDoc
       */
      setContext(key, context) {
        if (context === null) {
          delete this._contexts[key];
        } else {
          this._contexts[key] = context;
        }
      }
      /**
       * @inheritDoc
       */
      setMeasurement(name, value, unit = "") {
        this._measurements[name] = { value, unit };
      }
      /**
       * @inheritDoc
       */
      setMetadata(newMetadata) {
        this.metadata = { ...this.metadata, ...newMetadata };
      }
      /**
       * @inheritDoc
       */
      finish(endTimestamp) {
        if (this.endTimestamp !== void 0) {
          return void 0;
        }
        if (!this.name) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
          this.name = "<unlabeled transaction>";
        }
        super.finish(endTimestamp);
        const client = this._hub.getClient();
        if (client && client.emit) {
          client.emit("finishTransaction", this);
        }
        if (this.sampled !== true) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
          if (client) {
            client.recordDroppedEvent("sample_rate", "transaction");
          }
          return void 0;
        }
        const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter((s2) => s2 !== this && s2.endTimestamp) : [];
        if (this._trimEnd && finishedSpans.length > 0) {
          this.endTimestamp = finishedSpans.reduce((prev, current) => {
            if (prev.endTimestamp && current.endTimestamp) {
              return prev.endTimestamp > current.endTimestamp ? prev : current;
            }
            return prev;
          }).endTimestamp;
        }
        const metadata = this.metadata;
        const transaction = {
          contexts: {
            ...this._contexts,
            // We don't want to override trace context
            trace: this.getTraceContext()
          },
          spans: finishedSpans,
          start_timestamp: this.startTimestamp,
          tags: this.tags,
          timestamp: this.endTimestamp,
          transaction: this.name,
          type: "transaction",
          sdkProcessingMetadata: {
            ...metadata,
            dynamicSamplingContext: this.getDynamicSamplingContext()
          },
          ...metadata.source && {
            transaction_info: {
              source: metadata.source
            }
          }
        };
        const hasMeasurements = Object.keys(this._measurements).length > 0;
        if (hasMeasurements) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
            "[Measurements] Adding measurements to transaction",
            JSON.stringify(this._measurements, void 0, 2)
          );
          transaction.measurements = this._measurements;
        }
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);
        return this._hub.captureEvent(transaction);
      }
      /**
       * @inheritDoc
       */
      toContext() {
        const spanContext = super.toContext();
        return utils.dropUndefinedKeys({
          ...spanContext,
          name: this.name,
          trimEnd: this._trimEnd
        });
      }
      /**
       * @inheritDoc
       */
      updateWithContext(transactionContext) {
        super.updateWithContext(transactionContext);
        this.name = transactionContext.name || "";
        this._trimEnd = transactionContext.trimEnd;
        return this;
      }
      /**
       * @inheritdoc
       *
       * @experimental
       */
      getDynamicSamplingContext() {
        if (this._frozenDynamicSamplingContext) {
          return this._frozenDynamicSamplingContext;
        }
        const hub$1 = this._hub || hub.getCurrentHub();
        const client = hub$1 && hub$1.getClient();
        if (!client)
          return {};
        const { environment, release } = client.getOptions() || {};
        const { publicKey: public_key } = client.getDsn() || {};
        const maybeSampleRate = this.metadata.sampleRate;
        const sample_rate = maybeSampleRate !== void 0 ? maybeSampleRate.toString() : void 0;
        const { segment: user_segment } = hub$1.getScope().getUser() || {};
        const source = this.metadata.source;
        const transaction = source && source !== "url" ? this.name : void 0;
        const dsc = utils.dropUndefinedKeys({
          environment: environment || constants2.DEFAULT_ENVIRONMENT,
          release,
          transaction,
          user_segment,
          public_key,
          trace_id: this.traceId,
          sample_rate
        });
        client.emit && client.emit("createDsc", dsc);
        return dsc;
      }
      /**
       * Override the current hub with a new one.
       * Used if you want another hub to finish the transaction.
       *
       * @internal
       */
      setHub(hub2) {
        this._hub = hub2;
      }
    };
    exports.Transaction = Transaction;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/idletransaction.js
var require_idletransaction = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/idletransaction.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var span = require_span();
    var transaction = require_transaction();
    var TRACING_DEFAULTS = {
      idleTimeout: 1e3,
      finalTimeout: 3e4,
      heartbeatInterval: 5e3
    };
    var FINISH_REASON_TAG = "finishReason";
    var IDLE_TRANSACTION_FINISH_REASONS = [
      "heartbeatFailed",
      "idleTimeout",
      "documentHidden",
      "finalTimeout",
      "externalFinish",
      "cancelled"
    ];
    var IdleTransactionSpanRecorder = class extends span.SpanRecorder {
      constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {
        super(maxlen);
        this._pushActivity = _pushActivity;
        this._popActivity = _popActivity;
        this.transactionSpanId = transactionSpanId;
      }
      /**
       * @inheritDoc
       */
      add(span2) {
        if (span2.spanId !== this.transactionSpanId) {
          span2.finish = (endTimestamp) => {
            span2.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils.timestampInSeconds();
            this._popActivity(span2.spanId);
          };
          if (span2.endTimestamp === void 0) {
            this._pushActivity(span2.spanId);
          }
        }
        super.add(span2);
      }
    };
    var IdleTransaction = class extends transaction.Transaction {
      // Activities store a list of active spans
      __init() {
        this.activities = {};
      }
      // Track state of activities in previous heartbeat
      // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
      __init2() {
        this._heartbeatCounter = 0;
      }
      // We should not use heartbeat if we finished a transaction
      __init3() {
        this._finished = false;
      }
      // Idle timeout was canceled and we should finish the transaction with the last span end.
      __init4() {
        this._idleTimeoutCanceledPermanently = false;
      }
      __init5() {
        this._beforeFinishCallbacks = [];
      }
      /**
       * Timer that tracks Transaction idleTimeout
       */
      __init6() {
        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];
      }
      constructor(transactionContext, _idleHub, _idleTimeout = TRACING_DEFAULTS.idleTimeout, _finalTimeout = TRACING_DEFAULTS.finalTimeout, _heartbeatInterval = TRACING_DEFAULTS.heartbeatInterval, _onScope = false) {
        super(transactionContext, _idleHub);
        this._idleHub = _idleHub;
        this._idleTimeout = _idleTimeout;
        this._finalTimeout = _finalTimeout;
        this._heartbeatInterval = _heartbeatInterval;
        this._onScope = _onScope;
        IdleTransaction.prototype.__init.call(this);
        IdleTransaction.prototype.__init2.call(this);
        IdleTransaction.prototype.__init3.call(this);
        IdleTransaction.prototype.__init4.call(this);
        IdleTransaction.prototype.__init5.call(this);
        IdleTransaction.prototype.__init6.call(this);
        if (_onScope) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);
          _idleHub.configureScope((scope) => scope.setSpan(this));
        }
        this._restartIdleTimeout();
        setTimeout(() => {
          if (!this._finished) {
            this.setStatus("deadline_exceeded");
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];
            this.finish();
          }
        }, this._finalTimeout);
      }
      /** {@inheritDoc} */
      finish(endTimestamp = utils.timestampInSeconds()) {
        this._finished = true;
        this.activities = {};
        if (this.op === "ui.action.click") {
          this.setTag(FINISH_REASON_TAG, this._finishReason);
        }
        if (this.spanRecorder) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
          for (const callback of this._beforeFinishCallbacks) {
            callback(this, endTimestamp);
          }
          this.spanRecorder.spans = this.spanRecorder.spans.filter((span2) => {
            if (span2.spanId === this.spanId) {
              return true;
            }
            if (!span2.endTimestamp) {
              span2.endTimestamp = endTimestamp;
              span2.setStatus("cancelled");
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span2, void 0, 2));
            }
            const keepSpan = span2.startTimestamp < endTimestamp;
            if (!keepSpan) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
                "[Tracing] discarding Span since it happened after Transaction was finished",
                JSON.stringify(span2, void 0, 2)
              );
            }
            return keepSpan;
          });
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] flushing IdleTransaction");
        } else {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] No active IdleTransaction");
        }
        if (this._onScope) {
          const scope = this._idleHub.getScope();
          if (scope.getTransaction() === this) {
            scope.setSpan(void 0);
          }
        }
        return super.finish(endTimestamp);
      }
      /**
       * Register a callback function that gets excecuted before the transaction finishes.
       * Useful for cleanup or if you want to add any additional spans based on current context.
       *
       * This is exposed because users have no other way of running something before an idle transaction
       * finishes.
       */
      registerBeforeFinishCallback(callback) {
        this._beforeFinishCallbacks.push(callback);
      }
      /**
       * @inheritDoc
       */
      initSpanRecorder(maxlen) {
        if (!this.spanRecorder) {
          const pushActivity = (id) => {
            if (this._finished) {
              return;
            }
            this._pushActivity(id);
          };
          const popActivity = (id) => {
            if (this._finished) {
              return;
            }
            this._popActivity(id);
          };
          this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Starting heartbeat");
          this._pingHeartbeat();
        }
        this.spanRecorder.add(this);
      }
      /**
       * Cancels the existing idle timeout, if there is one.
       * @param restartOnChildSpanChange Default is `true`.
       *                                 If set to false the transaction will end
       *                                 with the last child span.
       */
      cancelIdleTimeout(endTimestamp, {
        restartOnChildSpanChange
      } = {
        restartOnChildSpanChange: true
      }) {
        this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;
        if (this._idleTimeoutID) {
          clearTimeout(this._idleTimeoutID);
          this._idleTimeoutID = void 0;
          if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
            this.finish(endTimestamp);
          }
        }
      }
      /**
       * Temporary method used to externally set the transaction's `finishReason`
       *
       * ** WARNING**
       * This is for the purpose of experimentation only and will be removed in the near future, do not use!
       *
       * @internal
       *
       */
      setFinishReason(reason) {
        this._finishReason = reason;
      }
      /**
       * Restarts idle timeout, if there is no running idle timeout it will start one.
       */
      _restartIdleTimeout(endTimestamp) {
        this.cancelIdleTimeout();
        this._idleTimeoutID = setTimeout(() => {
          if (!this._finished && Object.keys(this.activities).length === 0) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];
            this.finish(endTimestamp);
          }
        }, this._idleTimeout);
      }
      /**
       * Start tracking a specific activity.
       * @param spanId The span id that represents the activity
       */
      _pushActivity(spanId) {
        this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] pushActivity: ${spanId}`);
        this.activities[spanId] = true;
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      /**
       * Remove an activity from usage
       * @param spanId The span id that represents the activity
       */
      _popActivity(spanId) {
        if (this.activities[spanId]) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] popActivity ${spanId}`);
          delete this.activities[spanId];
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
        }
        if (Object.keys(this.activities).length === 0) {
          const endTimestamp = utils.timestampInSeconds();
          if (this._idleTimeoutCanceledPermanently) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
            this.finish(endTimestamp);
          } else {
            this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1e3);
          }
        }
      }
      /**
       * Checks when entries of this.activities are not changing for 3 beats.
       * If this occurs we finish the transaction.
       */
      _beat() {
        if (this._finished) {
          return;
        }
        const heartbeatString = Object.keys(this.activities).join("");
        if (heartbeatString === this._prevHeartbeatString) {
          this._heartbeatCounter++;
        } else {
          this._heartbeatCounter = 1;
        }
        this._prevHeartbeatString = heartbeatString;
        if (this._heartbeatCounter >= 3) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
          this.setStatus("deadline_exceeded");
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];
          this.finish();
        } else {
          this._pingHeartbeat();
        }
      }
      /**
       * Pings the heartbeat
       */
      _pingHeartbeat() {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
        setTimeout(() => {
          this._beat();
        }, this._heartbeatInterval);
      }
    };
    exports.IdleTransaction = IdleTransaction;
    exports.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
    exports.TRACING_DEFAULTS = TRACING_DEFAULTS;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/hubextensions.js
var require_hubextensions = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/hubextensions.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    var hasTracingEnabled = require_hasTracingEnabled();
    var errors = require_errors();
    var idletransaction = require_idletransaction();
    var transaction = require_transaction();
    function traceHeaders() {
      const scope = this.getScope();
      const span = scope.getSpan();
      return span ? {
        "sentry-trace": span.toTraceparent()
      } : {};
    }
    function sample(transaction2, options, samplingContext) {
      if (!hasTracingEnabled.hasTracingEnabled(options)) {
        transaction2.sampled = false;
        return transaction2;
      }
      if (transaction2.sampled !== void 0) {
        transaction2.setMetadata({
          sampleRate: Number(transaction2.sampled)
        });
        return transaction2;
      }
      let sampleRate;
      if (typeof options.tracesSampler === "function") {
        sampleRate = options.tracesSampler(samplingContext);
        transaction2.setMetadata({
          sampleRate: Number(sampleRate)
        });
      } else if (samplingContext.parentSampled !== void 0) {
        sampleRate = samplingContext.parentSampled;
      } else if (typeof options.tracesSampleRate !== "undefined") {
        sampleRate = options.tracesSampleRate;
        transaction2.setMetadata({
          sampleRate: Number(sampleRate)
        });
      } else {
        sampleRate = 1;
        transaction2.setMetadata({
          sampleRate
        });
      }
      if (!isValidSampleRate(sampleRate)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
        transaction2.sampled = false;
        return transaction2;
      }
      if (!sampleRate) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
          `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
        );
        transaction2.sampled = false;
        return transaction2;
      }
      transaction2.sampled = Math.random() < sampleRate;
      if (!transaction2.sampled) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
            sampleRate
          )})`
        );
        return transaction2;
      }
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] starting ${transaction2.op} transaction - ${transaction2.name}`);
      return transaction2;
    }
    function isValidSampleRate(rate) {
      if (utils.isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
          `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
            rate
          )} of type ${JSON.stringify(typeof rate)}.`
        );
        return false;
      }
      if (rate < 0 || rate > 1) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
        return false;
      }
      return true;
    }
    function _startTransaction(transactionContext, customSamplingContext) {
      const client = this.getClient();
      const options = client && client.getOptions() || {};
      const configInstrumenter = options.instrumenter || "sentry";
      const transactionInstrumenter = transactionContext.instrumenter || "sentry";
      if (configInstrumenter !== transactionInstrumenter) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(
          `A transaction was started with instrumenter=\`${transactionInstrumenter}\`, but the SDK is configured with the \`${configInstrumenter}\` instrumenter.
The transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`
        );
        transactionContext.sampled = false;
      }
      let transaction$1 = new transaction.Transaction(transactionContext, this);
      transaction$1 = sample(transaction$1, options, {
        parentSampled: transactionContext.parentSampled,
        transactionContext,
        ...customSamplingContext
      });
      if (transaction$1.sampled) {
        transaction$1.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      if (client && client.emit) {
        client.emit("startTransaction", transaction$1);
      }
      return transaction$1;
    }
    function startIdleTransaction(hub2, transactionContext, idleTimeout, finalTimeout, onScope, customSamplingContext, heartbeatInterval) {
      const client = hub2.getClient();
      const options = client && client.getOptions() || {};
      let transaction2 = new idletransaction.IdleTransaction(transactionContext, hub2, idleTimeout, finalTimeout, heartbeatInterval, onScope);
      transaction2 = sample(transaction2, options, {
        parentSampled: transactionContext.parentSampled,
        transactionContext,
        ...customSamplingContext
      });
      if (transaction2.sampled) {
        transaction2.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      if (client && client.emit) {
        client.emit("startTransaction", transaction2);
      }
      return transaction2;
    }
    function addTracingExtensions() {
      const carrier = hub.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
      errors.registerErrorInstrumentation();
    }
    exports.addTracingExtensions = addTracingExtensions;
    exports.startIdleTransaction = startIdleTransaction;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/spanstatus.js
var require_spanstatus = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/spanstatus.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanStatus = void 0;
    (function(SpanStatus) {
      const Ok = "ok";
      SpanStatus["Ok"] = Ok;
      const DeadlineExceeded = "deadline_exceeded";
      SpanStatus["DeadlineExceeded"] = DeadlineExceeded;
      const Unauthenticated = "unauthenticated";
      SpanStatus["Unauthenticated"] = Unauthenticated;
      const PermissionDenied = "permission_denied";
      SpanStatus["PermissionDenied"] = PermissionDenied;
      const NotFound = "not_found";
      SpanStatus["NotFound"] = NotFound;
      const ResourceExhausted = "resource_exhausted";
      SpanStatus["ResourceExhausted"] = ResourceExhausted;
      const InvalidArgument = "invalid_argument";
      SpanStatus["InvalidArgument"] = InvalidArgument;
      const Unimplemented = "unimplemented";
      SpanStatus["Unimplemented"] = Unimplemented;
      const Unavailable = "unavailable";
      SpanStatus["Unavailable"] = Unavailable;
      const InternalError = "internal_error";
      SpanStatus["InternalError"] = InternalError;
      const UnknownError = "unknown_error";
      SpanStatus["UnknownError"] = UnknownError;
      const Cancelled = "cancelled";
      SpanStatus["Cancelled"] = Cancelled;
      const AlreadyExists = "already_exists";
      SpanStatus["AlreadyExists"] = AlreadyExists;
      const FailedPrecondition = "failed_precondition";
      SpanStatus["FailedPrecondition"] = FailedPrecondition;
      const Aborted = "aborted";
      SpanStatus["Aborted"] = Aborted;
      const OutOfRange = "out_of_range";
      SpanStatus["OutOfRange"] = OutOfRange;
      const DataLoss = "data_loss";
      SpanStatus["DataLoss"] = DataLoss;
    })(exports.SpanStatus || (exports.SpanStatus = {}));
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/trace.js
var require_trace = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/tracing/trace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    function trace(context, callback, onError = () => {
    }) {
      const ctx = { ...context };
      if (ctx.name !== void 0 && ctx.description === void 0) {
        ctx.description = ctx.name;
      }
      const hub$1 = hub.getCurrentHub();
      const scope = hub$1.getScope();
      const parentSpan = scope.getSpan();
      const activeSpan = parentSpan ? parentSpan.startChild(ctx) : hub$1.startTransaction(ctx);
      scope.setSpan(activeSpan);
      function finishAndSetSpan() {
        activeSpan && activeSpan.finish();
        hub$1.getScope().setSpan(parentSpan);
      }
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(activeSpan);
      } catch (e2) {
        activeSpan && activeSpan.setStatus("internal_error");
        onError(e2);
        finishAndSetSpan();
        throw e2;
      }
      if (utils.isThenable(maybePromiseResult)) {
        Promise.resolve(maybePromiseResult).then(
          () => {
            finishAndSetSpan();
          },
          (e2) => {
            activeSpan && activeSpan.setStatus("internal_error");
            onError(e2);
            finishAndSetSpan();
          }
        );
      } else {
        finishAndSetSpan();
      }
      return maybePromiseResult;
    }
    exports.trace = trace;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/exports.js
var require_exports = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/exports.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub = require_hub();
    function captureException2(exception, captureContext) {
      return hub.getCurrentHub().captureException(exception, { captureContext });
    }
    function captureMessage(message, captureContext) {
      const level = typeof captureContext === "string" ? captureContext : void 0;
      const context = typeof captureContext !== "string" ? { captureContext } : void 0;
      return hub.getCurrentHub().captureMessage(message, level, context);
    }
    function captureEvent(event, hint) {
      return hub.getCurrentHub().captureEvent(event, hint);
    }
    function configureScope(callback) {
      hub.getCurrentHub().configureScope(callback);
    }
    function addBreadcrumb(breadcrumb) {
      hub.getCurrentHub().addBreadcrumb(breadcrumb);
    }
    function setContext(name, context) {
      hub.getCurrentHub().setContext(name, context);
    }
    function setExtras(extras) {
      hub.getCurrentHub().setExtras(extras);
    }
    function setExtra(key, extra) {
      hub.getCurrentHub().setExtra(key, extra);
    }
    function setTags(tags) {
      hub.getCurrentHub().setTags(tags);
    }
    function setTag(key, value) {
      hub.getCurrentHub().setTag(key, value);
    }
    function setUser(user) {
      hub.getCurrentHub().setUser(user);
    }
    function withScope(callback) {
      hub.getCurrentHub().withScope(callback);
    }
    function startTransaction(context, customSamplingContext) {
      return hub.getCurrentHub().startTransaction({ ...context }, customSamplingContext);
    }
    exports.addBreadcrumb = addBreadcrumb;
    exports.captureEvent = captureEvent;
    exports.captureException = captureException2;
    exports.captureMessage = captureMessage;
    exports.configureScope = configureScope;
    exports.setContext = setContext;
    exports.setExtra = setExtra;
    exports.setExtras = setExtras;
    exports.setTag = setTag;
    exports.setTags = setTags;
    exports.setUser = setUser;
    exports.startTransaction = startTransaction;
    exports.withScope = withScope;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/sessionflusher.js
var require_sessionflusher = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/sessionflusher.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    var SessionFlusher = class {
      __init() {
        this.flushTimeout = 60;
      }
      __init2() {
        this._pendingAggregates = {};
      }
      __init3() {
        this._isEnabled = true;
      }
      constructor(client, attrs) {
        SessionFlusher.prototype.__init.call(this);
        SessionFlusher.prototype.__init2.call(this);
        SessionFlusher.prototype.__init3.call(this);
        this._client = client;
        this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1e3);
        this._sessionAttrs = attrs;
      }
      /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */
      flush() {
        const sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
          return;
        }
        this._pendingAggregates = {};
        this._client.sendSession(sessionAggregates);
      }
      /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
      getSessionAggregates() {
        const aggregates = Object.keys(this._pendingAggregates).map((key) => {
          return this._pendingAggregates[parseInt(key)];
        });
        const sessionAggregates = {
          attrs: this._sessionAttrs,
          aggregates
        };
        return utils.dropUndefinedKeys(sessionAggregates);
      }
      /** JSDoc */
      close() {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
      }
      /**
       * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
       * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
       * `_incrementSessionStatusCount` along with the start date
       */
      incrementSessionStatusCount() {
        if (!this._isEnabled) {
          return;
        }
        const scope = hub.getCurrentHub().getScope();
        const requestSession = scope.getRequestSession();
        if (requestSession && requestSession.status) {
          this._incrementSessionStatusCount(requestSession.status, /* @__PURE__ */ new Date());
          scope.setRequestSession(void 0);
        }
      }
      /**
       * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
       * the session received
       */
      _incrementSessionStatusCount(status, date) {
        const sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
          aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
          case "errored":
            aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
            return aggregationCounts.errored;
          case "ok":
            aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
            return aggregationCounts.exited;
          default:
            aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
            return aggregationCounts.crashed;
        }
      }
    };
    exports.SessionFlusher = SessionFlusher;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/api.js
var require_api = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/api.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var SENTRY_API_VERSION = "7";
    function getBaseApiEndpoint(dsn) {
      const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
      const port = dsn.port ? `:${dsn.port}` : "";
      return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
    }
    function _getIngestEndpoint(dsn) {
      return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
    }
    function _encodedAuth(dsn, sdkInfo) {
      return utils.urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
        ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
      });
    }
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
      const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
      const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
      return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
    }
    function getReportDialogEndpoint(dsnLike, dialogOptions) {
      const dsn = utils.makeDsn(dsnLike);
      const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;
      let encodedOptions = `dsn=${utils.dsnToString(dsn)}`;
      for (const key in dialogOptions) {
        if (key === "dsn") {
          continue;
        }
        if (key === "user") {
          const user = dialogOptions.user;
          if (!user) {
            continue;
          }
          if (user.name) {
            encodedOptions += `&name=${encodeURIComponent(user.name)}`;
          }
          if (user.email) {
            encodedOptions += `&email=${encodeURIComponent(user.email)}`;
          }
        } else {
          encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key])}`;
        }
      }
      return `${endpoint}?${encodedOptions}`;
    }
    exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getReportDialogEndpoint = getReportDialogEndpoint;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/envelope.js
var require_envelope2 = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/envelope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
      event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
      return event;
    }
    function createSessionEnvelope(session, dsn, metadata, tunnel) {
      const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
      const envelopeHeaders = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && { dsn: utils.dsnToString(dsn) }
      };
      const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session];
      return utils.createEnvelope(envelopeHeaders, [envelopeItem]);
    }
    function createEventEnvelope(event, dsn, metadata, tunnel) {
      const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
      const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
      enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
      const envelopeHeaders = utils.createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
      delete event.sdkProcessingMetadata;
      const eventItem = [{ type: eventType }, event];
      return utils.createEnvelope(envelopeHeaders, [eventItem]);
    }
    exports.createEventEnvelope = createEventEnvelope;
    exports.createSessionEnvelope = createSessionEnvelope;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integration.js
var require_integration = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integration.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    var scope = require_scope();
    var installedIntegrations = [];
    function filterDuplicates(integrations) {
      const integrationsByName = {};
      integrations.forEach((currentInstance) => {
        const { name } = currentInstance;
        const existingInstance = integrationsByName[name];
        if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
          return;
        }
        integrationsByName[name] = currentInstance;
      });
      return Object.keys(integrationsByName).map((k) => integrationsByName[k]);
    }
    function getIntegrationsToSetup(options) {
      const defaultIntegrations = options.defaultIntegrations || [];
      const userIntegrations = options.integrations;
      defaultIntegrations.forEach((integration) => {
        integration.isDefaultInstance = true;
      });
      let integrations;
      if (Array.isArray(userIntegrations)) {
        integrations = [...defaultIntegrations, ...userIntegrations];
      } else if (typeof userIntegrations === "function") {
        integrations = utils.arrayify(userIntegrations(defaultIntegrations));
      } else {
        integrations = defaultIntegrations;
      }
      const finalIntegrations = filterDuplicates(integrations);
      const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
      if (debugIndex !== -1) {
        const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
        finalIntegrations.push(debugInstance);
      }
      return finalIntegrations;
    }
    function setupIntegrations(integrations) {
      const integrationIndex = {};
      integrations.forEach((integration) => {
        if (integration) {
          setupIntegration(integration, integrationIndex);
        }
      });
      return integrationIndex;
    }
    function setupIntegration(integration, integrationIndex) {
      integrationIndex[integration.name] = integration;
      if (installedIntegrations.indexOf(integration.name) === -1) {
        integration.setupOnce(scope.addGlobalEventProcessor, hub.getCurrentHub);
        installedIntegrations.push(integration.name);
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`Integration installed: ${integration.name}`);
      }
    }
    function findIndex(arr, callback) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (callback(arr[i2]) === true) {
          return i2;
        }
      }
      return -1;
    }
    exports.getIntegrationsToSetup = getIntegrationsToSetup;
    exports.installedIntegrations = installedIntegrations;
    exports.setupIntegration = setupIntegration;
    exports.setupIntegrations = setupIntegrations;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/utils/prepareEvent.js
var require_prepareEvent = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/utils/prepareEvent.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants2 = require_constants();
    var scope = require_scope();
    function prepareEvent(options, event, hint, scope$1) {
      const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
      const prepared = {
        ...event,
        event_id: event.event_id || hint.event_id || utils.uuid4(),
        timestamp: event.timestamp || utils.dateTimestampInSeconds()
      };
      const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
      applyClientOptions(prepared, options);
      applyIntegrationsMetadata(prepared, integrations);
      if (event.type === void 0) {
        applyDebugMetadata(prepared, options.stackParser);
      }
      let finalScope = scope$1;
      if (hint.captureContext) {
        finalScope = scope.Scope.clone(finalScope).update(hint.captureContext);
      }
      let result = utils.resolvedSyncPromise(prepared);
      if (finalScope) {
        if (finalScope.getAttachments) {
          const attachments = [...hint.attachments || [], ...finalScope.getAttachments()];
          if (attachments.length) {
            hint.attachments = attachments;
          }
        }
        result = finalScope.applyToEvent(prepared, hint);
      }
      return result.then((evt) => {
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    }
    function applyClientOptions(event, options) {
      const { environment, release, dist, maxValueLength = 250 } = options;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : constants2.DEFAULT_ENVIRONMENT;
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = utils.truncate(event.message, maxValueLength);
      }
      const exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = utils.truncate(exception.value, maxValueLength);
      }
      const request = event.request;
      if (request && request.url) {
        request.url = utils.truncate(request.url, maxValueLength);
      }
    }
    var debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
    function applyDebugMetadata(event, stackParser) {
      const debugIdMap = utils.GLOBAL_OBJ._sentryDebugIds;
      if (!debugIdMap) {
        return;
      }
      let debugIdStackFramesCache;
      const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
      if (cachedDebugIdStackFrameCache) {
        debugIdStackFramesCache = cachedDebugIdStackFrameCache;
      } else {
        debugIdStackFramesCache = /* @__PURE__ */ new Map();
        debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
      }
      const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
        let parsedStack;
        const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
        if (cachedParsedStack) {
          parsedStack = cachedParsedStack;
        } else {
          parsedStack = stackParser(debugIdStackTrace);
          debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
        }
        for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
          const stackFrame = parsedStack[i2];
          if (stackFrame.filename) {
            acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
            break;
          }
        }
        return acc;
      }, {});
      const errorFileNames = /* @__PURE__ */ new Set();
      try {
        event.exception.values.forEach((exception) => {
          exception.stacktrace.frames.forEach((frame) => {
            if (frame.filename) {
              errorFileNames.add(frame.filename);
            }
          });
        });
      } catch (e2) {
      }
      event.debug_meta = event.debug_meta || {};
      event.debug_meta.images = event.debug_meta.images || [];
      const images = event.debug_meta.images;
      errorFileNames.forEach((filename) => {
        if (filenameDebugIdMap[filename]) {
          images.push({
            type: "sourcemap",
            code_file: filename,
            debug_id: filenameDebugIdMap[filename]
          });
        }
      });
    }
    function applyIntegrationsMetadata(event, integrationNames) {
      if (integrationNames.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
      }
    }
    function normalizeEvent(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }
      const normalized = {
        ...event,
        ...event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map((b) => ({
            ...b,
            ...b.data && {
              data: utils.normalize(b.data, depth, maxBreadth)
            }
          }))
        },
        ...event.user && {
          user: utils.normalize(event.user, depth, maxBreadth)
        },
        ...event.contexts && {
          contexts: utils.normalize(event.contexts, depth, maxBreadth)
        },
        ...event.extra && {
          extra: utils.normalize(event.extra, depth, maxBreadth)
        }
      };
      if (event.contexts && event.contexts.trace && normalized.contexts) {
        normalized.contexts.trace = event.contexts.trace;
        if (event.contexts.trace.data) {
          normalized.contexts.trace.data = utils.normalize(event.contexts.trace.data, depth, maxBreadth);
        }
      }
      if (event.spans) {
        normalized.spans = event.spans.map((span) => {
          if (span.data) {
            span.data = utils.normalize(span.data, depth, maxBreadth);
          }
          return span;
        });
      }
      return normalized;
    }
    exports.applyDebugMetadata = applyDebugMetadata;
    exports.prepareEvent = prepareEvent;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/baseclient.js
var require_baseclient = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/baseclient.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var api = require_api();
    var envelope = require_envelope2();
    var integration = require_integration();
    var session = require_session();
    var prepareEvent = require_prepareEvent();
    var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    var BaseClient = class {
      /** Options passed to the SDK. */
      /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
      /** Array of set up integrations. */
      __init() {
        this._integrations = {};
      }
      /** Indicates whether this client's integrations have been set up. */
      __init2() {
        this._integrationsInitialized = false;
      }
      /** Number of calls being processed */
      __init3() {
        this._numProcessing = 0;
      }
      /** Holds flushable  */
      __init4() {
        this._outcomes = {};
      }
      // eslint-disable-next-line @typescript-eslint/ban-types
      __init5() {
        this._hooks = {};
      }
      /**
       * Initializes this client instance.
       *
       * @param options Options for the client.
       */
      constructor(options) {
        BaseClient.prototype.__init.call(this);
        BaseClient.prototype.__init2.call(this);
        BaseClient.prototype.__init3.call(this);
        BaseClient.prototype.__init4.call(this);
        BaseClient.prototype.__init5.call(this);
        this._options = options;
        if (options.dsn) {
          this._dsn = utils.makeDsn(options.dsn);
          const url = api.getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
          this._transport = options.transport({
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...options.transportOptions,
            url
          });
        } else {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("No DSN provided, client will not do anything.");
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      captureException(exception, hint, scope) {
        if (utils.checkOrSetAlreadyCaught(exception)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        let eventId = hint && hint.event_id;
        this._process(
          this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message, level, hint, scope) {
        let eventId = hint && hint.event_id;
        const promisedEvent = utils.isPrimitive(message) ? this.eventFromMessage(String(message), level, hint) : this.eventFromException(message, hint);
        this._process(
          promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, scope) {
        if (hint && hint.originalException && utils.checkOrSetAlreadyCaught(hint.originalException)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        let eventId = hint && hint.event_id;
        this._process(
          this._captureEvent(event, hint, scope).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureSession(session$1) {
        if (!this._isEnabled()) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("SDK not enabled, will not capture session.");
          return;
        }
        if (!(typeof session$1.release === "string")) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Discarded session because of missing or non-string release");
        } else {
          this.sendSession(session$1);
          session.updateSession(session$1, { init: false });
        }
      }
      /**
       * @inheritDoc
       */
      getDsn() {
        return this._dsn;
      }
      /**
       * @inheritDoc
       */
      getOptions() {
        return this._options;
      }
      /**
       * @see SdkMetadata in @sentry/types
       *
       * @return The metadata of the SDK
       */
      getSdkMetadata() {
        return this._options._metadata;
      }
      /**
       * @inheritDoc
       */
      getTransport() {
        return this._transport;
      }
      /**
       * @inheritDoc
       */
      flush(timeout) {
        const transport = this._transport;
        if (transport) {
          return this._isClientDoneProcessing(timeout).then((clientFinished) => {
            return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
          });
        } else {
          return utils.resolvedSyncPromise(true);
        }
      }
      /**
       * @inheritDoc
       */
      close(timeout) {
        return this.flush(timeout).then((result) => {
          this.getOptions().enabled = false;
          return result;
        });
      }
      /**
       * Sets up the integrations
       */
      setupIntegrations() {
        if (this._isEnabled() && !this._integrationsInitialized) {
          this._integrations = integration.setupIntegrations(this._options.integrations);
          this._integrationsInitialized = true;
        }
      }
      /**
       * Gets an installed integration by its `id`.
       *
       * @returns The installed integration or `undefined` if no integration with that `id` was installed.
       */
      getIntegrationById(integrationId) {
        return this._integrations[integrationId];
      }
      /**
       * @inheritDoc
       */
      getIntegration(integration2) {
        try {
          return this._integrations[integration2.id] || null;
        } catch (_oO) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`Cannot retrieve integration ${integration2.id} from the current Client`);
          return null;
        }
      }
      /**
       * @inheritDoc
       */
      addIntegration(integration$1) {
        integration.setupIntegration(integration$1, this._integrations);
      }
      /**
       * @inheritDoc
       */
      sendEvent(event, hint = {}) {
        if (this._dsn) {
          let env = envelope.createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
          for (const attachment of hint.attachments || []) {
            env = utils.addItemToEnvelope(
              env,
              utils.createAttachmentEnvelopeItem(
                attachment,
                this._options.transportOptions && this._options.transportOptions.textEncoder
              )
            );
          }
          const promise = this._sendEnvelope(env);
          if (promise) {
            promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
          }
        }
      }
      /**
       * @inheritDoc
       */
      sendSession(session2) {
        if (this._dsn) {
          const env = envelope.createSessionEnvelope(session2, this._dsn, this._options._metadata, this._options.tunnel);
          void this._sendEnvelope(env);
        }
      }
      /**
       * @inheritDoc
       */
      recordDroppedEvent(reason, category, _event) {
        if (this._options.sendClientReports) {
          const key = `${reason}:${category}`;
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`Adding outcome: "${key}"`);
          this._outcomes[key] = this._outcomes[key] + 1 || 1;
        }
      }
      // Keep on() & emit() signatures in sync with types' client.ts interface
      /** @inheritdoc */
      /** @inheritdoc */
      on(hook, callback) {
        if (!this._hooks[hook]) {
          this._hooks[hook] = [];
        }
        this._hooks[hook].push(callback);
      }
      /** @inheritdoc */
      /** @inheritdoc */
      emit(hook, ...rest) {
        if (this._hooks[hook]) {
          this._hooks[hook].forEach((callback) => callback(...rest));
        }
      }
      /** Updates existing session based on the provided event */
      _updateSessionFromEvent(session$1, event) {
        let crashed = false;
        let errored = false;
        const exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          for (const ex of exceptions) {
            const mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        }
        const sessionNonTerminal = session$1.status === "ok";
        const shouldUpdateAndSend = sessionNonTerminal && session$1.errors === 0 || sessionNonTerminal && crashed;
        if (shouldUpdateAndSend) {
          session.updateSession(session$1, {
            ...crashed && { status: "crashed" },
            errors: session$1.errors || Number(errored || crashed)
          });
          this.captureSession(session$1);
        }
      }
      /**
       * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
       * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
       * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
       * `false` otherwise
       */
      _isClientDoneProcessing(timeout) {
        return new utils.SyncPromise((resolve2) => {
          let ticked = 0;
          const tick = 1;
          const interval = setInterval(() => {
            if (this._numProcessing == 0) {
              clearInterval(interval);
              resolve2(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve2(false);
              }
            }
          }, tick);
        });
      }
      /** Determines whether this SDK is enabled and a valid Dsn is present. */
      _isEnabled() {
        return this.getOptions().enabled !== false && this._dsn !== void 0;
      }
      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A new event with more information.
       */
      _prepareEvent(event, hint, scope) {
        const options = this.getOptions();
        const integrations = Object.keys(this._integrations);
        if (!hint.integrations && integrations.length > 0) {
          hint.integrations = integrations;
        }
        return prepareEvent.prepareEvent(options, event, hint, scope);
      }
      /**
       * Processes the event and logs an error in case of rejection
       * @param event
       * @param hint
       * @param scope
       */
      _captureEvent(event, hint = {}, scope) {
        return this._processEvent(event, hint, scope).then(
          (finalEvent) => {
            return finalEvent.event_id;
          },
          (reason) => {
            if (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) {
              const sentryError = reason;
              if (sentryError.logLevel === "log") {
                utils.logger.log(sentryError.message);
              } else {
                utils.logger.warn(sentryError);
              }
            }
            return void 0;
          }
        );
      }
      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
      _processEvent(event, hint, scope) {
        const options = this.getOptions();
        const { sampleRate } = options;
        if (!this._isEnabled()) {
          return utils.rejectedSyncPromise(new utils.SentryError("SDK not enabled, will not capture event.", "log"));
        }
        const isTransaction = isTransactionEvent(event);
        const isError = isErrorEvent(event);
        const eventType = event.type || "error";
        const beforeSendLabel = `before send for type \`${eventType}\``;
        if (isError && typeof sampleRate === "number" && Math.random() > sampleRate) {
          this.recordDroppedEvent("sample_rate", "error", event);
          return utils.rejectedSyncPromise(
            new utils.SentryError(
              `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
              "log"
            )
          );
        }
        const dataCategory = eventType === "replay_event" ? "replay" : eventType;
        return this._prepareEvent(event, hint, scope).then((prepared) => {
          if (prepared === null) {
            this.recordDroppedEvent("event_processor", dataCategory, event);
            throw new utils.SentryError("An event processor returned `null`, will not send event.", "log");
          }
          const isInternalException = hint.data && hint.data.__sentry__ === true;
          if (isInternalException) {
            return prepared;
          }
          const result = processBeforeSend(options, prepared, hint);
          return _validateBeforeSendResult(result, beforeSendLabel);
        }).then((processedEvent) => {
          if (processedEvent === null) {
            this.recordDroppedEvent("before_send", dataCategory, event);
            throw new utils.SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
          }
          const session2 = scope && scope.getSession();
          if (!isTransaction && session2) {
            this._updateSessionFromEvent(session2, processedEvent);
          }
          const transactionInfo = processedEvent.transaction_info;
          if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
            const source = "custom";
            processedEvent.transaction_info = {
              ...transactionInfo,
              source
            };
          }
          this.sendEvent(processedEvent, hint);
          return processedEvent;
        }).then(null, (reason) => {
          if (reason instanceof utils.SentryError) {
            throw reason;
          }
          this.captureException(reason, {
            data: {
              __sentry__: true
            },
            originalException: reason
          });
          throw new utils.SentryError(
            `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
          );
        });
      }
      /**
       * Occupies the client with processing and event
       */
      _process(promise) {
        this._numProcessing++;
        void promise.then(
          (value) => {
            this._numProcessing--;
            return value;
          },
          (reason) => {
            this._numProcessing--;
            return reason;
          }
        );
      }
      /**
       * @inheritdoc
       */
      _sendEnvelope(envelope2) {
        if (this._transport && this._dsn) {
          this.emit("beforeEnvelope", envelope2);
          return this._transport.send(envelope2).then(null, (reason) => {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Error while sending event:", reason);
          });
        } else {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Transport disabled");
        }
      }
      /**
       * Clears outcomes on this client and returns them.
       */
      _clearOutcomes() {
        const outcomes = this._outcomes;
        this._outcomes = {};
        return Object.keys(outcomes).map((key) => {
          const [reason, category] = key.split(":");
          return {
            reason,
            category,
            quantity: outcomes[key]
          };
        });
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    };
    function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
      const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
      if (utils.isThenable(beforeSendResult)) {
        return beforeSendResult.then(
          (event) => {
            if (!utils.isPlainObject(event) && event !== null) {
              throw new utils.SentryError(invalidValueError);
            }
            return event;
          },
          (e2) => {
            throw new utils.SentryError(`${beforeSendLabel} rejected with ${e2}`);
          }
        );
      } else if (!utils.isPlainObject(beforeSendResult) && beforeSendResult !== null) {
        throw new utils.SentryError(invalidValueError);
      }
      return beforeSendResult;
    }
    function processBeforeSend(options, event, hint) {
      const { beforeSend, beforeSendTransaction } = options;
      if (isErrorEvent(event) && beforeSend) {
        return beforeSend(event, hint);
      }
      if (isTransactionEvent(event) && beforeSendTransaction) {
        return beforeSendTransaction(event, hint);
      }
      return event;
    }
    function isErrorEvent(event) {
      return event.type === void 0;
    }
    function isTransactionEvent(event) {
      return event.type === "transaction";
    }
    exports.BaseClient = BaseClient;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/sdk.js
var require_sdk = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/sdk.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    function initAndBind(clientClass, options) {
      if (options.debug === true) {
        if (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) {
          utils.logger.enable();
        } else {
          console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
        }
      }
      const hub$1 = hub.getCurrentHub();
      const scope = hub$1.getScope();
      scope.update(options.initialScope);
      const client = new clientClass(options);
      hub$1.bindClient(client);
    }
    exports.initAndBind = initAndBind;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/base.js
var require_base = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/base.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
    function createTransport(options, makeRequest, buffer = utils.makePromiseBuffer(
      options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
    )) {
      let rateLimits = {};
      const flush = (timeout) => buffer.drain(timeout);
      function send(envelope) {
        const filteredEnvelopeItems = [];
        utils.forEachEnvelopeItem(envelope, (item, type) => {
          const envelopeItemDataCategory = utils.envelopeItemTypeToDataCategory(type);
          if (utils.isRateLimited(rateLimits, envelopeItemDataCategory)) {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent("ratelimit_backoff", envelopeItemDataCategory, event);
          } else {
            filteredEnvelopeItems.push(item);
          }
        });
        if (filteredEnvelopeItems.length === 0) {
          return utils.resolvedSyncPromise();
        }
        const filteredEnvelope = utils.createEnvelope(envelope[0], filteredEnvelopeItems);
        const recordEnvelopeLoss = (reason) => {
          utils.forEachEnvelopeItem(filteredEnvelope, (item, type) => {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent(reason, utils.envelopeItemTypeToDataCategory(type), event);
          });
        };
        const requestTask = () => makeRequest({ body: utils.serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
          (response) => {
            if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
            }
            rateLimits = utils.updateRateLimits(rateLimits, response);
            return response;
          },
          (error) => {
            recordEnvelopeLoss("network_error");
            throw error;
          }
        );
        return buffer.add(requestTask).then(
          (result) => result,
          (error) => {
            if (error instanceof utils.SentryError) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Skipped sending event because buffer is full.");
              recordEnvelopeLoss("queue_overflow");
              return utils.resolvedSyncPromise();
            } else {
              throw error;
            }
          }
        );
      }
      send.__sentry__baseTransport__ = true;
      return {
        send,
        flush
      };
    }
    function getEventForEnvelopeItem(item, type) {
      if (type !== "event" && type !== "transaction") {
        return void 0;
      }
      return Array.isArray(item) ? item[1] : void 0;
    }
    exports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;
    exports.createTransport = createTransport;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/offline.js
var require_offline = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/offline.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var MIN_DELAY = 100;
    var START_DELAY = 5e3;
    var MAX_DELAY = 36e5;
    function log2(msg, error) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.info(`[Offline]: ${msg}`, error);
    }
    function makeOfflineTransport(createTransport) {
      return (options) => {
        const transport = createTransport(options);
        const store = options.createStore ? options.createStore(options) : void 0;
        let retryDelay = START_DELAY;
        let flushTimer;
        function shouldQueue(env, error, retryDelay2) {
          if (utils.envelopeContainsItemType(env, ["replay_event", "replay_recording", "client_report"])) {
            return false;
          }
          if (options.shouldStore) {
            return options.shouldStore(env, error, retryDelay2);
          }
          return true;
        }
        function flushIn(delay) {
          if (!store) {
            return;
          }
          if (flushTimer) {
            clearTimeout(flushTimer);
          }
          flushTimer = setTimeout(async () => {
            flushTimer = void 0;
            const found = await store.pop();
            if (found) {
              log2("Attempting to send previously queued event");
              void send(found).catch((e2) => {
                log2("Failed to retry sending", e2);
              });
            }
          }, delay);
          if (typeof flushTimer !== "number" && flushTimer.unref) {
            flushTimer.unref();
          }
        }
        function flushWithBackOff() {
          if (flushTimer) {
            return;
          }
          flushIn(retryDelay);
          retryDelay = Math.min(retryDelay * 2, MAX_DELAY);
        }
        async function send(envelope) {
          try {
            const result = await transport.send(envelope);
            let delay = MIN_DELAY;
            if (result) {
              if (result.headers && result.headers["retry-after"]) {
                delay = utils.parseRetryAfterHeader(result.headers["retry-after"]);
              } else if ((result.statusCode || 0) >= 400) {
                return result;
              }
            }
            flushIn(delay);
            retryDelay = START_DELAY;
            return result;
          } catch (e2) {
            if (store && await shouldQueue(envelope, e2, retryDelay)) {
              await store.insert(envelope);
              flushWithBackOff();
              log2("Error sending. Event queued", e2);
              return {};
            } else {
              throw e2;
            }
          }
        }
        if (options.flushAtStartup) {
          flushWithBackOff();
        }
        return {
          send,
          flush: (t2) => transport.flush(t2)
        };
      };
    }
    exports.MIN_DELAY = MIN_DELAY;
    exports.START_DELAY = START_DELAY;
    exports.makeOfflineTransport = makeOfflineTransport;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/multiplexed.js
var require_multiplexed = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/transports/multiplexed.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var api = require_api();
    function eventFromEnvelope(env, types3) {
      let event;
      utils.forEachEnvelopeItem(env, (item, type) => {
        if (types3.includes(type)) {
          event = Array.isArray(item) ? item[1] : void 0;
        }
        return !!event;
      });
      return event;
    }
    function makeMultiplexedTransport(createTransport, matcher) {
      return (options) => {
        const fallbackTransport = createTransport(options);
        const otherTransports = {};
        function getTransport(dsn) {
          if (!otherTransports[dsn]) {
            const url = api.getEnvelopeEndpointWithUrlEncodedAuth(utils.dsnFromString(dsn));
            otherTransports[dsn] = createTransport({ ...options, url });
          }
          return otherTransports[dsn];
        }
        async function send(envelope) {
          function getEvent(types3) {
            const eventTypes = types3 && types3.length ? types3 : ["event"];
            return eventFromEnvelope(envelope, eventTypes);
          }
          const transports = matcher({ envelope, getEvent }).map((dsn) => getTransport(dsn));
          if (transports.length === 0) {
            transports.push(fallbackTransport);
          }
          const results = await Promise.all(transports.map((transport) => transport.send(envelope)));
          return results[0];
        }
        async function flush(timeout) {
          const allTransports = [...Object.keys(otherTransports).map((dsn) => otherTransports[dsn]), fallbackTransport];
          const results = await Promise.all(allTransports.map((transport) => transport.flush(timeout)));
          return results.every((r2) => r2);
        }
        return {
          send,
          flush
        };
      };
    }
    exports.makeMultiplexedTransport = makeMultiplexedTransport;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/version.js
var require_version = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/version.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SDK_VERSION = "7.51.2";
    exports.SDK_VERSION = SDK_VERSION;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/functiontostring.js
var require_functiontostring = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/functiontostring.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var originalFunctionToString;
    var FunctionToString = class {
      constructor() {
        FunctionToString.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "FunctionToString";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = FunctionToString.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
          Function.prototype.toString = function(...args) {
            const context = utils.getOriginalFunction(this) || this;
            return originalFunctionToString.apply(context, args);
          };
        } catch (e2) {
        }
      }
    };
    FunctionToString.__initStatic();
    exports.FunctionToString = FunctionToString;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/inboundfilters.js
var require_inboundfilters = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/inboundfilters.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    var InboundFilters = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "InboundFilters";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = InboundFilters.id;
      }
      constructor(_options = {}) {
        this._options = _options;
        InboundFilters.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor, getCurrentHub) {
        const eventProcess = (event) => {
          const hub = getCurrentHub();
          if (hub) {
            const self2 = hub.getIntegration(InboundFilters);
            if (self2) {
              const client = hub.getClient();
              const clientOptions = client ? client.getOptions() : {};
              const options = _mergeOptions(self2._options, clientOptions);
              return _shouldDropEvent(event, options) ? null : event;
            }
          }
          return event;
        };
        eventProcess.id = this.name;
        addGlobalEventProcessor(eventProcess);
      }
    };
    InboundFilters.__initStatic();
    function _mergeOptions(internalOptions = {}, clientOptions = {}) {
      return {
        allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
        denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
        ignoreErrors: [
          ...internalOptions.ignoreErrors || [],
          ...clientOptions.ignoreErrors || [],
          ...DEFAULT_IGNORE_ERRORS
        ],
        ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []],
        ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
      };
    }
    function _shouldDropEvent(event, options) {
      if (options.ignoreInternal && _isSentryError(event)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${utils.getEventDescription(event)}`);
        return true;
      }
      if (_isIgnoredError(event, options.ignoreErrors)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
          `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${utils.getEventDescription(event)}`
        );
        return true;
      }
      if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
          `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${utils.getEventDescription(event)}`
        );
        return true;
      }
      if (_isDeniedUrl(event, options.denyUrls)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
          `Event dropped due to being matched by \`denyUrls\` option.
Event: ${utils.getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      if (!_isAllowedUrl(event, options.allowUrls)) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
          `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${utils.getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      return false;
    }
    function _isIgnoredError(event, ignoreErrors) {
      if (event.type || !ignoreErrors || !ignoreErrors.length) {
        return false;
      }
      return _getPossibleEventMessages(event).some((message) => utils.stringMatchesSomePattern(message, ignoreErrors));
    }
    function _isIgnoredTransaction(event, ignoreTransactions) {
      if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
        return false;
      }
      const name = event.transaction;
      return name ? utils.stringMatchesSomePattern(name, ignoreTransactions) : false;
    }
    function _isDeniedUrl(event, denyUrls) {
      if (!denyUrls || !denyUrls.length) {
        return false;
      }
      const url = _getEventFilterUrl(event);
      return !url ? false : utils.stringMatchesSomePattern(url, denyUrls);
    }
    function _isAllowedUrl(event, allowUrls) {
      if (!allowUrls || !allowUrls.length) {
        return true;
      }
      const url = _getEventFilterUrl(event);
      return !url ? true : utils.stringMatchesSomePattern(url, allowUrls);
    }
    function _getPossibleEventMessages(event) {
      if (event.message) {
        return [event.message];
      }
      if (event.exception) {
        try {
          const { type = "", value = "" } = event.exception.values && event.exception.values[0] || {};
          return [`${value}`, `${type}: ${value}`];
        } catch (oO) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(`Cannot extract message for event ${utils.getEventDescription(event)}`);
          return [];
        }
      }
      return [];
    }
    function _isSentryError(event) {
      try {
        return event.exception.values[0].type === "SentryError";
      } catch (e2) {
      }
      return false;
    }
    function _getLastValidUrl(frames = []) {
      for (let i2 = frames.length - 1; i2 >= 0; i2--) {
        const frame = frames[i2];
        if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
          return frame.filename || null;
        }
      }
      return null;
    }
    function _getEventFilterUrl(event) {
      try {
        let frames;
        try {
          frames = event.exception.values[0].stacktrace.frames;
        } catch (e2) {
        }
        return frames ? _getLastValidUrl(frames) : null;
      } catch (oO) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(`Cannot extract url for event ${utils.getEventDescription(event)}`);
        return null;
      }
    }
    exports.InboundFilters = InboundFilters;
    exports._mergeOptions = _mergeOptions;
    exports._shouldDropEvent = _shouldDropEvent;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/index.js
var require_integrations = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/integrations/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var functiontostring = require_functiontostring();
    var inboundfilters = require_inboundfilters();
    exports.FunctionToString = functiontostring.FunctionToString;
    exports.InboundFilters = inboundfilters.InboundFilters;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/index.js
var require_cjs2 = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/core/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hubextensions = require_hubextensions();
    var idletransaction = require_idletransaction();
    var span = require_span();
    var transaction = require_transaction();
    var utils$1 = require_utils();
    var spanstatus = require_spanstatus();
    var trace = require_trace();
    var exports$1 = require_exports();
    var hub = require_hub();
    var session = require_session();
    var sessionflusher = require_sessionflusher();
    var scope = require_scope();
    var api = require_api();
    var baseclient = require_baseclient();
    var sdk = require_sdk();
    var base = require_base();
    var offline = require_offline();
    var multiplexed = require_multiplexed();
    var version2 = require_version();
    var integration = require_integration();
    var index = require_integrations();
    var prepareEvent = require_prepareEvent();
    var hasTracingEnabled = require_hasTracingEnabled();
    var constants2 = require_constants();
    var functiontostring = require_functiontostring();
    var inboundfilters = require_inboundfilters();
    var utils = require_cjs();
    exports.addTracingExtensions = hubextensions.addTracingExtensions;
    exports.startIdleTransaction = hubextensions.startIdleTransaction;
    exports.IdleTransaction = idletransaction.IdleTransaction;
    exports.TRACING_DEFAULTS = idletransaction.TRACING_DEFAULTS;
    exports.Span = span.Span;
    exports.spanStatusfromHttpCode = span.spanStatusfromHttpCode;
    exports.Transaction = transaction.Transaction;
    exports.getActiveTransaction = utils$1.getActiveTransaction;
    Object.defineProperty(exports, "SpanStatus", {
      enumerable: true,
      get: () => spanstatus.SpanStatus
    });
    exports.trace = trace.trace;
    exports.addBreadcrumb = exports$1.addBreadcrumb;
    exports.captureEvent = exports$1.captureEvent;
    exports.captureException = exports$1.captureException;
    exports.captureMessage = exports$1.captureMessage;
    exports.configureScope = exports$1.configureScope;
    exports.setContext = exports$1.setContext;
    exports.setExtra = exports$1.setExtra;
    exports.setExtras = exports$1.setExtras;
    exports.setTag = exports$1.setTag;
    exports.setTags = exports$1.setTags;
    exports.setUser = exports$1.setUser;
    exports.startTransaction = exports$1.startTransaction;
    exports.withScope = exports$1.withScope;
    exports.Hub = hub.Hub;
    exports.ensureHubOnCarrier = hub.ensureHubOnCarrier;
    exports.getCurrentHub = hub.getCurrentHub;
    exports.getHubFromCarrier = hub.getHubFromCarrier;
    exports.getMainCarrier = hub.getMainCarrier;
    exports.makeMain = hub.makeMain;
    exports.runWithAsyncContext = hub.runWithAsyncContext;
    exports.setAsyncContextStrategy = hub.setAsyncContextStrategy;
    exports.setHubOnCarrier = hub.setHubOnCarrier;
    exports.closeSession = session.closeSession;
    exports.makeSession = session.makeSession;
    exports.updateSession = session.updateSession;
    exports.SessionFlusher = sessionflusher.SessionFlusher;
    exports.Scope = scope.Scope;
    exports.addGlobalEventProcessor = scope.addGlobalEventProcessor;
    exports.getEnvelopeEndpointWithUrlEncodedAuth = api.getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getReportDialogEndpoint = api.getReportDialogEndpoint;
    exports.BaseClient = baseclient.BaseClient;
    exports.initAndBind = sdk.initAndBind;
    exports.createTransport = base.createTransport;
    exports.makeOfflineTransport = offline.makeOfflineTransport;
    exports.makeMultiplexedTransport = multiplexed.makeMultiplexedTransport;
    exports.SDK_VERSION = version2.SDK_VERSION;
    exports.getIntegrationsToSetup = integration.getIntegrationsToSetup;
    exports.Integrations = index;
    exports.prepareEvent = prepareEvent.prepareEvent;
    exports.hasTracingEnabled = hasTracingEnabled.hasTracingEnabled;
    exports.DEFAULT_ENVIRONMENT = constants2.DEFAULT_ENVIRONMENT;
    exports.FunctionToString = functiontostring.FunctionToString;
    exports.InboundFilters = inboundfilters.InboundFilters;
    exports.extractTraceparentData = utils.extractTraceparentData;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_nullishCoalesce.js
var require_nullishCoalesce = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_nullishCoalesce.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _nullishCoalesce(lhs, rhsFn) {
      return lhs != null ? lhs : rhsFn();
    }
    exports._nullishCoalesce = _nullishCoalesce;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncNullishCoalesce.js
var require_asyncNullishCoalesce = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncNullishCoalesce.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _nullishCoalesce = require_nullishCoalesce();
    async function _asyncNullishCoalesce(lhs, rhsFn) {
      return _nullishCoalesce._nullishCoalesce(lhs, rhsFn);
    }
    exports._asyncNullishCoalesce = _asyncNullishCoalesce;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChain.js
var require_asyncOptionalChain = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    async function _asyncOptionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i2 = 1;
      while (i2 < ops.length) {
        const op = ops[i2];
        const fn = ops[i2 + 1];
        i2 += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    exports._asyncOptionalChain = _asyncOptionalChain;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChainDelete.js
var require_asyncOptionalChainDelete = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChainDelete.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _asyncOptionalChain = require_asyncOptionalChain();
    async function _asyncOptionalChainDelete(ops) {
      const result = await _asyncOptionalChain._asyncOptionalChain(ops);
      return result == null ? true : result;
    }
    exports._asyncOptionalChainDelete = _asyncOptionalChainDelete;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_createNamedExportFrom.js
var require_createNamedExportFrom = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_createNamedExportFrom.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _createNamedExportFrom(obj, localName, importedName) {
      exports[localName] = obj[importedName];
    }
    exports._createNamedExportFrom = _createNamedExportFrom;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_createStarExport.js
var require_createStarExport = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_createStarExport.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _createStarExport(obj) {
      Object.keys(obj).filter((key) => key !== "default" && key !== "__esModule" && !(key in exports)).forEach((key) => exports[key] = obj[key]);
    }
    exports._createStarExport = _createStarExport;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopDefault.js
var require_interopDefault = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopDefault.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault$1(requireResult) {
      return requireResult.__esModule ? requireResult.default : requireResult;
    }
    exports._interopDefault = _interopDefault$1;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopNamespace.js
var require_interopNamespace = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopNamespace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopNamespace$1(requireResult) {
      return requireResult.__esModule ? requireResult : { ...requireResult, default: requireResult };
    }
    exports._interopNamespace = _interopNamespace$1;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopNamespaceDefaultOnly.js
var require_interopNamespaceDefaultOnly = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopNamespaceDefaultOnly.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopNamespaceDefaultOnly$1(requireResult) {
      return {
        __proto__: null,
        default: requireResult
      };
    }
    exports._interopNamespaceDefaultOnly = _interopNamespaceDefaultOnly$1;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopRequireDefault.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(requireResult) {
      return requireResult.__esModule ? requireResult : { default: requireResult };
    }
    exports._interopRequireDefault = _interopRequireDefault;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopRequireWildcard.js
var require_interopRequireWildcard = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_interopRequireWildcard.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireWildcard(requireResult) {
      return requireResult.__esModule ? requireResult : { ...requireResult, default: requireResult };
    }
    exports._interopRequireWildcard = _interopRequireWildcard;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChain.js
var require_optionalChain = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i2 = 1;
      while (i2 < ops.length) {
        const op = ops[i2];
        const fn = ops[i2 + 1];
        i2 += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    exports._optionalChain = _optionalChain;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChainDelete.js
var require_optionalChainDelete = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChainDelete.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _optionalChain = require_optionalChain();
    function _optionalChainDelete(ops) {
      const result = _optionalChain._optionalChain(ops);
      return result == null ? true : result;
    }
    exports._optionalChainDelete = _optionalChainDelete;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/index.js
var require_buildPolyfills = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry/utils/cjs/buildPolyfills/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _asyncNullishCoalesce = require_asyncNullishCoalesce();
    var _asyncOptionalChain = require_asyncOptionalChain();
    var _asyncOptionalChainDelete = require_asyncOptionalChainDelete();
    var _createNamedExportFrom = require_createNamedExportFrom();
    var _createStarExport = require_createStarExport();
    var _interopDefault$1 = require_interopDefault();
    var _interopNamespace$1 = require_interopNamespace();
    var _interopNamespaceDefaultOnly$1 = require_interopNamespaceDefaultOnly();
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _nullishCoalesce = require_nullishCoalesce();
    var _optionalChain = require_optionalChain();
    var _optionalChainDelete = require_optionalChainDelete();
    exports._asyncNullishCoalesce = _asyncNullishCoalesce._asyncNullishCoalesce;
    exports._asyncOptionalChain = _asyncOptionalChain._asyncOptionalChain;
    exports._asyncOptionalChainDelete = _asyncOptionalChainDelete._asyncOptionalChainDelete;
    exports._createNamedExportFrom = _createNamedExportFrom._createNamedExportFrom;
    exports._createStarExport = _createStarExport._createStarExport;
    exports._interopDefault = _interopDefault$1._interopDefault;
    exports._interopNamespace = _interopNamespace$1._interopNamespace;
    exports._interopNamespaceDefaultOnly = _interopNamespaceDefaultOnly$1._interopNamespaceDefaultOnly;
    exports._interopRequireDefault = _interopRequireDefault._interopRequireDefault;
    exports._interopRequireWildcard = _interopRequireWildcard._interopRequireWildcard;
    exports._nullishCoalesce = _nullishCoalesce._nullishCoalesce;
    exports._optionalChain = _optionalChain._optionalChain;
    exports._optionalChainDelete = _optionalChainDelete._optionalChainDelete;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/utils/node-utils.js
var require_node_utils = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/utils/node-utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    function shouldDisableAutoInstrumentation(getCurrentHub) {
      const clientOptions = _optionalChain([getCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
      const instrumenter = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.instrumenter]) || "sentry";
      return instrumenter !== "sentry";
    }
    exports.shouldDisableAutoInstrumentation = shouldDisableAutoInstrumentation;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/express.js
var require_express = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/express.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var Express = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Express";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Express.id;
      }
      /**
       * Express App instance
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        Express.prototype.__init.call(this);
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (!this._router) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("ExpressIntegration is missing an Express instance");
          return;
        }
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Express Integration is skipped because of instrumenter configuration.");
          return;
        }
        instrumentMiddlewares(this._router, this._methods);
        instrumentRouter(this._router);
      }
    };
    Express.__initStatic();
    function wrap(fn, method) {
      const arity = fn.length;
      switch (arity) {
        case 2: {
          return function(req, res) {
            const transaction = res.__sentry_transaction;
            if (transaction) {
              const span = transaction.startChild({
                description: fn.name,
                op: `middleware.express.${method}`
              });
              res.once("finish", () => {
                span.finish();
              });
            }
            return fn.call(this, req, res);
          };
        }
        case 3: {
          return function(req, res, next) {
            const transaction = res.__sentry_transaction;
            const span = _optionalChain([transaction, "optionalAccess", (_2) => _2.startChild, "call", (_3) => _3({
              description: fn.name,
              op: `middleware.express.${method}`
            })]);
            fn.call(this, req, res, function(...args) {
              _optionalChain([span, "optionalAccess", (_4) => _4.finish, "call", (_5) => _5()]);
              next.call(this, ...args);
            });
          };
        }
        case 4: {
          return function(err, req, res, next) {
            const transaction = res.__sentry_transaction;
            const span = _optionalChain([transaction, "optionalAccess", (_6) => _6.startChild, "call", (_7) => _7({
              description: fn.name,
              op: `middleware.express.${method}`
            })]);
            fn.call(this, err, req, res, function(...args) {
              _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
              next.call(this, ...args);
            });
          };
        }
        default: {
          throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);
        }
      }
    }
    function wrapMiddlewareArgs(args, method) {
      return args.map((arg) => {
        if (typeof arg === "function") {
          return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
          return arg.map((a) => {
            if (typeof a === "function") {
              return wrap(a, method);
            }
            return a;
          });
        }
        return arg;
      });
    }
    function patchMiddleware(router, method) {
      const originalCallback = router[method];
      router[method] = function(...args) {
        return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));
      };
      return router;
    }
    function instrumentMiddlewares(router, methods = []) {
      methods.forEach((method) => patchMiddleware(router, method));
    }
    function instrumentRouter(appOrRouter) {
      const isApp = "settings" in appOrRouter;
      if (isApp && appOrRouter._router === void 0 && appOrRouter.lazyrouter) {
        appOrRouter.lazyrouter();
      }
      const router = isApp ? appOrRouter._router : appOrRouter;
      if (!router) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.debug("Cannot instrument router for URL Parameterization (did not find a valid router).");
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.debug("Routing instrumentation is currently only supported in Express 4.");
        return;
      }
      const routerProto = Object.getPrototypeOf(router);
      const originalProcessParams = routerProto.process_params;
      routerProto.process_params = function process_params(layer, called, req, res, done) {
        if (!req._reconstructedRoute) {
          req._reconstructedRoute = "";
        }
        const { layerRoutePath, isRegex, isArray, numExtraSegments } = getLayerRoutePathInfo(layer);
        if (layerRoutePath || isRegex || isArray) {
          req._hasParameters = true;
        }
        const partialRoute = layerRoutePath || layer.path || "";
        const finalPartialRoute = partialRoute.split("/").filter((segment) => segment.length > 0 && (isRegex || isArray || !segment.includes("*"))).join("/");
        if (finalPartialRoute && finalPartialRoute.length > 0) {
          req._reconstructedRoute += `/${finalPartialRoute}${isRegex ? "/" : ""}`;
        }
        const urlLength = utils.getNumberOfUrlSegments(req.originalUrl || "") + numExtraSegments;
        const routeLength = utils.getNumberOfUrlSegments(req._reconstructedRoute);
        if (urlLength === routeLength) {
          if (!req._hasParameters) {
            if (req._reconstructedRoute !== req.originalUrl) {
              req._reconstructedRoute = req.originalUrl;
            }
          }
          const transaction = res.__sentry_transaction;
          if (transaction && transaction.metadata.source !== "custom") {
            const finalRoute = req._reconstructedRoute || "/";
            transaction.setName(...utils.extractPathForTransaction(req, { path: true, method: true, customRoute: finalRoute }));
          }
        }
        return originalProcessParams.call(this, layer, called, req, res, done);
      };
    }
    function getLayerRoutePathInfo(layer) {
      const lrp = _optionalChain([layer, "access", (_10) => _10.route, "optionalAccess", (_11) => _11.path]);
      const isRegex = utils.isRegExp(lrp);
      const isArray = Array.isArray(lrp);
      if (!lrp) {
        return { isRegex, isArray, numExtraSegments: 0 };
      }
      const numExtraSegments = isArray ? Math.max(getNumberOfArrayUrlSegments(lrp) - utils.getNumberOfUrlSegments(layer.path || ""), 0) : 0;
      const layerRoutePath = getLayerRoutePathString(isArray, lrp);
      return { layerRoutePath, isRegex, isArray, numExtraSegments };
    }
    function getNumberOfArrayUrlSegments(routesArray) {
      return routesArray.reduce((accNumSegments, currentRoute) => {
        return accNumSegments + utils.getNumberOfUrlSegments(currentRoute.toString());
      }, 0);
    }
    function getLayerRoutePathString(isArray, lrp) {
      if (isArray) {
        return lrp.map((r2) => r2.toString()).join(",");
      }
      return lrp && lrp.toString();
    }
    exports.Express = Express;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/postgres.js
var require_postgres = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/postgres.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var Postgres = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Postgres";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Postgres.id;
      }
      constructor(options = {}) {
        Postgres.prototype.__init.call(this);
        this._usePgNative = !!options.usePgNative;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("pg");
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Postgres Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Postgres Integration was unable to require `pg` package.");
          return;
        }
        if (this._usePgNative && !_optionalChain([pkg, "access", (_2) => _2.native, "optionalAccess", (_3) => _3.Client])) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
          return;
        }
        const { Client } = this._usePgNative ? pkg.native : pkg;
        utils.fill(Client.prototype, "query", function(orig) {
          return function(config3, values, callback) {
            const scope = getCurrentHub().getScope();
            const parentSpan = _optionalChain([scope, "optionalAccess", (_4) => _4.getSpan, "call", (_5) => _5()]);
            const span = _optionalChain([parentSpan, "optionalAccess", (_6) => _6.startChild, "call", (_7) => _7({
              description: typeof config3 === "string" ? config3 : config3.text,
              op: "db",
              data: {
                "db.system": "postgresql"
              }
            })]);
            if (typeof callback === "function") {
              return orig.call(this, config3, values, function(err, result) {
                _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
                callback(err, result);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, config3, function(err, result) {
                _optionalChain([span, "optionalAccess", (_10) => _10.finish, "call", (_11) => _11()]);
                values(err, result);
              });
            }
            const rv = typeof values !== "undefined" ? orig.call(this, config3, values) : orig.call(this, config3);
            if (utils.isThenable(rv)) {
              return rv.then((res) => {
                _optionalChain([span, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
                return res;
              });
            }
            _optionalChain([span, "optionalAccess", (_14) => _14.finish, "call", (_15) => _15()]);
            return rv;
          };
        });
      }
    };
    Postgres.__initStatic();
    exports.Postgres = Postgres;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/mysql.js
var require_mysql = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/mysql.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var Mysql = class {
      constructor() {
        Mysql.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Mysql";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Mysql.id;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("mysql/lib/Connection.js");
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Mysql Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Mysql Integration was unable to require `mysql` package.");
          return;
        }
        utils.fill(pkg, "createQuery", function(orig) {
          return function(options, values, callback) {
            const scope = getCurrentHub().getScope();
            const parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
            const span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
              description: typeof options === "string" ? options : options.sql,
              op: "db",
              data: {
                "db.system": "mysql"
              }
            })]);
            if (typeof callback === "function") {
              return orig.call(this, options, values, function(err, result, fields) {
                _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
                callback(err, result, fields);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, options, function(err, result, fields) {
                _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
                values(err, result, fields);
              });
            }
            return orig.call(this, options, values, callback);
          };
        });
      }
    };
    Mysql.__initStatic();
    exports.Mysql = Mysql;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/mongo.js
var require_mongo = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/mongo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var OPERATIONS = [
      "aggregate",
      // aggregate(pipeline, options, callback)
      "bulkWrite",
      // bulkWrite(operations, options, callback)
      "countDocuments",
      // countDocuments(query, options, callback)
      "createIndex",
      // createIndex(fieldOrSpec, options, callback)
      "createIndexes",
      // createIndexes(indexSpecs, options, callback)
      "deleteMany",
      // deleteMany(filter, options, callback)
      "deleteOne",
      // deleteOne(filter, options, callback)
      "distinct",
      // distinct(key, query, options, callback)
      "drop",
      // drop(options, callback)
      "dropIndex",
      // dropIndex(indexName, options, callback)
      "dropIndexes",
      // dropIndexes(options, callback)
      "estimatedDocumentCount",
      // estimatedDocumentCount(options, callback)
      "find",
      // find(query, options, callback)
      "findOne",
      // findOne(query, options, callback)
      "findOneAndDelete",
      // findOneAndDelete(filter, options, callback)
      "findOneAndReplace",
      // findOneAndReplace(filter, replacement, options, callback)
      "findOneAndUpdate",
      // findOneAndUpdate(filter, update, options, callback)
      "indexes",
      // indexes(options, callback)
      "indexExists",
      // indexExists(indexes, options, callback)
      "indexInformation",
      // indexInformation(options, callback)
      "initializeOrderedBulkOp",
      // initializeOrderedBulkOp(options, callback)
      "insertMany",
      // insertMany(docs, options, callback)
      "insertOne",
      // insertOne(doc, options, callback)
      "isCapped",
      // isCapped(options, callback)
      "mapReduce",
      // mapReduce(map, reduce, options, callback)
      "options",
      // options(options, callback)
      "parallelCollectionScan",
      // parallelCollectionScan(options, callback)
      "rename",
      // rename(newName, options, callback)
      "replaceOne",
      // replaceOne(filter, doc, options, callback)
      "stats",
      // stats(options, callback)
      "updateMany",
      // updateMany(filter, update, options, callback)
      "updateOne"
      // updateOne(filter, update, options, callback)
    ];
    var OPERATION_SIGNATURES = {
      // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well
      // see https://github.com/getsentry/sentry-javascript/pull/3102
      bulkWrite: ["operations"],
      countDocuments: ["query"],
      createIndex: ["fieldOrSpec"],
      createIndexes: ["indexSpecs"],
      deleteMany: ["filter"],
      deleteOne: ["filter"],
      distinct: ["key", "query"],
      dropIndex: ["indexName"],
      find: ["query"],
      findOne: ["query"],
      findOneAndDelete: ["filter"],
      findOneAndReplace: ["filter", "replacement"],
      findOneAndUpdate: ["filter", "update"],
      indexExists: ["indexes"],
      insertMany: ["docs"],
      insertOne: ["doc"],
      mapReduce: ["map", "reduce"],
      rename: ["newName"],
      replaceOne: ["filter", "doc"],
      updateMany: ["filter", "update"],
      updateOne: ["filter", "update"]
    };
    function isCursor(maybeCursor) {
      return maybeCursor && typeof maybeCursor === "object" && maybeCursor.once && typeof maybeCursor.once === "function";
    }
    var Mongo = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Mongo";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Mongo.id;
      }
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        Mongo.prototype.__init.call(this);
        this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
        this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
        this._useMongoose = !!options.useMongoose;
      }
      /** @inheritdoc */
      loadDependency() {
        const moduleName = this._useMongoose ? "mongoose" : "mongodb";
        return this._module = this._module || utils.loadModule(moduleName);
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Mongo Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          const moduleName = this._useMongoose ? "mongoose" : "mongodb";
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(`Mongo Integration was unable to require \`${moduleName}\` package.`);
          return;
        }
        this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
      }
      /**
       * Patches original collection methods
       */
      _instrumentOperations(collection, operations, getCurrentHub) {
        operations.forEach((operation) => this._patchOperation(collection, operation, getCurrentHub));
      }
      /**
       * Patches original collection to utilize our tracing functionality
       */
      _patchOperation(collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
          return;
        const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        utils.fill(collection.prototype, operation, function(orig) {
          return function(...args) {
            const lastArg = args[args.length - 1];
            const scope = getCurrentHub().getScope();
            const parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
            if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
              const span2 = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5(getSpanContext(this, operation, args))]);
              const maybePromiseOrCursor = orig.call(this, ...args);
              if (utils.isThenable(maybePromiseOrCursor)) {
                return maybePromiseOrCursor.then((res) => {
                  _optionalChain([span2, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
                  return res;
                });
              } else if (isCursor(maybePromiseOrCursor)) {
                const cursor = maybePromiseOrCursor;
                try {
                  cursor.once("close", () => {
                    _optionalChain([span2, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
                  });
                } catch (e2) {
                  _optionalChain([span2, "optionalAccess", (_10) => _10.finish, "call", (_11) => _11()]);
                }
                return cursor;
              } else {
                _optionalChain([span2, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
                return maybePromiseOrCursor;
              }
            }
            const span = _optionalChain([parentSpan, "optionalAccess", (_14) => _14.startChild, "call", (_15) => _15(getSpanContext(this, operation, args.slice(0, -1)))]);
            return orig.call(this, ...args.slice(0, -1), function(err, result) {
              _optionalChain([span, "optionalAccess", (_16) => _16.finish, "call", (_17) => _17()]);
              lastArg(err, result);
            });
          };
        });
      }
      /**
       * Form a SpanContext based on the user input to a given operation.
       */
      _getSpanContextFromOperationArguments(collection, operation, args) {
        const data = {
          collectionName: collection.collectionName,
          dbName: collection.dbName,
          namespace: collection.namespace,
          "db.system": "mongodb"
        };
        const spanContext = {
          op: "db",
          description: operation,
          data
        };
        const signature = OPERATION_SIGNATURES[operation];
        const shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
        if (!signature || !shouldDescribe) {
          return spanContext;
        }
        try {
          if (operation === "mapReduce") {
            const [map, reduce] = args;
            data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
            data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
          } else {
            for (let i2 = 0; i2 < signature.length; i2++) {
              data[signature[i2]] = JSON.stringify(args[i2]);
            }
          }
        } catch (_oO) {
        }
        return spanContext;
      }
    };
    Mongo.__initStatic();
    exports.Mongo = Mongo;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/prisma.js
var require_prisma = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/prisma.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    function isValidPrismaClient(possibleClient) {
      return possibleClient && !!possibleClient["$use"];
    }
    var Prisma = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Prisma";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Prisma.id;
      }
      /**
       * Prisma ORM Client Instance
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        Prisma.prototype.__init.call(this);
        if (isValidPrismaClient(options.client)) {
          this._client = options.client;
        } else {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
            `Unsupported Prisma client provided to PrismaIntegration. Provided client: ${JSON.stringify(options.client)}`
          );
        }
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (!this._client) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("PrismaIntegration is missing a Prisma Client Instance");
          return;
        }
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Prisma Integration is skipped because of instrumenter configuration.");
          return;
        }
        this._client.$use((params, next) => {
          const action = params.action;
          const model = params.model;
          return core.trace(
            { name: model ? `${model} ${action}` : action, op: "db.sql.prisma", data: { "db.system": "prisma" } },
            () => next(params)
          );
        });
      }
    };
    Prisma.__initStatic();
    exports.Prisma = Prisma;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/graphql.js
var require_graphql = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/graphql.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var GraphQL = class {
      constructor() {
        GraphQL.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "GraphQL";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = GraphQL.id;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("graphql/execution/execute.js");
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("GraphQL Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("GraphQL Integration was unable to require graphql/execution package.");
          return;
        }
        utils.fill(pkg, "execute", function(orig) {
          return function(...args) {
            const scope = getCurrentHub().getScope();
            const parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
            const span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
              description: "execute",
              op: "graphql.execute"
            })]);
            _optionalChain([scope, "optionalAccess", (_6) => _6.setSpan, "call", (_7) => _7(span)]);
            const rv = orig.call(this, ...args);
            if (utils.isThenable(rv)) {
              return rv.then((res) => {
                _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
                _optionalChain([scope, "optionalAccess", (_10) => _10.setSpan, "call", (_11) => _11(parentSpan)]);
                return res;
              });
            }
            _optionalChain([span, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
            _optionalChain([scope, "optionalAccess", (_14) => _14.setSpan, "call", (_15) => _15(parentSpan)]);
            return rv;
          };
        });
      }
    };
    GraphQL.__initStatic();
    exports.GraphQL = GraphQL;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/apollo.js
var require_apollo = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/apollo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeUtils = require_node_utils();
    var Apollo = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Apollo";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Apollo.id;
      }
      /**
       * @inheritDoc
       */
      constructor(options = {
        useNestjs: false
      }) {
        Apollo.prototype.__init.call(this);
        this._useNest = !!options.useNestjs;
      }
      /** @inheritdoc */
      loadDependency() {
        if (this._useNest) {
          this._module = this._module || utils.loadModule("@nestjs/graphql");
        } else {
          this._module = this._module || utils.loadModule("apollo-server-core");
        }
        return this._module;
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("Apollo Integration is skipped because of instrumenter configuration.");
          return;
        }
        if (this._useNest) {
          const pkg = this.loadDependency();
          if (!pkg) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Apollo-NestJS Integration was unable to require @nestjs/graphql package.");
            return;
          }
          utils.fill(
            pkg.GraphQLFactory.prototype,
            "mergeWithSchema",
            function(orig) {
              return function(...args) {
                utils.fill(this.resolversExplorerService, "explore", function(orig2) {
                  return function() {
                    const resolvers = utils.arrayify(orig2.call(this));
                    const instrumentedResolvers = instrumentResolvers(resolvers, getCurrentHub);
                    return instrumentedResolvers;
                  };
                });
                return orig.call(this, ...args);
              };
            }
          );
        } else {
          const pkg = this.loadDependency();
          if (!pkg) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error("Apollo Integration was unable to require apollo-server-core package.");
            return;
          }
          utils.fill(pkg.ApolloServerBase.prototype, "constructSchema", function(orig) {
            return function() {
              if (!this.config.resolvers) {
                if (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) {
                  if (this.config.schema) {
                    utils.logger.warn(
                      "Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead."
                    );
                    utils.logger.warn();
                  } else if (this.config.modules) {
                    utils.logger.warn(
                      "Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property."
                    );
                  }
                  utils.logger.error("Skipping tracing as no resolvers found on the `ApolloServer` instance.");
                }
                return orig.call(this);
              }
              const resolvers = utils.arrayify(this.config.resolvers);
              this.config.resolvers = instrumentResolvers(resolvers, getCurrentHub);
              return orig.call(this);
            };
          });
        }
      }
    };
    Apollo.__initStatic();
    function instrumentResolvers(resolvers, getCurrentHub) {
      return resolvers.map((model) => {
        Object.keys(model).forEach((resolverGroupName) => {
          Object.keys(model[resolverGroupName]).forEach((resolverName) => {
            if (typeof model[resolverGroupName][resolverName] !== "function") {
              return;
            }
            wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);
          });
        });
        return model;
      });
    }
    function wrapResolver(model, resolverGroupName, resolverName, getCurrentHub) {
      utils.fill(model[resolverGroupName], resolverName, function(orig) {
        return function(...args) {
          const scope = getCurrentHub().getScope();
          const parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
          const span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
            description: `${resolverGroupName}.${resolverName}`,
            op: "graphql.resolve"
          })]);
          const rv = orig.call(this, ...args);
          if (utils.isThenable(rv)) {
            return rv.then((res) => {
              _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
              return res;
            });
          }
          _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
          return rv;
        };
      });
    }
    exports.Apollo = Apollo;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/lazy.js
var require_lazy = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/node/integrations/lazy.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var lazyLoadedNodePerformanceMonitoringIntegrations = [
      () => {
        const integration = utils.dynamicRequire(module, "./apollo");
        return new integration.Apollo();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./apollo");
        return new integration.Apollo({ useNestjs: true });
      },
      () => {
        const integration = utils.dynamicRequire(module, "./graphql");
        return new integration.GraphQL();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mongo");
        return new integration.Mongo();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mongo");
        return new integration.Mongo({ mongoose: true });
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mysql");
        return new integration.Mysql();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./postgres");
        return new integration.Postgres();
      }
    ];
    exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazyLoadedNodePerformanceMonitoringIntegrations;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/types.js
var require_types = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/types.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var WINDOW = utils.GLOBAL_OBJ;
    exports.WINDOW = WINDOW;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/backgroundtab.js
var require_backgroundtab = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/backgroundtab.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var types3 = require_types();
    function registerBackgroundTabDetection() {
      if (types3.WINDOW && types3.WINDOW.document) {
        types3.WINDOW.document.addEventListener("visibilitychange", () => {
          const activeTransaction = core.getActiveTransaction();
          if (types3.WINDOW.document.hidden && activeTransaction) {
            const statusType = "cancelled";
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
              `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`
            );
            if (!activeTransaction.status) {
              activeTransaction.setStatus(statusType);
            }
            activeTransaction.setTag("visibilitychange", "document.hidden");
            activeTransaction.finish();
          }
        });
      } else {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
      }
    }
    exports.registerBackgroundTabDetection = registerBackgroundTabDetection;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/bindReporter.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = (callback, metric, reportAllChanges) => {
      let prevValue;
      let delta;
      return (forceReport) => {
        if (metric.value >= 0) {
          if (forceReport || reportAllChanges) {
            delta = metric.value - (prevValue || 0);
            if (delta || prevValue === void 0) {
              prevValue = metric.value;
              metric.delta = delta;
              callback(metric);
            }
          }
        }
      };
    };
    exports.bindReporter = bindReporter;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/generateUniqueID.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var generateUniqueID = () => {
      return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
    };
    exports.generateUniqueID = generateUniqueID;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getNavigationEntry.js
var require_getNavigationEntry = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getNavigationEntry.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types3 = require_types();
    var getNavigationEntryFromPerformanceTiming = () => {
      const timing = types3.WINDOW.performance.timing;
      const type = types3.WINDOW.performance.navigation.type;
      const navigationEntry = {
        entryType: "navigation",
        startTime: 0,
        type: type == 2 ? "back_forward" : type === 1 ? "reload" : "navigate"
      };
      for (const key in timing) {
        if (key !== "navigationStart" && key !== "toJSON") {
          navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
        }
      }
      return navigationEntry;
    };
    var getNavigationEntry = () => {
      if (types3.WINDOW.__WEB_VITALS_POLYFILL__) {
        return types3.WINDOW.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming());
      } else {
        return types3.WINDOW.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
      }
    };
    exports.getNavigationEntry = getNavigationEntry;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getActivationStart.js
var require_getActivationStart = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getActivationStart.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var getNavigationEntry = require_getNavigationEntry();
    var getActivationStart = () => {
      const navEntry = getNavigationEntry.getNavigationEntry();
      return navEntry && navEntry.activationStart || 0;
    };
    exports.getActivationStart = getActivationStart;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/initMetric.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types3 = require_types();
    var generateUniqueID = require_generateUniqueID();
    var getActivationStart = require_getActivationStart();
    var getNavigationEntry = require_getNavigationEntry();
    var initMetric = (name, value) => {
      const navEntry = getNavigationEntry.getNavigationEntry();
      let navigationType = "navigate";
      if (navEntry) {
        if (types3.WINDOW.document.prerendering || getActivationStart.getActivationStart() > 0) {
          navigationType = "prerender";
        } else {
          navigationType = navEntry.type.replace(/_/g, "-");
        }
      }
      return {
        name,
        value: typeof value === "undefined" ? -1 : value,
        rating: "good",
        // Will be updated if the value changes.
        delta: 0,
        entries: [],
        id: generateUniqueID.generateUniqueID(),
        navigationType
      };
    };
    exports.initMetric = initMetric;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/observe.js
var require_observe = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/observe.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var observe = (type, callback, opts) => {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(type)) {
          const po = new PerformanceObserver((list) => {
            callback(list.getEntries());
          });
          po.observe(
            Object.assign(
              {
                type,
                buffered: true
              },
              opts || {}
            )
          );
          return po;
        }
      } catch (e2) {
      }
      return;
    };
    exports.observe = observe;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/onHidden.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types3 = require_types();
    var onHidden = (cb, once) => {
      const onHiddenOrPageHide = (event) => {
        if (event.type === "pagehide" || types3.WINDOW.document.visibilityState === "hidden") {
          cb(event);
          if (once) {
            removeEventListener("visibilitychange", onHiddenOrPageHide, true);
            removeEventListener("pagehide", onHiddenOrPageHide, true);
          }
        }
      };
      addEventListener("visibilitychange", onHiddenOrPageHide, true);
      addEventListener("pagehide", onHiddenOrPageHide, true);
    };
    exports.onHidden = onHidden;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getCLS.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var onCLS = (onReport) => {
      const metric = initMetric.initMetric("CLS", 0);
      let report;
      let sessionValue = 0;
      let sessionEntries = [];
      const handleEntries = (entries) => {
        entries.forEach((entry) => {
          if (!entry.hadRecentInput) {
            const firstSessionEntry = sessionEntries[0];
            const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
            if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
              sessionValue += entry.value;
              sessionEntries.push(entry);
            } else {
              sessionValue = entry.value;
              sessionEntries = [entry];
            }
            if (sessionValue > metric.value) {
              metric.value = sessionValue;
              metric.entries = sessionEntries;
              if (report) {
                report();
              }
            }
          }
        });
      };
      const po = observe.observe("layout-shift", handleEntries);
      if (po) {
        report = bindReporter.bindReporter(onReport, metric);
        const stopListening = () => {
          handleEntries(po.takeRecords());
          report(true);
        };
        onHidden.onHidden(stopListening);
        return stopListening;
      }
      return;
    };
    exports.onCLS = onCLS;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getVisibilityWatcher.js
var require_getVisibilityWatcher = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getVisibilityWatcher.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types3 = require_types();
    var onHidden = require_onHidden();
    var firstHiddenTime = -1;
    var initHiddenTime = () => {
      return types3.WINDOW.document.visibilityState === "hidden" && !types3.WINDOW.document.prerendering ? 0 : Infinity;
    };
    var trackChanges = () => {
      onHidden.onHidden(({ timeStamp }) => {
        firstHiddenTime = timeStamp;
      }, true);
    };
    var getVisibilityWatcher = () => {
      if (firstHiddenTime < 0) {
        firstHiddenTime = initHiddenTime();
        trackChanges();
      }
      return {
        get firstHiddenTime() {
          return firstHiddenTime;
        }
      };
    };
    exports.getVisibilityWatcher = getVisibilityWatcher;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getFID.js
var require_getFID = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getFID.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var onFID = (onReport) => {
      const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
      const metric = initMetric.initMetric("FID");
      let report;
      const handleEntry = (entry) => {
        if (entry.startTime < visibilityWatcher.firstHiddenTime) {
          metric.value = entry.processingStart - entry.startTime;
          metric.entries.push(entry);
          report(true);
        }
      };
      const handleEntries = (entries) => {
        entries.forEach(handleEntry);
      };
      const po = observe.observe("first-input", handleEntries);
      report = bindReporter.bindReporter(onReport, metric);
      if (po) {
        onHidden.onHidden(() => {
          handleEntries(po.takeRecords());
          po.disconnect();
        }, true);
      }
    };
    exports.onFID = onFID;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getLCP.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var getActivationStart = require_getActivationStart();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var reportedMetricIDs = {};
    var onLCP = (onReport) => {
      const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
      const metric = initMetric.initMetric("LCP");
      let report;
      const handleEntries = (entries) => {
        const lastEntry = entries[entries.length - 1];
        if (lastEntry) {
          const value = Math.max(lastEntry.startTime - getActivationStart.getActivationStart(), 0);
          if (value < visibilityWatcher.firstHiddenTime) {
            metric.value = value;
            metric.entries = [lastEntry];
            report();
          }
        }
      };
      const po = observe.observe("largest-contentful-paint", handleEntries);
      if (po) {
        report = bindReporter.bindReporter(onReport, metric);
        const stopListening = () => {
          if (!reportedMetricIDs[metric.id]) {
            handleEntries(po.takeRecords());
            po.disconnect();
            reportedMetricIDs[metric.id] = true;
            report(true);
          }
        };
        ["keydown", "click"].forEach((type) => {
          addEventListener(type, stopListening, { once: true, capture: true });
        });
        onHidden.onHidden(stopListening, true);
        return stopListening;
      }
      return;
    };
    exports.onLCP = onLCP;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/metrics/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/metrics/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMeasurementValue(value) {
      return typeof value === "number" && isFinite(value);
    }
    function _startChild(transaction, { startTimestamp, ...ctx }) {
      if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
      }
      return transaction.startChild({
        startTimestamp,
        ...ctx
      });
    }
    exports._startChild = _startChild;
    exports.isMeasurementValue = isMeasurementValue;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/metrics/index.js
var require_metrics = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/metrics/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var types3 = require_types();
    var getCLS = require_getCLS();
    var getFID = require_getFID();
    var getLCP = require_getLCP();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var observe = require_observe();
    var utils$1 = require_utils2();
    function msToSec(time) {
      return time / 1e3;
    }
    function getBrowserPerformanceAPI() {
      return types3.WINDOW && types3.WINDOW.addEventListener && types3.WINDOW.performance;
    }
    var _performanceCursor = 0;
    var _measurements = {};
    var _lcpEntry;
    var _clsEntry;
    function startTrackingWebVitals() {
      const performance2 = getBrowserPerformanceAPI();
      if (performance2 && utils.browserPerformanceTimeOrigin) {
        if (performance2.mark) {
          types3.WINDOW.performance.mark("sentry-tracing-init");
        }
        _trackFID();
        const clsCallback = _trackCLS();
        const lcpCallback = _trackLCP();
        return () => {
          if (clsCallback) {
            clsCallback();
          }
          if (lcpCallback) {
            lcpCallback();
          }
        };
      }
      return () => void 0;
    }
    function startTrackingLongTasks() {
      const entryHandler = (entries) => {
        for (const entry of entries) {
          const transaction = core.getActiveTransaction();
          if (!transaction) {
            return;
          }
          const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
          const duration = msToSec(entry.duration);
          transaction.startChild({
            description: "Main UI thread blocked",
            op: "ui.long-task",
            startTimestamp: startTime,
            endTimestamp: startTime + duration
          });
        }
      };
      observe.observe("longtask", entryHandler);
    }
    function startTrackingInteractions() {
      const entryHandler = (entries) => {
        for (const entry of entries) {
          const transaction = core.getActiveTransaction();
          if (!transaction) {
            return;
          }
          if (entry.name === "click") {
            const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
            const duration = msToSec(entry.duration);
            transaction.startChild({
              description: utils.htmlTreeAsString(entry.target),
              op: `ui.interaction.${entry.name}`,
              startTimestamp: startTime,
              endTimestamp: startTime + duration
            });
          }
        }
      };
      observe.observe("event", entryHandler, { durationThreshold: 0 });
    }
    function _trackCLS() {
      return getCLS.onCLS((metric) => {
        const entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding CLS");
        _measurements["cls"] = { value: metric.value, unit: "" };
        _clsEntry = entry;
      });
    }
    function _trackLCP() {
      return getLCP.onLCP((metric) => {
        const entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding LCP");
        _measurements["lcp"] = { value: metric.value, unit: "millisecond" };
        _lcpEntry = entry;
      });
    }
    function _trackFID() {
      getFID.onFID((metric) => {
        const entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
        const startTime = msToSec(entry.startTime);
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding FID");
        _measurements["fid"] = { value: metric.value, unit: "millisecond" };
        _measurements["mark.fid"] = { value: timeOrigin + startTime, unit: "second" };
      });
    }
    function addPerformanceEntries(transaction) {
      const performance2 = getBrowserPerformanceAPI();
      if (!performance2 || !types3.WINDOW.performance.getEntries || !utils.browserPerformanceTimeOrigin) {
        return;
      }
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Tracing] Adding & adjusting spans using Performance API");
      const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
      const performanceEntries = performance2.getEntries();
      let responseStartTimestamp;
      let requestStartTimestamp;
      performanceEntries.slice(_performanceCursor).forEach((entry) => {
        const startTime = msToSec(entry.startTime);
        const duration = msToSec(entry.duration);
        if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
          return;
        }
        switch (entry.entryType) {
          case "navigation": {
            _addNavigationSpans(transaction, entry, timeOrigin);
            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
            break;
          }
          case "mark":
          case "paint":
          case "measure": {
            _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
            const firstHidden = getVisibilityWatcher.getVisibilityWatcher();
            const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
            if (entry.name === "first-paint" && shouldRecord) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding FP");
              _measurements["fp"] = { value: entry.startTime, unit: "millisecond" };
            }
            if (entry.name === "first-contentful-paint" && shouldRecord) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding FCP");
              _measurements["fcp"] = { value: entry.startTime, unit: "millisecond" };
            }
            break;
          }
          case "resource": {
            const resourceName = entry.name.replace(types3.WINDOW.location.origin, "");
            _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
            break;
          }
        }
      });
      _performanceCursor = Math.max(performanceEntries.length - 1, 0);
      _trackNavigator(transaction);
      if (transaction.op === "pageload") {
        if (typeof responseStartTimestamp === "number") {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding TTFB");
          _measurements["ttfb"] = {
            value: (responseStartTimestamp - transaction.startTimestamp) * 1e3,
            unit: "millisecond"
          };
          if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
            _measurements["ttfb.requestTime"] = {
              value: (responseStartTimestamp - requestStartTimestamp) * 1e3,
              unit: "millisecond"
            };
          }
        }
        ["fcp", "fp", "lcp"].forEach((name) => {
          if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {
            return;
          }
          const oldValue = _measurements[name].value;
          const measurementTimestamp = timeOrigin + msToSec(oldValue);
          const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
          const delta = normalizedValue - oldValue;
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
          _measurements[name].value = normalizedValue;
        });
        const fidMark = _measurements["mark.fid"];
        if (fidMark && _measurements["fid"]) {
          utils$1._startChild(transaction, {
            description: "first input delay",
            endTimestamp: fidMark.value + msToSec(_measurements["fid"].value),
            op: "ui.action",
            startTimestamp: fidMark.value
          });
          delete _measurements["mark.fid"];
        }
        if (!("fcp" in _measurements)) {
          delete _measurements.cls;
        }
        Object.keys(_measurements).forEach((measurementName) => {
          transaction.setMeasurement(
            measurementName,
            _measurements[measurementName].value,
            _measurements[measurementName].unit
          );
        });
        _tagMetricInfo(transaction);
      }
      _lcpEntry = void 0;
      _clsEntry = void 0;
      _measurements = {};
    }
    function _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
      const measureStartTimestamp = timeOrigin + startTime;
      const measureEndTimestamp = measureStartTimestamp + duration;
      utils$1._startChild(transaction, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        startTimestamp: measureStartTimestamp
      });
      return measureStartTimestamp;
    }
    function _addNavigationSpans(transaction, entry, timeOrigin) {
      ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((event) => {
        _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
      });
      _addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
      _addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
      _addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
      _addRequest(transaction, entry, timeOrigin);
    }
    function _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
      const end = eventEnd ? entry[eventEnd] : entry[`${event}End`];
      const start = entry[`${event}Start`];
      if (!start || !end) {
        return;
      }
      utils$1._startChild(transaction, {
        op: "browser",
        description: description || event,
        startTimestamp: timeOrigin + msToSec(start),
        endTimestamp: timeOrigin + msToSec(end)
      });
    }
    function _addRequest(transaction, entry, timeOrigin) {
      utils$1._startChild(transaction, {
        op: "browser",
        description: "request",
        startTimestamp: timeOrigin + msToSec(entry.requestStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
      utils$1._startChild(transaction, {
        op: "browser",
        description: "response",
        startTimestamp: timeOrigin + msToSec(entry.responseStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
    }
    function _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
      if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
        return;
      }
      const data = {};
      if ("transferSize" in entry) {
        data["http.response_transfer_size"] = entry.transferSize;
      }
      if ("encodedBodySize" in entry) {
        data["http.response_content_length"] = entry.encodedBodySize;
      }
      if ("decodedBodySize" in entry) {
        data["http.decoded_response_content_length"] = entry.decodedBodySize;
      }
      if ("renderBlockingStatus" in entry) {
        data["resource.render_blocking_status"] = entry.renderBlockingStatus;
      }
      const startTimestamp = timeOrigin + startTime;
      const endTimestamp = startTimestamp + duration;
      utils$1._startChild(transaction, {
        description: resourceName,
        endTimestamp,
        op: entry.initiatorType ? `resource.${entry.initiatorType}` : "resource.other",
        startTimestamp,
        data
      });
    }
    function _trackNavigator(transaction) {
      const navigator2 = types3.WINDOW.navigator;
      if (!navigator2) {
        return;
      }
      const connection = navigator2.connection;
      if (connection) {
        if (connection.effectiveType) {
          transaction.setTag("effectiveConnectionType", connection.effectiveType);
        }
        if (connection.type) {
          transaction.setTag("connectionType", connection.type);
        }
        if (utils$1.isMeasurementValue(connection.rtt)) {
          _measurements["connection.rtt"] = { value: connection.rtt, unit: "millisecond" };
        }
      }
      if (utils$1.isMeasurementValue(navigator2.deviceMemory)) {
        transaction.setTag("deviceMemory", `${navigator2.deviceMemory} GB`);
      }
      if (utils$1.isMeasurementValue(navigator2.hardwareConcurrency)) {
        transaction.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
      }
    }
    function _tagMetricInfo(transaction) {
      if (_lcpEntry) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding LCP Data");
        if (_lcpEntry.element) {
          transaction.setTag("lcp.element", utils.htmlTreeAsString(_lcpEntry.element));
        }
        if (_lcpEntry.id) {
          transaction.setTag("lcp.id", _lcpEntry.id);
        }
        if (_lcpEntry.url) {
          transaction.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200));
        }
        transaction.setTag("lcp.size", _lcpEntry.size);
      }
      if (_clsEntry && _clsEntry.sources) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("[Measurements] Adding CLS Data");
        _clsEntry.sources.forEach(
          (source, index) => transaction.setTag(`cls.source.${index + 1}`, utils.htmlTreeAsString(source.node))
        );
      }
    }
    exports._addMeasureSpans = _addMeasureSpans;
    exports._addResourceSpans = _addResourceSpans;
    exports.addPerformanceEntries = addPerformanceEntries;
    exports.startTrackingInteractions = startTrackingInteractions;
    exports.startTrackingLongTasks = startTrackingLongTasks;
    exports.startTrackingWebVitals = startTrackingWebVitals;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/request.js
var require_request = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/request.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var DEFAULT_TRACE_PROPAGATION_TARGETS = ["localhost", /^\//];
    var defaultRequestInstrumentationOptions = {
      traceFetch: true,
      traceXHR: true,
      // TODO (v8): Remove this property
      tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,
      tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS
    };
    function instrumentOutgoingRequests(_options) {
      const { traceFetch, traceXHR, tracePropagationTargets, tracingOrigins, shouldCreateSpanForRequest } = {
        traceFetch: defaultRequestInstrumentationOptions.traceFetch,
        traceXHR: defaultRequestInstrumentationOptions.traceXHR,
        ..._options
      };
      const shouldCreateSpan = typeof shouldCreateSpanForRequest === "function" ? shouldCreateSpanForRequest : (_) => true;
      const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);
      const spans = {};
      if (traceFetch) {
        utils.addInstrumentationHandler("fetch", (handlerData) => {
          fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        });
      }
      if (traceXHR) {
        utils.addInstrumentationHandler("xhr", (handlerData) => {
          xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        });
      }
    }
    function shouldAttachHeaders(url, tracePropagationTargets) {
      return utils.stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);
    }
    function fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {
      if (!core.hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
        return;
      }
      if (handlerData.endTimestamp) {
        const spanId = handlerData.fetchData.__span;
        if (!spanId)
          return;
        const span = spans[spanId];
        if (span) {
          if (handlerData.response) {
            span.setHttpStatus(handlerData.response.status);
          } else if (handlerData.error) {
            span.setStatus("internal_error");
          }
          span.finish();
          delete spans[spanId];
        }
        return;
      }
      const contentLength = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        handlerData.response && handlerData.response.headers && handlerData.response.headers.get("content-length")
      );
      const currentScope = core.getCurrentHub().getScope();
      const currentSpan = currentScope && currentScope.getSpan();
      const activeTransaction = currentSpan && currentSpan.transaction;
      if (currentSpan && activeTransaction) {
        const { method, url } = handlerData.fetchData;
        const span = currentSpan.startChild({
          data: {
            url,
            type: "fetch",
            ...contentLength ? { "http.response_content_length": contentLength } : {},
            "http.method": method
          },
          description: `${method} ${url}`,
          op: "http.client"
        });
        handlerData.fetchData.__span = span.spanId;
        spans[span.spanId] = span;
        const request = handlerData.args[0];
        handlerData.args[1] = handlerData.args[1] || {};
        const options = handlerData.args[1];
        if (shouldAttachHeaders2(handlerData.fetchData.url)) {
          options.headers = addTracingHeadersToFetchRequest(
            request,
            activeTransaction.getDynamicSamplingContext(),
            span,
            options
          );
        }
      }
    }
    function addTracingHeadersToFetchRequest(request, dynamicSamplingContext, span, options) {
      const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
      const sentryTraceHeader = span.toTraceparent();
      const headers = typeof Request !== "undefined" && utils.isInstanceOf(request, Request) ? request.headers : options.headers;
      if (!headers) {
        return { "sentry-trace": sentryTraceHeader, baggage: sentryBaggageHeader };
      } else if (typeof Headers !== "undefined" && utils.isInstanceOf(headers, Headers)) {
        const newHeaders = new Headers(headers);
        newHeaders.append("sentry-trace", sentryTraceHeader);
        if (sentryBaggageHeader) {
          newHeaders.append(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
        }
        return newHeaders;
      } else if (Array.isArray(headers)) {
        const newHeaders = [...headers, ["sentry-trace", sentryTraceHeader]];
        if (sentryBaggageHeader) {
          newHeaders.push([utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader]);
        }
        return newHeaders;
      } else {
        const existingBaggageHeader = "baggage" in headers ? headers.baggage : void 0;
        const newBaggageHeaders = [];
        if (Array.isArray(existingBaggageHeader)) {
          newBaggageHeaders.push(...existingBaggageHeader);
        } else if (existingBaggageHeader) {
          newBaggageHeaders.push(existingBaggageHeader);
        }
        if (sentryBaggageHeader) {
          newBaggageHeaders.push(sentryBaggageHeader);
        }
        return {
          ...headers,
          "sentry-trace": sentryTraceHeader,
          baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(",") : void 0
        };
      }
    }
    function xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {
      const xhr = handlerData.xhr;
      const sentryXhrData = xhr && xhr[utils.SENTRY_XHR_DATA_KEY];
      if (!core.hasTracingEnabled() || xhr && xhr.__sentry_own_request__ || !(xhr && sentryXhrData && shouldCreateSpan(sentryXhrData.url))) {
        return;
      }
      if (handlerData.endTimestamp) {
        const spanId = xhr.__sentry_xhr_span_id__;
        if (!spanId)
          return;
        const span = spans[spanId];
        if (span) {
          span.setHttpStatus(sentryXhrData.status_code);
          span.finish();
          delete spans[spanId];
        }
        return;
      }
      const currentScope = core.getCurrentHub().getScope();
      const currentSpan = currentScope && currentScope.getSpan();
      const activeTransaction = currentSpan && currentSpan.transaction;
      if (currentSpan && activeTransaction) {
        const span = currentSpan.startChild({
          data: {
            ...sentryXhrData.data,
            type: "xhr",
            "http.method": sentryXhrData.method,
            url: sentryXhrData.url
          },
          description: `${sentryXhrData.method} ${sentryXhrData.url}`,
          op: "http.client"
        });
        xhr.__sentry_xhr_span_id__ = span.spanId;
        spans[xhr.__sentry_xhr_span_id__] = span;
        if (xhr.setRequestHeader && shouldAttachHeaders2(sentryXhrData.url)) {
          try {
            xhr.setRequestHeader("sentry-trace", span.toTraceparent());
            const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();
            const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
            if (sentryBaggageHeader) {
              xhr.setRequestHeader(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
            }
          } catch (_) {
          }
        }
      }
    }
    exports.DEFAULT_TRACE_PROPAGATION_TARGETS = DEFAULT_TRACE_PROPAGATION_TARGETS;
    exports.addTracingHeadersToFetchRequest = addTracingHeadersToFetchRequest;
    exports.defaultRequestInstrumentationOptions = defaultRequestInstrumentationOptions;
    exports.fetchCallback = fetchCallback;
    exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
    exports.shouldAttachHeaders = shouldAttachHeaders;
    exports.xhrCallback = xhrCallback;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/router.js
var require_router = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/router.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var types3 = require_types();
    function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
      if (!types3.WINDOW || !types3.WINDOW.location) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Could not initialize routing instrumentation due to invalid location");
        return;
      }
      let startingUrl = types3.WINDOW.location.href;
      let activeTransaction;
      if (startTransactionOnPageLoad) {
        activeTransaction = customStartTransaction({
          name: types3.WINDOW.location.pathname,
          // pageload should always start at timeOrigin (and needs to be in s, not ms)
          startTimestamp: utils.browserPerformanceTimeOrigin ? utils.browserPerformanceTimeOrigin / 1e3 : void 0,
          op: "pageload",
          metadata: { source: "url" }
        });
      }
      if (startTransactionOnLocationChange) {
        utils.addInstrumentationHandler("history", ({ to, from }) => {
          if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
            startingUrl = void 0;
            return;
          }
          if (from !== to) {
            startingUrl = void 0;
            if (activeTransaction) {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);
              activeTransaction.finish();
            }
            activeTransaction = customStartTransaction({
              name: types3.WINDOW.location.pathname,
              op: "navigation",
              metadata: { source: "url" }
            });
          }
        });
      }
    }
    exports.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/browsertracing.js
var require_browsertracing = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/browser/browsertracing.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var backgroundtab = require_backgroundtab();
    var index = require_metrics();
    var request = require_request();
    var router = require_router();
    var types3 = require_types();
    var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
    var DEFAULT_BROWSER_TRACING_OPTIONS = {
      ...core.TRACING_DEFAULTS,
      markBackgroundTransactions: true,
      routingInstrumentation: router.instrumentRoutingWithDefaults,
      startTransactionOnLocationChange: true,
      startTransactionOnPageLoad: true,
      enableLongTask: true,
      _experiments: {},
      ...request.defaultRequestInstrumentationOptions
    };
    var BrowserTracing = class {
      // This class currently doesn't have a static `id` field like the other integration classes, because it prevented
      // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.
      // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all
      // integrations.
      /** Browser Tracing integration options */
      /**
       * @inheritDoc
       */
      __init() {
        this.name = BROWSER_TRACING_INTEGRATION_ID;
      }
      constructor(_options) {
        BrowserTracing.prototype.__init.call(this);
        core.addTracingExtensions();
        this.options = {
          ...DEFAULT_BROWSER_TRACING_OPTIONS,
          ..._options
        };
        if (this.options._experiments.enableLongTask !== void 0) {
          this.options.enableLongTask = this.options._experiments.enableLongTask;
        }
        if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {
          this.options.tracePropagationTargets = _options.tracingOrigins;
        }
        this._collectWebVitals = index.startTrackingWebVitals();
        if (this.options.enableLongTask) {
          index.startTrackingLongTasks();
        }
        if (this.options._experiments.enableInteractions) {
          index.startTrackingInteractions();
        }
      }
      /**
       * @inheritDoc
       */
      setupOnce(_, getCurrentHub) {
        this._getCurrentHub = getCurrentHub;
        const {
          routingInstrumentation: instrumentRouting,
          startTransactionOnLocationChange,
          startTransactionOnPageLoad,
          markBackgroundTransactions,
          traceFetch,
          traceXHR,
          tracePropagationTargets,
          shouldCreateSpanForRequest,
          _experiments
        } = this.options;
        instrumentRouting(
          (context) => {
            const transaction = this._createRouteTransaction(context);
            this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(transaction, context, getCurrentHub);
            return transaction;
          },
          startTransactionOnPageLoad,
          startTransactionOnLocationChange
        );
        if (markBackgroundTransactions) {
          backgroundtab.registerBackgroundTabDetection();
        }
        if (_experiments.enableInteractions) {
          this._registerInteractionListener();
        }
        request.instrumentOutgoingRequests({
          traceFetch,
          traceXHR,
          tracePropagationTargets,
          shouldCreateSpanForRequest
        });
      }
      /** Create routing idle transaction. */
      _createRouteTransaction(context) {
        if (!this._getCurrentHub) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);
          return void 0;
        }
        const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;
        const isPageloadTransaction = context.op === "pageload";
        const sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent("sentry-trace") : null;
        const baggageMetaTagValue = isPageloadTransaction ? getMetaContent("baggage") : null;
        const traceParentData = sentryTraceMetaTagValue ? core.extractTraceparentData(sentryTraceMetaTagValue) : void 0;
        const dynamicSamplingContext = baggageMetaTagValue ? utils.baggageHeaderToDynamicSamplingContext(baggageMetaTagValue) : void 0;
        const expandedContext = {
          ...context,
          ...traceParentData,
          metadata: {
            ...context.metadata,
            dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext
          },
          trimEnd: true
        };
        const modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
        const finalContext = modifiedContext === void 0 ? { ...expandedContext, sampled: false } : modifiedContext;
        finalContext.metadata = finalContext.name !== expandedContext.name ? { ...finalContext.metadata, source: "custom" } : finalContext.metadata;
        this._latestRouteName = finalContext.name;
        this._latestRouteSource = finalContext.metadata && finalContext.metadata.source;
        if (finalContext.sampled === false) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
        }
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
        const hub = this._getCurrentHub();
        const { location: location2 } = types3.WINDOW;
        const idleTransaction = core.startIdleTransaction(
          hub,
          finalContext,
          idleTimeout,
          finalTimeout,
          true,
          { location: location2 },
          // for use in the tracesSampler
          heartbeatInterval
        );
        idleTransaction.registerBeforeFinishCallback((transaction) => {
          this._collectWebVitals();
          index.addPerformanceEntries(transaction);
        });
        return idleTransaction;
      }
      /** Start listener for interaction transactions */
      _registerInteractionListener() {
        let inflightInteractionTransaction;
        const registerInteractionTransaction = () => {
          const { idleTimeout, finalTimeout, heartbeatInterval } = this.options;
          const op = "ui.action.click";
          const currentTransaction = core.getActiveTransaction();
          if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
              `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`
            );
            return void 0;
          }
          if (inflightInteractionTransaction) {
            inflightInteractionTransaction.setFinishReason("interactionInterrupted");
            inflightInteractionTransaction.finish();
            inflightInteractionTransaction = void 0;
          }
          if (!this._getCurrentHub) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);
            return void 0;
          }
          if (!this._latestRouteName) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
            return void 0;
          }
          const hub = this._getCurrentHub();
          const { location: location2 } = types3.WINDOW;
          const context = {
            name: this._latestRouteName,
            op,
            trimEnd: true,
            metadata: {
              source: this._latestRouteSource || "url"
            }
          };
          inflightInteractionTransaction = core.startIdleTransaction(
            hub,
            context,
            idleTimeout,
            finalTimeout,
            true,
            { location: location2 },
            // for use in the tracesSampler
            heartbeatInterval
          );
        };
        ["click"].forEach((type) => {
          addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
        });
      }
    };
    function getMetaContent(metaName) {
      const metaTag = utils.getDomElement(`meta[name=${metaName}]`);
      return metaTag ? metaTag.getAttribute("content") : null;
    }
    exports.BROWSER_TRACING_INTEGRATION_ID = BROWSER_TRACING_INTEGRATION_ID;
    exports.BrowserTracing = BrowserTracing;
    exports.getMetaContent = getMetaContent;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/extensions.js
var require_extensions = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/extensions.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function _autoloadDatabaseIntegrations() {
      const carrier = core.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      const packageToIntegrationMapping = {
        mongodb() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
          return new integration.Mongo();
        },
        mongoose() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
          return new integration.Mongo();
        },
        mysql() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mysql");
          return new integration.Mysql();
        },
        pg() {
          const integration = utils.dynamicRequire(module, "./node/integrations/postgres");
          return new integration.Postgres();
        }
      };
      const mappedPackages = Object.keys(packageToIntegrationMapping).filter((moduleName) => !!utils.loadModule(moduleName)).map((pkg) => {
        try {
          return packageToIntegrationMapping[pkg]();
        } catch (e2) {
          return void 0;
        }
      }).filter((p) => p);
      if (mappedPackages.length > 0) {
        carrier.__SENTRY__.integrations = [...carrier.__SENTRY__.integrations || [], ...mappedPackages];
      }
    }
    function addExtensionMethods() {
      core.addTracingExtensions();
      if (utils.isNodeEnv()) {
        _autoloadDatabaseIntegrations();
      }
    }
    exports.addExtensionMethods = addExtensionMethods;
  }
});

// ../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/index.js
var require_cjs3 = __commonJS({
  "../../node_modules/@sentry/node/node_modules/@sentry-internal/tracing/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var express = require_express();
    var postgres = require_postgres();
    var mysql = require_mysql();
    var mongo = require_mongo();
    var prisma = require_prisma();
    var graphql = require_graphql();
    var apollo = require_apollo();
    var lazy = require_lazy();
    var browsertracing = require_browsertracing();
    var request = require_request();
    var extensions = require_extensions();
    exports.IdleTransaction = core.IdleTransaction;
    exports.Span = core.Span;
    exports.SpanStatus = core.SpanStatus;
    exports.Transaction = core.Transaction;
    exports.extractTraceparentData = core.extractTraceparentData;
    exports.getActiveTransaction = core.getActiveTransaction;
    exports.hasTracingEnabled = core.hasTracingEnabled;
    exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
    exports.startIdleTransaction = core.startIdleTransaction;
    exports.TRACEPARENT_REGEXP = utils.TRACEPARENT_REGEXP;
    exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
    exports.Express = express.Express;
    exports.Postgres = postgres.Postgres;
    exports.Mysql = mysql.Mysql;
    exports.Mongo = mongo.Mongo;
    exports.Prisma = prisma.Prisma;
    exports.GraphQL = graphql.GraphQL;
    exports.Apollo = apollo.Apollo;
    exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazy.lazyLoadedNodePerformanceMonitoringIntegrations;
    exports.BROWSER_TRACING_INTEGRATION_ID = browsertracing.BROWSER_TRACING_INTEGRATION_ID;
    exports.BrowserTracing = browsertracing.BrowserTracing;
    exports.addTracingHeadersToFetchRequest = request.addTracingHeadersToFetchRequest;
    exports.defaultRequestInstrumentationOptions = request.defaultRequestInstrumentationOptions;
    exports.instrumentOutgoingRequests = request.instrumentOutgoingRequests;
    exports.addExtensionMethods = extensions.addExtensionMethods;
  }
});

// ../../node_modules/@sentry/node/cjs/tracing/index.js
var require_tracing2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/tracing/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tracing = require_cjs3();
    var utils = require_cjs();
    function autoDiscoverNodePerformanceMonitoringIntegrations() {
      const loadedIntegrations = tracing.lazyLoadedNodePerformanceMonitoringIntegrations.map((tryLoad) => {
        try {
          return tryLoad();
        } catch (_) {
          return void 0;
        }
      }).filter((integration) => !!integration);
      if (loadedIntegrations.length === 0) {
        utils.logger.warn("Performance monitoring integrations could not be automatically loaded.");
      }
      return loadedIntegrations.filter((integration) => !!integration.loadDependency());
    }
    exports.autoDiscoverNodePerformanceMonitoringIntegrations = autoDiscoverNodePerformanceMonitoringIntegrations;
  }
});

// ../../node_modules/@sentry/node/cjs/checkin.js
var require_checkin = __commonJS({
  "../../node_modules/@sentry/node/cjs/checkin.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function createCheckInEnvelope(checkIn, metadata, tunnel, dsn) {
      const headers = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...metadata && metadata.sdk && {
          sdk: {
            name: metadata.sdk.name,
            version: metadata.sdk.version
          }
        },
        ...!!tunnel && !!dsn && { dsn: utils.dsnToString(dsn) }
      };
      const item = createCheckInEnvelopeItem(checkIn);
      return utils.createEnvelope(headers, [item]);
    }
    function createCheckInEnvelopeItem(checkIn) {
      const checkInHeaders = {
        type: "check_in"
      };
      return [checkInHeaders, checkIn];
    }
    exports.createCheckInEnvelope = createCheckInEnvelope;
  }
});

// ../../node_modules/@sentry/node/cjs/eventbuilder.js
var require_eventbuilder = __commonJS({
  "../../node_modules/@sentry/node/cjs/eventbuilder.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function parseStackFrames(stackParser, error) {
      return stackParser(error.stack || "", 1);
    }
    function exceptionFromError(stackParser, error) {
      const exception = {
        type: error.name || error.constructor.name,
        value: error.message
      };
      const frames = parseStackFrames(stackParser, error);
      if (frames.length) {
        exception.stacktrace = { frames };
      }
      return exception;
    }
    function eventFromUnknownInput(stackParser, exception, hint) {
      let ex = exception;
      const providedMechanism = hint && hint.data && hint.data.mechanism;
      const mechanism = providedMechanism || {
        handled: true,
        type: "generic"
      };
      if (!utils.isError(exception)) {
        if (utils.isPlainObject(exception)) {
          const message = `Non-Error exception captured with keys: ${utils.extractExceptionKeysForMessage(exception)}`;
          const hub = core.getCurrentHub();
          const client = hub.getClient();
          const normalizeDepth = client && client.getOptions().normalizeDepth;
          hub.configureScope((scope) => {
            scope.setExtra("__serialized__", utils.normalizeToSize(exception, normalizeDepth));
          });
          ex = hint && hint.syntheticException || new Error(message);
          ex.message = message;
        } else {
          ex = hint && hint.syntheticException || new Error(exception);
          ex.message = exception;
        }
        mechanism.synthetic = true;
      }
      const event = {
        exception: {
          values: [exceptionFromError(stackParser, ex)]
        }
      };
      utils.addExceptionTypeValue(event, void 0, void 0);
      utils.addExceptionMechanism(event, mechanism);
      return {
        ...event,
        event_id: hint && hint.event_id
      };
    }
    function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
      const event = {
        event_id: hint && hint.event_id,
        level,
        message
      };
      if (attachStacktrace && hint && hint.syntheticException) {
        const frames = parseStackFrames(stackParser, hint.syntheticException);
        if (frames.length) {
          event.exception = {
            values: [
              {
                value: message,
                stacktrace: { frames }
              }
            ]
          };
        }
      }
      return event;
    }
    exports.eventFromMessage = eventFromMessage;
    exports.eventFromUnknownInput = eventFromUnknownInput;
    exports.exceptionFromError = exceptionFromError;
    exports.parseStackFrames = parseStackFrames;
  }
});

// ../../node_modules/@sentry/node/cjs/client.js
var require_client2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/client.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var os = __require("os");
    var util2 = __require("util");
    var checkin = require_checkin();
    var eventbuilder = require_eventbuilder();
    var NodeClient = class extends core.BaseClient {
      /**
       * Creates a new Node SDK instance.
       * @param options Configuration options for this SDK.
       */
      constructor(options) {
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
          name: "sentry.javascript.node",
          packages: [
            {
              name: "npm:@sentry/node",
              version: core.SDK_VERSION
            }
          ],
          version: core.SDK_VERSION
        };
        options.transportOptions = {
          textEncoder: new util2.TextEncoder(),
          ...options.transportOptions
        };
        core.addTracingExtensions();
        super(options);
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      captureException(exception, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          const requestSession = scope.getRequestSession();
          if (requestSession && requestSession.status === "ok") {
            requestSession.status = "errored";
          }
        }
        return super.captureException(exception, hint, scope);
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          const eventType = event.type || "exception";
          const isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
          if (isException) {
            const requestSession = scope.getRequestSession();
            if (requestSession && requestSession.status === "ok") {
              requestSession.status = "errored";
            }
          }
        }
        return super.captureEvent(event, hint, scope);
      }
      /**
       *
       * @inheritdoc
       */
      close(timeout) {
        _optionalChain([this, "access", (_) => _._sessionFlusher, "optionalAccess", (_2) => _2.close, "call", (_3) => _3()]);
        return super.close(timeout);
      }
      /** Method that initialises an instance of SessionFlusher on Client */
      initSessionFlusher() {
        const { release, environment } = this._options;
        if (!release) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
        } else {
          this._sessionFlusher = new core.SessionFlusher(this, {
            release,
            environment
          });
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      eventFromException(exception, hint) {
        return utils.resolvedSyncPromise(eventbuilder.eventFromUnknownInput(this._options.stackParser, exception, hint));
      }
      /**
       * @inheritDoc
       */
      eventFromMessage(message, level = "info", hint) {
        return utils.resolvedSyncPromise(
          eventbuilder.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace)
        );
      }
      /**
       * Create a cron monitor check in and send it to Sentry.
       *
       * @param checkIn An object that describes a check in.
       * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
       * to create a monitor automatically when sending a check in.
       * @returns A string representing the id of the check in.
       */
      captureCheckIn(checkIn, monitorConfig) {
        const id = checkIn.status !== "in_progress" && checkIn.checkInId ? checkIn.checkInId : utils.uuid4();
        if (!this._isEnabled()) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("SDK not enabled, will not capture checkin.");
          return id;
        }
        const options = this.getOptions();
        const { release, environment, tunnel } = options;
        const serializedCheckIn = {
          check_in_id: id,
          monitor_slug: checkIn.monitorSlug,
          status: checkIn.status,
          release,
          environment
        };
        if (checkIn.status !== "in_progress") {
          serializedCheckIn.duration = checkIn.duration;
        }
        if (monitorConfig) {
          serializedCheckIn.monitor_config = {
            schedule: monitorConfig.schedule,
            checkin_margin: monitorConfig.checkinMargin,
            max_runtime: monitorConfig.maxRuntime,
            timezone: monitorConfig.timezone
          };
        }
        const envelope = checkin.createCheckInEnvelope(serializedCheckIn, this.getSdkMetadata(), tunnel, this.getDsn());
        void this._sendEnvelope(envelope);
        return id;
      }
      /**
       * @inheritDoc
       */
      _prepareEvent(event, hint, scope) {
        event.platform = event.platform || "node";
        event.contexts = {
          ...event.contexts,
          runtime: _optionalChain([event, "access", (_4) => _4.contexts, "optionalAccess", (_5) => _5.runtime]) || {
            name: "node",
            version: global.process.version
          }
        };
        event.server_name = event.server_name || this.getOptions().serverName || global.process.env.SENTRY_NAME || os.hostname();
        return super._prepareEvent(event, hint, scope);
      }
      /**
       * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
       * appropriate session aggregates bucket
       */
      _captureRequestSession() {
        if (!this._sessionFlusher) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
        } else {
          this._sessionFlusher.incrementSessionStatusCount();
        }
      }
    };
    exports.NodeClient = NodeClient;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../../node_modules/debug/src/node.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var tty = __require("tty");
    var util2 = __require("util");
    exports.init = init3;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init3(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/debug/src/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser2();
    } else {
      module.exports = require_node2();
    }
  }
});

// ../../node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "../../node_modules/agent-base/dist/src/promisify.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function promisify2(fn) {
      return function(req, opts) {
        return new Promise((resolve2, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve2(rtn);
            }
          });
        });
      };
    }
    exports.default = promisify2;
  }
});

// ../../node_modules/agent-base/dist/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/agent-base/dist/src/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = __require("events");
    var debug_1 = __importDefault(require_src2());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module.exports = createAgent;
  }
});

// ../../node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "../../node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src2());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve2, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve2({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports.default = parseProxyResponse;
  }
});

// ../../node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "../../node_modules/https-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(__require("net"));
    var tls_1 = __importDefault(__require("tls"));
    var url_1 = __importDefault(__require("url"));
    var assert_1 = __importDefault(__require("assert"));
    var debug_1 = __importDefault(require_src2());
    var agent_base_1 = require_src3();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s2) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s2.listenerCount("data") > 0);
            s2.push(buffered);
            s2.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// ../../node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/https-proxy-agent/dist/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module.exports = createHttpsProxyAgent;
  }
});

// ../../node_modules/@sentry/node/cjs/transports/http.js
var require_http = __commonJS({
  "../../node_modules/@sentry/node/cjs/transports/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _nullishCoalesce
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var http3 = __require("http");
    var https2 = __require("https");
    var httpsProxyAgent = require_dist3();
    var stream = __require("stream");
    var url = __require("url");
    var zlib2 = __require("zlib");
    var GZIP_THRESHOLD = 1024 * 32;
    function streamFromBody(body) {
      return new stream.Readable({
        read() {
          this.push(body);
          this.push(null);
        }
      });
    }
    function makeNodeTransport(options) {
      let urlSegments;
      try {
        urlSegments = new url.URL(options.url);
      } catch (e2) {
        console.warn(
          "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
        );
        return core.createTransport(options, () => Promise.resolve({}));
      }
      const isHttps = urlSegments.protocol === "https:";
      const proxy = applyNoProxyOption(
        urlSegments,
        options.proxy || (isHttps ? process.env.https_proxy : void 0) || process.env.http_proxy
      );
      const nativeHttpModule = isHttps ? https2 : http3;
      const keepAlive = options.keepAlive === void 0 ? false : options.keepAlive;
      const agent = proxy ? new httpsProxyAgent.HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2e3 });
      const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
      return core.createTransport(options, requestExecutor);
    }
    function applyNoProxyOption(transportUrlSegments, proxy) {
      const { no_proxy } = process.env;
      const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some(
        (exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption)
      );
      if (urlIsExemptFromProxy) {
        return void 0;
      } else {
        return proxy;
      }
    }
    function createRequestExecutor(options, httpModule, agent) {
      const { hostname, pathname, port, protocol, search } = new url.URL(options.url);
      return function makeRequest(request) {
        return new Promise((resolve2, reject) => {
          let body = streamFromBody(request.body);
          const headers = { ...options.headers };
          if (request.body.length > GZIP_THRESHOLD) {
            headers["content-encoding"] = "gzip";
            body = body.pipe(zlib2.createGzip());
          }
          const req = httpModule.request(
            {
              method: "POST",
              agent,
              headers,
              hostname,
              path: `${pathname}${search}`,
              port,
              protocol,
              ca: options.caCerts
            },
            (res) => {
              res.on("data", () => {
              });
              res.on("end", () => {
              });
              res.setEncoding("utf8");
              const retryAfterHeader = _nullishCoalesce(res.headers["retry-after"], () => null);
              const rateLimitsHeader = _nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
              resolve2({
                statusCode: res.statusCode,
                headers: {
                  "retry-after": retryAfterHeader,
                  "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader
                }
              });
            }
          );
          req.on("error", reject);
          body.pipe(req);
        });
      };
    }
    exports.makeNodeTransport = makeNodeTransport;
  }
});

// ../../node_modules/@sentry/node/cjs/nodeVersion.js
var require_nodeVersion = __commonJS({
  "../../node_modules/@sentry/node/cjs/nodeVersion.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var NODE_VERSION = utils.parseSemver(process.versions.node);
    exports.NODE_VERSION = NODE_VERSION;
  }
});

// ../../node_modules/@sentry/node/cjs/async/domain.js
var require_domain = __commonJS({
  "../../node_modules/@sentry/node/cjs/async/domain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var domain = __require("domain");
    function getActiveDomain() {
      return domain.active;
    }
    function getCurrentHub() {
      const activeDomain = getActiveDomain();
      if (!activeDomain) {
        return void 0;
      }
      core.ensureHubOnCarrier(activeDomain);
      return core.getHubFromCarrier(activeDomain);
    }
    function createNewHub(parent) {
      const carrier = {};
      core.ensureHubOnCarrier(carrier, parent);
      return core.getHubFromCarrier(carrier);
    }
    function runWithAsyncContext(callback, options) {
      const activeDomain = getActiveDomain();
      if (activeDomain && _optionalChain([options, "optionalAccess", (_) => _.reuseExisting])) {
        return callback();
      }
      const local = domain.create();
      const parentHub = activeDomain ? core.getHubFromCarrier(activeDomain) : void 0;
      const newHub = createNewHub(parentHub);
      core.setHubOnCarrier(local, newHub);
      return local.bind(() => {
        return callback();
      })();
    }
    function setDomainAsyncContextStrategy() {
      core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
    }
    exports.setDomainAsyncContextStrategy = setDomainAsyncContextStrategy;
  }
});

// ../../node_modules/@sentry/node/cjs/async/hooks.js
var require_hooks = __commonJS({
  "../../node_modules/@sentry/node/cjs/async/hooks.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var async_hooks = __require("async_hooks");
    function setHooksAsyncContextStrategy() {
      const asyncStorage = new async_hooks.AsyncLocalStorage();
      function getCurrentHub() {
        return asyncStorage.getStore();
      }
      function createNewHub(parent) {
        const carrier = {};
        core.ensureHubOnCarrier(carrier, parent);
        return core.getHubFromCarrier(carrier);
      }
      function runWithAsyncContext(callback, options) {
        const existingHub = getCurrentHub();
        if (existingHub && _optionalChain([options, "optionalAccess", (_) => _.reuseExisting])) {
          return callback();
        }
        const newHub = createNewHub(existingHub);
        return asyncStorage.run(newHub, () => {
          return callback();
        });
      }
      core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
    }
    exports.setHooksAsyncContextStrategy = setHooksAsyncContextStrategy;
  }
});

// ../../node_modules/@sentry/node/cjs/async/index.js
var require_async = __commonJS({
  "../../node_modules/@sentry/node/cjs/async/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var nodeVersion = require_nodeVersion();
    var domain = require_domain();
    var hooks = require_hooks();
    function setNodeAsyncContextStrategy() {
      if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major >= 14) {
        hooks.setHooksAsyncContextStrategy();
      } else {
        domain.setDomainAsyncContextStrategy();
      }
    }
    exports.setNodeAsyncContextStrategy = setNodeAsyncContextStrategy;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/console.js
var require_console = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/console.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var util2 = __require("util");
    var Console = class {
      constructor() {
        Console.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Console";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Console.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
        for (const level of ["debug", "info", "warn", "error", "log"]) {
          utils.fill(console, level, createConsoleWrapper(level));
        }
      }
    };
    Console.__initStatic();
    function createConsoleWrapper(level) {
      return function consoleWrapper(originalConsoleMethod) {
        const sentryLevel = utils.severityLevelFromString(level);
        return function() {
          if (core.getCurrentHub().getIntegration(Console)) {
            core.getCurrentHub().addBreadcrumb(
              {
                category: "console",
                level: sentryLevel,
                message: util2.format.apply(void 0, arguments)
              },
              {
                input: [...arguments],
                level
              }
            );
          }
          originalConsoleMethod.apply(this, arguments);
        };
      };
    }
    exports.Console = Console;
  }
});

// ../../node_modules/lru_map/lru.js
var require_lru = __commonJS({
  "../../node_modules/lru_map/lru.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function(g, f3) {
      const e2 = typeof exports == "object" ? exports : typeof g == "object" ? g : {};
      f3(e2);
      if (typeof define == "function" && define.amd) {
        define("lru", e2);
      }
    })(exports, function(exports2) {
      const NEWER = Symbol("newer");
      const OLDER = Symbol("older");
      function LRUMap(limit, entries) {
        if (typeof limit !== "number") {
          entries = limit;
          limit = 0;
        }
        this.size = 0;
        this.limit = limit;
        this.oldest = this.newest = void 0;
        this._keymap = /* @__PURE__ */ new Map();
        if (entries) {
          this.assign(entries);
          if (limit < 1) {
            this.limit = this.size;
          }
        }
      }
      exports2.LRUMap = LRUMap;
      function Entry(key, value) {
        this.key = key;
        this.value = value;
        this[NEWER] = void 0;
        this[OLDER] = void 0;
      }
      LRUMap.prototype._markEntryAsUsed = function(entry) {
        if (entry === this.newest) {
          return;
        }
        if (entry[NEWER]) {
          if (entry === this.oldest) {
            this.oldest = entry[NEWER];
          }
          entry[NEWER][OLDER] = entry[OLDER];
        }
        if (entry[OLDER]) {
          entry[OLDER][NEWER] = entry[NEWER];
        }
        entry[NEWER] = void 0;
        entry[OLDER] = this.newest;
        if (this.newest) {
          this.newest[NEWER] = entry;
        }
        this.newest = entry;
      };
      LRUMap.prototype.assign = function(entries) {
        let entry, limit = this.limit || Number.MAX_VALUE;
        this._keymap.clear();
        let it = entries[Symbol.iterator]();
        for (let itv = it.next(); !itv.done; itv = it.next()) {
          let e2 = new Entry(itv.value[0], itv.value[1]);
          this._keymap.set(e2.key, e2);
          if (!entry) {
            this.oldest = e2;
          } else {
            entry[NEWER] = e2;
            e2[OLDER] = entry;
          }
          entry = e2;
          if (limit-- == 0) {
            throw new Error("overflow");
          }
        }
        this.newest = entry;
        this.size = this._keymap.size;
      };
      LRUMap.prototype.get = function(key) {
        var entry = this._keymap.get(key);
        if (!entry)
          return;
        this._markEntryAsUsed(entry);
        return entry.value;
      };
      LRUMap.prototype.set = function(key, value) {
        var entry = this._keymap.get(key);
        if (entry) {
          entry.value = value;
          this._markEntryAsUsed(entry);
          return this;
        }
        this._keymap.set(key, entry = new Entry(key, value));
        if (this.newest) {
          this.newest[NEWER] = entry;
          entry[OLDER] = this.newest;
        } else {
          this.oldest = entry;
        }
        this.newest = entry;
        ++this.size;
        if (this.size > this.limit) {
          this.shift();
        }
        return this;
      };
      LRUMap.prototype.shift = function() {
        var entry = this.oldest;
        if (entry) {
          if (this.oldest[NEWER]) {
            this.oldest = this.oldest[NEWER];
            this.oldest[OLDER] = void 0;
          } else {
            this.oldest = void 0;
            this.newest = void 0;
          }
          entry[NEWER] = entry[OLDER] = void 0;
          this._keymap.delete(entry.key);
          --this.size;
          return [entry.key, entry.value];
        }
      };
      LRUMap.prototype.find = function(key) {
        let e2 = this._keymap.get(key);
        return e2 ? e2.value : void 0;
      };
      LRUMap.prototype.has = function(key) {
        return this._keymap.has(key);
      };
      LRUMap.prototype["delete"] = function(key) {
        var entry = this._keymap.get(key);
        if (!entry)
          return;
        this._keymap.delete(entry.key);
        if (entry[NEWER] && entry[OLDER]) {
          entry[OLDER][NEWER] = entry[NEWER];
          entry[NEWER][OLDER] = entry[OLDER];
        } else if (entry[NEWER]) {
          entry[NEWER][OLDER] = void 0;
          this.oldest = entry[NEWER];
        } else if (entry[OLDER]) {
          entry[OLDER][NEWER] = void 0;
          this.newest = entry[OLDER];
        } else {
          this.oldest = this.newest = void 0;
        }
        this.size--;
        return entry.value;
      };
      LRUMap.prototype.clear = function() {
        this.oldest = this.newest = void 0;
        this.size = 0;
        this._keymap.clear();
      };
      function EntryIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      EntryIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      EntryIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: [ent.key, ent.value] };
        } else {
          return { done: true, value: void 0 };
        }
      };
      function KeyIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      KeyIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      KeyIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: ent.key };
        } else {
          return { done: true, value: void 0 };
        }
      };
      function ValueIterator(oldestEntry) {
        this.entry = oldestEntry;
      }
      ValueIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
      ValueIterator.prototype.next = function() {
        let ent = this.entry;
        if (ent) {
          this.entry = ent[NEWER];
          return { done: false, value: ent.value };
        } else {
          return { done: true, value: void 0 };
        }
      };
      LRUMap.prototype.keys = function() {
        return new KeyIterator(this.oldest);
      };
      LRUMap.prototype.values = function() {
        return new ValueIterator(this.oldest);
      };
      LRUMap.prototype.entries = function() {
        return this;
      };
      LRUMap.prototype[Symbol.iterator] = function() {
        return new EntryIterator(this.oldest);
      };
      LRUMap.prototype.forEach = function(fun, thisObj) {
        if (typeof thisObj !== "object") {
          thisObj = this;
        }
        let entry = this.oldest;
        while (entry) {
          fun.call(thisObj, entry.value, entry.key, this);
          entry = entry[NEWER];
        }
      };
      LRUMap.prototype.toJSON = function() {
        var s2 = new Array(this.size), i2 = 0, entry = this.oldest;
        while (entry) {
          s2[i2++] = { key: entry.key, value: entry.value };
          entry = entry[NEWER];
        }
        return s2;
      };
      LRUMap.prototype.toString = function() {
        var s2 = "", entry = this.oldest;
        while (entry) {
          s2 += String(entry.key) + ":" + entry.value;
          entry = entry[NEWER];
          if (entry) {
            s2 += " < ";
          }
        }
        return s2;
      };
    });
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/utils/http.js
var require_http2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/utils/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var url = __require("url");
    var nodeVersion = require_nodeVersion();
    function isSentryRequest(url2) {
      const dsn = _optionalChain([core.getCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getDsn, "call", (_5) => _5()]);
      return dsn ? url2.includes(dsn.host) : false;
    }
    function extractRawUrl(requestOptions) {
      const protocol = requestOptions.protocol || "";
      const hostname = requestOptions.hostname || requestOptions.host || "";
      const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? "" : `:${requestOptions.port}`;
      const path4 = requestOptions.path ? requestOptions.path : "/";
      return `${protocol}//${hostname}${port}${path4}`;
    }
    function extractUrl(requestOptions) {
      const protocol = requestOptions.protocol || "";
      const hostname = requestOptions.hostname || requestOptions.host || "";
      const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? "" : `:${requestOptions.port}`;
      const path4 = requestOptions.pathname || "/";
      const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : "";
      return `${protocol}//${authority}${hostname}${port}${path4}`;
    }
    function redactAuthority(auth) {
      const [user, password] = auth.split(":");
      return `${user ? "[Filtered]" : ""}:${password ? "[Filtered]" : ""}@`;
    }
    function cleanSpanDescription(description, requestOptions, request) {
      if (!description) {
        return description;
      }
      let [method, requestUrl] = description.split(" ");
      if (requestOptions.host && !requestOptions.protocol) {
        requestOptions.protocol = _optionalChain([request, "optionalAccess", (_6) => _6.agent, "optionalAccess", (_7) => _7.protocol]);
        requestUrl = extractUrl(requestOptions);
      }
      if (_optionalChain([requestUrl, "optionalAccess", (_8) => _8.startsWith, "call", (_9) => _9("///")])) {
        requestUrl = requestUrl.slice(2);
      }
      return `${method} ${requestUrl}`;
    }
    function urlToOptions(url2) {
      const options = {
        protocol: url2.protocol,
        hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname || ""}${url2.search || ""}`,
        href: url2.href
      };
      if (url2.port !== "") {
        options.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options.auth = `${url2.username}:${url2.password}`;
      }
      return options;
    }
    function normalizeRequestArgs(httpModule, requestArgs) {
      let callback, requestOptions;
      if (typeof requestArgs[requestArgs.length - 1] === "function") {
        callback = requestArgs.pop();
      }
      if (typeof requestArgs[0] === "string") {
        requestOptions = urlToOptions(new url.URL(requestArgs[0]));
      } else if (requestArgs[0] instanceof url.URL) {
        requestOptions = urlToOptions(requestArgs[0]);
      } else {
        requestOptions = requestArgs[0];
      }
      if (requestArgs.length === 2) {
        requestOptions = { ...requestOptions, ...requestArgs[1] };
      }
      if (requestOptions.protocol === void 0) {
        if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major > 8) {
          requestOptions.protocol = _optionalChain([_optionalChain([httpModule, "optionalAccess", (_10) => _10.globalAgent]), "optionalAccess", (_11) => _11.protocol]) || _optionalChain([requestOptions.agent, "optionalAccess", (_12) => _12.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_13) => _13.protocol]);
        } else {
          requestOptions.protocol = _optionalChain([requestOptions.agent, "optionalAccess", (_14) => _14.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_15) => _15.protocol]) || _optionalChain([_optionalChain([httpModule, "optionalAccess", (_16) => _16.globalAgent]), "optionalAccess", (_17) => _17.protocol]);
        }
      }
      if (callback) {
        return [requestOptions, callback];
      } else {
        return [requestOptions];
      }
    }
    exports.cleanSpanDescription = cleanSpanDescription;
    exports.extractRawUrl = extractRawUrl;
    exports.extractUrl = extractUrl;
    exports.isSentryRequest = isSentryRequest;
    exports.normalizeRequestArgs = normalizeRequestArgs;
    exports.urlToOptions = urlToOptions;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/http.js
var require_http3 = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var lru_map = require_lru();
    var nodeVersion = require_nodeVersion();
    var http3 = require_http2();
    var Http = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Http";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Http.id;
      }
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        Http.prototype.__init.call(this);
        this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
        this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
      }
      /**
       * @inheritDoc
       */
      setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
        if (!this._breadcrumbs && !this._tracing) {
          return;
        }
        const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
        if (clientOptions && clientOptions.instrumenter !== "sentry") {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log("HTTP Integration is skipped because of instrumenter configuration.");
          return;
        }
        const tracingOptions = this._tracing ? { ...clientOptions, ...this._tracing } : void 0;
        const httpModule = __require("http");
        const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, tracingOptions, httpModule);
        utils.fill(httpModule, "get", wrappedHttpHandlerMaker);
        utils.fill(httpModule, "request", wrappedHttpHandlerMaker);
        if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major > 8) {
          const httpsModule = __require("https");
          const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
            this._breadcrumbs,
            tracingOptions,
            httpsModule
          );
          utils.fill(httpsModule, "get", wrappedHttpsHandlerMaker);
          utils.fill(httpsModule, "request", wrappedHttpsHandlerMaker);
        }
      }
    };
    Http.__initStatic();
    function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingOptions, httpModule) {
      const createSpanUrlMap = new lru_map.LRUMap(100);
      const headersUrlMap = {};
      const shouldCreateSpan = (url) => {
        if (_optionalChain([tracingOptions, "optionalAccess", (_6) => _6.shouldCreateSpanForRequest]) === void 0) {
          return true;
        }
        const cachedDecision = createSpanUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = tracingOptions.shouldCreateSpanForRequest(url);
        createSpanUrlMap.set(url, decision);
        return decision;
      };
      const shouldAttachTraceData = (url) => {
        if (_optionalChain([tracingOptions, "optionalAccess", (_7) => _7.tracePropagationTargets]) === void 0) {
          return true;
        }
        if (headersUrlMap[url]) {
          return headersUrlMap[url];
        }
        headersUrlMap[url] = utils.stringMatchesSomePattern(url, tracingOptions.tracePropagationTargets);
        return headersUrlMap[url];
      };
      return function wrappedRequestMethodFactory(originalRequestMethod) {
        return function wrappedMethod(...args) {
          const requestArgs = http3.normalizeRequestArgs(httpModule, args);
          const requestOptions = requestArgs[0];
          const rawRequestUrl = http3.extractRawUrl(requestOptions);
          const requestUrl = http3.extractUrl(requestOptions);
          if (http3.isSentryRequest(requestUrl)) {
            return originalRequestMethod.apply(httpModule, requestArgs);
          }
          let requestSpan;
          let parentSpan;
          const scope = core.getCurrentHub().getScope();
          const method = requestOptions.method || "GET";
          const requestSpanData = {
            url: requestUrl,
            "http.method": method
          };
          if (requestOptions.hash) {
            requestSpanData["http.fragment"] = requestOptions.hash.substring(1);
          }
          if (requestOptions.search) {
            requestSpanData["http.query"] = requestOptions.search.substring(1);
          }
          if (scope && tracingOptions && shouldCreateSpan(rawRequestUrl)) {
            parentSpan = scope.getSpan();
            if (parentSpan) {
              requestSpan = parentSpan.startChild({
                description: `${method} ${requestSpanData.url}`,
                op: "http.client",
                data: requestSpanData
              });
              if (shouldAttachTraceData(rawRequestUrl)) {
                const sentryTraceHeader = requestSpan.toTraceparent();
                (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
                  `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `
                );
                requestOptions.headers = {
                  ...requestOptions.headers,
                  "sentry-trace": sentryTraceHeader
                };
                if (parentSpan.transaction) {
                  const dynamicSamplingContext = parentSpan.transaction.getDynamicSamplingContext();
                  const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
                  let newBaggageHeaderField;
                  if (!requestOptions.headers || !requestOptions.headers.baggage) {
                    newBaggageHeaderField = sentryBaggageHeader;
                  } else if (!sentryBaggageHeader) {
                    newBaggageHeaderField = requestOptions.headers.baggage;
                  } else if (Array.isArray(requestOptions.headers.baggage)) {
                    newBaggageHeaderField = [...requestOptions.headers.baggage, sentryBaggageHeader];
                  } else {
                    newBaggageHeaderField = [requestOptions.headers.baggage, sentryBaggageHeader];
                  }
                  requestOptions.headers = {
                    ...requestOptions.headers,
                    // Setting a hader to `undefined` will crash in node so we only set the baggage header when it's defined
                    ...newBaggageHeaderField && { baggage: newBaggageHeaderField }
                  };
                }
              } else {
                (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.log(
                  `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
                );
              }
            }
          }
          return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
            const req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("response", requestSpanData, req, res);
            }
            if (requestSpan) {
              if (res.statusCode) {
                requestSpan.setHttpStatus(res.statusCode);
              }
              requestSpan.description = http3.cleanSpanDescription(requestSpan.description, requestOptions, req);
              requestSpan.finish();
            }
          }).once("error", function() {
            const req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("error", requestSpanData, req);
            }
            if (requestSpan) {
              requestSpan.setHttpStatus(500);
              requestSpan.description = http3.cleanSpanDescription(requestSpan.description, requestOptions, req);
              requestSpan.finish();
            }
          });
        };
      };
    }
    function addRequestBreadcrumb(event, requestSpanData, req, res) {
      if (!core.getCurrentHub().getIntegration(Http)) {
        return;
      }
      core.getCurrentHub().addBreadcrumb(
        {
          category: "http",
          data: {
            status_code: res && res.statusCode,
            ...requestSpanData
          },
          type: "http"
        },
        {
          event,
          request: req,
          response: res
        }
      );
    }
    exports.Http = Http;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/utils/errorhandling.js
var require_errorhandling = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/utils/errorhandling.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
    function logAndExitProcess(error) {
      console.error(error && error.stack ? error.stack : error);
      const client = core.getCurrentHub().getClient();
      if (client === void 0) {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("No NodeClient was defined, we are exiting the process now.");
        global.process.exit(1);
      }
      const options = client.getOptions();
      const timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
      client.close(timeout).then(
        (result) => {
          if (!result) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
          }
          global.process.exit(1);
        },
        (error2) => {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(error2);
        }
      );
    }
    exports.logAndExitProcess = logAndExitProcess;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/onuncaughtexception.js
var require_onuncaughtexception = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/onuncaughtexception.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var errorhandling = require_errorhandling();
    var OnUncaughtException = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "OnUncaughtException";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = OnUncaughtException.id;
      }
      /**
       * @inheritDoc
       */
      __init2() {
        this.handler = this._makeErrorHandler();
      }
      // CAREFUL: Please think twice before updating the way _options looks because the Next.js SDK depends on it in `index.server.ts`
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        OnUncaughtException.prototype.__init.call(this);
        OnUncaughtException.prototype.__init2.call(this);
        this._options = {
          exitEvenIfOtherHandlersAreRegistered: true,
          ...options
        };
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
        global.process.on("uncaughtException", this.handler);
      }
      /**
       * @hidden
       */
      _makeErrorHandler() {
        const timeout = 2e3;
        let caughtFirstError = false;
        let caughtSecondError = false;
        let calledFatalError = false;
        let firstError;
        return (error) => {
          let onFatalError = errorhandling.logAndExitProcess;
          const client = core.getCurrentHub().getClient();
          if (this._options.onFatalError) {
            onFatalError = this._options.onFatalError;
          } else if (client && client.getOptions().onFatalError) {
            onFatalError = client.getOptions().onFatalError;
          }
          const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
            if (
              // There are 3 listeners we ignore:
              listener.name === "domainUncaughtExceptionClear" || // as soon as we're using domains this listener is attached by node itself
              listener.tag && listener.tag === "sentry_tracingErrorCallback" || // the handler we register for tracing
              listener === this.handler
            ) {
              return acc;
            } else {
              return acc + 1;
            }
          }, 0);
          const processWouldExit = userProvidedListenersCount === 0;
          const shouldApplyFatalHandlingLogic = this._options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
          if (!caughtFirstError) {
            const hub = core.getCurrentHub();
            firstError = error;
            caughtFirstError = true;
            if (hub.getIntegration(OnUncaughtException)) {
              hub.withScope((scope) => {
                scope.setLevel("fatal");
                hub.captureException(error, {
                  originalException: error,
                  data: { mechanism: { handled: false, type: "onuncaughtexception" } }
                });
                if (!calledFatalError && shouldApplyFatalHandlingLogic) {
                  calledFatalError = true;
                  onFatalError(error);
                }
              });
            } else {
              if (!calledFatalError && shouldApplyFatalHandlingLogic) {
                calledFatalError = true;
                onFatalError(error);
              }
            }
          } else {
            if (shouldApplyFatalHandlingLogic) {
              if (calledFatalError) {
                (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
                  "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
                );
                errorhandling.logAndExitProcess(error);
              } else if (!caughtSecondError) {
                caughtSecondError = true;
                setTimeout(() => {
                  if (!calledFatalError) {
                    calledFatalError = true;
                    onFatalError(firstError, error);
                  }
                }, timeout);
              }
            }
          }
        };
      }
    };
    OnUncaughtException.__initStatic();
    exports.OnUncaughtException = OnUncaughtException;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/onunhandledrejection.js
var require_onunhandledrejection = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/onunhandledrejection.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var errorhandling = require_errorhandling();
    var OnUnhandledRejection = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "OnUnhandledRejection";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = OnUnhandledRejection.id;
      }
      /**
       * @inheritDoc
       */
      constructor(_options = { mode: "warn" }) {
        this._options = _options;
        OnUnhandledRejection.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
        global.process.on("unhandledRejection", this.sendUnhandledPromise.bind(this));
      }
      /**
       * Send an exception with reason
       * @param reason string
       * @param promise promise
       */
      sendUnhandledPromise(reason, promise) {
        const hub = core.getCurrentHub();
        if (hub.getIntegration(OnUnhandledRejection)) {
          hub.withScope((scope) => {
            scope.setExtra("unhandledPromiseRejection", true);
            hub.captureException(reason, {
              originalException: promise,
              data: { mechanism: { handled: false, type: "onunhandledrejection" } }
            });
          });
        }
        this._handleRejection(reason);
      }
      /**
       * Handler for `mode` option
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _handleRejection(reason) {
        const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
        if (this._options.mode === "warn") {
          utils.consoleSandbox(() => {
            console.warn(rejectionWarning);
            console.error(reason && reason.stack ? reason.stack : reason);
          });
        } else if (this._options.mode === "strict") {
          utils.consoleSandbox(() => {
            console.warn(rejectionWarning);
          });
          errorhandling.logAndExitProcess(reason);
        }
      }
    };
    OnUnhandledRejection.__initStatic();
    exports.OnUnhandledRejection = OnUnhandledRejection;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/contextlines.js
var require_contextlines = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/contextlines.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var fs7 = __require("fs");
    var lru_map = require_lru();
    var FILE_CONTENT_CACHE = new lru_map.LRUMap(100);
    var DEFAULT_LINES_OF_CONTEXT = 7;
    function readTextFileAsync(path4) {
      return new Promise((resolve2, reject) => {
        fs7.readFile(path4, "utf8", (err, data) => {
          if (err)
            reject(err);
          else
            resolve2(data);
        });
      });
    }
    var ContextLines = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "ContextLines";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = ContextLines.id;
      }
      constructor(_options = {}) {
        this._options = _options;
        ContextLines.prototype.__init.call(this);
      }
      /** Get's the number of context lines to add */
      get _contextLines() {
        return this._options.frameContextLines !== void 0 ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor) {
        addGlobalEventProcessor((event) => this.addSourceContext(event));
      }
      /** Processes an event and adds context lines */
      async addSourceContext(event) {
        const enqueuedReadSourceFileTasks = {};
        const readSourceFileTasks = [];
        if (this._contextLines > 0 && _optionalChain([event, "access", (_2) => _2.exception, "optionalAccess", (_3) => _3.values])) {
          for (const exception of event.exception.values) {
            if (!_optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
              continue;
            }
            for (let i2 = exception.stacktrace.frames.length - 1; i2 >= 0; i2--) {
              const frame = exception.stacktrace.frames[i2];
              if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
                readSourceFileTasks.push(_readSourceFile(frame.filename));
                enqueuedReadSourceFileTasks[frame.filename] = 1;
              }
            }
          }
        }
        if (readSourceFileTasks.length > 0) {
          await Promise.all(readSourceFileTasks);
        }
        if (this._contextLines > 0 && _optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
          for (const exception of event.exception.values) {
            if (exception.stacktrace && exception.stacktrace.frames) {
              await this.addSourceContextToFrames(exception.stacktrace.frames);
            }
          }
        }
        return event;
      }
      /** Adds context lines to frames */
      addSourceContextToFrames(frames) {
        for (const frame of frames) {
          if (frame.filename && frame.context_line === void 0) {
            const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
            if (sourceFileLines) {
              try {
                utils.addContextToFrame(sourceFileLines, frame, this._contextLines);
              } catch (e2) {
              }
            }
          }
        }
      }
    };
    ContextLines.__initStatic();
    async function _readSourceFile(filename) {
      const cachedFile = FILE_CONTENT_CACHE.get(filename);
      if (cachedFile === null) {
        return null;
      }
      if (cachedFile !== void 0) {
        return cachedFile;
      }
      let content = null;
      try {
        const rawFileContents = await readTextFileAsync(filename);
        content = rawFileContents.split("\n");
      } catch (_) {
      }
      FILE_CONTENT_CACHE.set(filename, content);
      return content;
    }
    exports.ContextLines = ContextLines;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/linkederrors.js
var require_linkederrors = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/linkederrors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var eventbuilder = require_eventbuilder();
    var contextlines = require_contextlines();
    var DEFAULT_KEY = "cause";
    var DEFAULT_LIMIT = 5;
    var LinkedErrors = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "LinkedErrors";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = LinkedErrors.id;
      }
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        LinkedErrors.prototype.__init.call(this);
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
        core.addGlobalEventProcessor(async (event, hint) => {
          const hub = core.getCurrentHub();
          const self2 = hub.getIntegration(LinkedErrors);
          const client = hub.getClient();
          if (client && self2 && self2._handler && typeof self2._handler === "function") {
            await self2._handler(client.getOptions().stackParser, event, hint);
          }
          return event;
        });
      }
      /**
       * @inheritDoc
       */
      _handler(stackParser, event, hint) {
        if (!event.exception || !event.exception.values || !utils.isInstanceOf(hint.originalException, Error)) {
          return utils.resolvedSyncPromise(event);
        }
        return new utils.SyncPromise((resolve2) => {
          void this._walkErrorTree(stackParser, hint.originalException, this._key).then((linkedErrors) => {
            if (event && event.exception && event.exception.values) {
              event.exception.values = [...linkedErrors, ...event.exception.values];
            }
            resolve2(event);
          }).then(null, () => {
            resolve2(event);
          });
        });
      }
      /**
       * @inheritDoc
       */
      async _walkErrorTree(stackParser, error, key, stack = []) {
        if (!utils.isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
          return Promise.resolve(stack);
        }
        const exception = eventbuilder.exceptionFromError(stackParser, error[key]);
        const contextLines = core.getCurrentHub().getIntegration(contextlines.ContextLines);
        if (contextLines && _optionalChain([exception, "access", (_) => _.stacktrace, "optionalAccess", (_2) => _2.frames])) {
          await contextLines.addSourceContextToFrames(exception.stacktrace.frames);
        }
        return new Promise((resolve2, reject) => {
          void this._walkErrorTree(stackParser, error[key], key, [exception, ...stack]).then(resolve2).then(null, () => {
            reject();
          });
        });
      }
    };
    LinkedErrors.__initStatic();
    exports.LinkedErrors = LinkedErrors;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/modules.js
var require_modules = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/modules.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs7 = __require("fs");
    var path4 = __require("path");
    var moduleCache;
    function getPaths() {
      try {
        return __require.cache ? Object.keys(__require.cache) : [];
      } catch (e2) {
        return [];
      }
    }
    function collectModules() {
      const mainPaths = __require.main && __require.main.paths || [];
      const paths = getPaths();
      const infos = {};
      const seen = {};
      paths.forEach((path$1) => {
        let dir = path$1;
        const updir = () => {
          const orig = dir;
          dir = path4.dirname(orig);
          if (!dir || orig === dir || seen[orig]) {
            return void 0;
          }
          if (mainPaths.indexOf(dir) < 0) {
            return updir();
          }
          const pkgfile = path4.join(orig, "package.json");
          seen[orig] = true;
          if (!fs7.existsSync(pkgfile)) {
            return updir();
          }
          try {
            const info = JSON.parse(fs7.readFileSync(pkgfile, "utf8"));
            infos[info.name] = info.version;
          } catch (_oO) {
          }
        };
        updir();
      });
      return infos;
    }
    var Modules = class {
      constructor() {
        Modules.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Modules";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Modules.id;
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor((event) => {
          if (!getCurrentHub().getIntegration(Modules)) {
            return event;
          }
          return {
            ...event,
            modules: {
              ...event.modules,
              ...this._getModules()
            }
          };
        });
      }
      /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
      _getModules() {
        if (!moduleCache) {
          moduleCache = collectModules();
        }
        return moduleCache;
      }
    };
    Modules.__initStatic();
    exports.Modules = Modules;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/context.js
var require_context = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/context.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var child_process = __require("child_process");
    var fs7 = __require("fs");
    var os = __require("os");
    var path4 = __require("path");
    var util2 = __require("util");
    var readFileAsync = util2.promisify(fs7.readFile);
    var readDirAsync = util2.promisify(fs7.readdir);
    var Context = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Context";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Context.id;
      }
      /**
       * Caches context so it's only evaluated once
       */
      constructor(_options = { app: true, os: true, device: true, culture: true }) {
        this._options = _options;
        Context.prototype.__init.call(this);
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor) {
        addGlobalEventProcessor((event) => this.addContext(event));
      }
      /** Processes an event and adds context */
      async addContext(event) {
        if (this._cachedContext === void 0) {
          this._cachedContext = this._getContexts();
        }
        const updatedContext = this._updateContext(await this._cachedContext);
        event.contexts = {
          ...event.contexts,
          app: { ...updatedContext.app, ..._optionalChain([event, "access", (_) => _.contexts, "optionalAccess", (_2) => _2.app]) },
          os: { ...updatedContext.os, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_4) => _4.os]) },
          device: { ...updatedContext.device, ..._optionalChain([event, "access", (_5) => _5.contexts, "optionalAccess", (_6) => _6.device]) },
          culture: { ...updatedContext.culture, ..._optionalChain([event, "access", (_7) => _7.contexts, "optionalAccess", (_8) => _8.culture]) }
        };
        return event;
      }
      /**
       * Updates the context with dynamic values that can change
       */
      _updateContext(contexts) {
        if (_optionalChain([contexts, "optionalAccess", (_9) => _9.app, "optionalAccess", (_10) => _10.app_memory])) {
          contexts.app.app_memory = process.memoryUsage().rss;
        }
        if (_optionalChain([contexts, "optionalAccess", (_11) => _11.device, "optionalAccess", (_12) => _12.free_memory])) {
          contexts.device.free_memory = os.freemem();
        }
        return contexts;
      }
      /**
       * Gets the contexts for the current environment
       */
      async _getContexts() {
        const contexts = {};
        if (this._options.os) {
          contexts.os = await getOsContext();
        }
        if (this._options.app) {
          contexts.app = getAppContext();
        }
        if (this._options.device) {
          contexts.device = getDeviceContext(this._options.device);
        }
        if (this._options.culture) {
          const culture = getCultureContext();
          if (culture) {
            contexts.culture = culture;
          }
        }
        return contexts;
      }
    };
    Context.__initStatic();
    async function getOsContext() {
      const platformId = os.platform();
      switch (platformId) {
        case "darwin":
          return getDarwinInfo();
        case "linux":
          return getLinuxInfo();
        default:
          return {
            name: PLATFORM_NAMES[platformId] || platformId,
            version: os.release()
          };
      }
    }
    function getCultureContext() {
      try {
        if (typeof process.versions.icu !== "string") {
          return;
        }
        const january = /* @__PURE__ */ new Date(9e8);
        const spanish = new Intl.DateTimeFormat("es", { month: "long" });
        if (spanish.format(january) === "enero") {
          const options = Intl.DateTimeFormat().resolvedOptions();
          return {
            locale: options.locale,
            timezone: options.timeZone
          };
        }
      } catch (err) {
      }
      return;
    }
    function getAppContext() {
      const app_memory = process.memoryUsage().rss;
      const app_start_time = new Date(Date.now() - process.uptime() * 1e3).toISOString();
      return { app_start_time, app_memory };
    }
    function getDeviceContext(deviceOpt) {
      const device = {};
      const uptime = os.uptime && os.uptime();
      if (typeof uptime === "number") {
        device.boot_time = new Date(Date.now() - uptime * 1e3).toISOString();
      }
      device.arch = os.arch();
      if (deviceOpt === true || deviceOpt.memory) {
        device.memory_size = os.totalmem();
        device.free_memory = os.freemem();
      }
      if (deviceOpt === true || deviceOpt.cpu) {
        const cpuInfo = os.cpus();
        if (cpuInfo && cpuInfo.length) {
          const firstCpu = cpuInfo[0];
          device.processor_count = cpuInfo.length;
          device.cpu_description = firstCpu.model;
          device.processor_frequency = firstCpu.speed;
        }
      }
      return device;
    }
    var PLATFORM_NAMES = {
      aix: "IBM AIX",
      freebsd: "FreeBSD",
      openbsd: "OpenBSD",
      sunos: "SunOS",
      win32: "Windows"
    };
    var LINUX_DISTROS = [
      { name: "fedora-release", distros: ["Fedora"] },
      { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
      { name: "redhat_version", distros: ["Red Hat Linux"] },
      { name: "SuSE-release", distros: ["SUSE Linux"] },
      { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
      { name: "debian_version", distros: ["Debian"] },
      { name: "debian_release", distros: ["Debian"] },
      { name: "arch-release", distros: ["Arch Linux"] },
      { name: "gentoo-release", distros: ["Gentoo Linux"] },
      { name: "novell-release", distros: ["SUSE Linux"] },
      { name: "alpine-release", distros: ["Alpine Linux"] }
    ];
    var LINUX_VERSIONS = {
      alpine: (content) => content,
      arch: (content) => matchFirst(/distrib_release=(.*)/, content),
      centos: (content) => matchFirst(/release ([^ ]+)/, content),
      debian: (content) => content,
      fedora: (content) => matchFirst(/release (..)/, content),
      mint: (content) => matchFirst(/distrib_release=(.*)/, content),
      red: (content) => matchFirst(/release ([^ ]+)/, content),
      suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
      ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
    };
    function matchFirst(regex, text) {
      const match = regex.exec(text);
      return match ? match[1] : void 0;
    }
    async function getDarwinInfo() {
      const darwinInfo = {
        kernel_version: os.release(),
        name: "Mac OS X",
        version: `10.${Number(os.release().split(".")[0]) - 4}`
      };
      try {
        const output = await new Promise((resolve2, reject) => {
          child_process.execFile("/usr/bin/sw_vers", (error, stdout) => {
            if (error) {
              reject(error);
              return;
            }
            resolve2(stdout);
          });
        });
        darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
        darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
        darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
      } catch (e2) {
      }
      return darwinInfo;
    }
    function getLinuxDistroId(name) {
      return name.split(" ")[0].toLowerCase();
    }
    async function getLinuxInfo() {
      const linuxInfo = {
        kernel_version: os.release(),
        name: "Linux"
      };
      try {
        const etcFiles = await readDirAsync("/etc");
        const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
        if (!distroFile) {
          return linuxInfo;
        }
        const distroPath = path4.join("/etc", distroFile.name);
        const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
        const { distros } = distroFile;
        linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
        const id = getLinuxDistroId(linuxInfo.name);
        linuxInfo.version = LINUX_VERSIONS[id](contents);
      } catch (e2) {
      }
      return linuxInfo;
    }
    exports.Context = Context;
    exports.getDeviceContext = getDeviceContext;
    exports.readDirAsync = readDirAsync;
    exports.readFileAsync = readFileAsync;
  }
});

// ../../node_modules/@sentry/node/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "../../node_modules/@sentry/node/node_modules/cookie/index.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode2 = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i2 = 0; i2 < pairs.length; i2++) {
        var pair = pairs[i2];
        var index = pair.indexOf("=");
        if (index < 0) {
          continue;
        }
        var key = pair.substring(0, index).trim();
        if (void 0 == obj[key]) {
          var val = pair.substring(index + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode2;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e2) {
        return str;
      }
    }
  }
});

// ../../node_modules/@sentry/node/cjs/requestdata.js
var require_requestdata2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/requestdata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var cookie = require_cookie();
    var url = __require("url");
    var DEFAULT_INCLUDES = {
      ip: false,
      request: true,
      transaction: true,
      user: true
    };
    var DEFAULT_REQUEST_INCLUDES = ["cookies", "data", "headers", "method", "query_string", "url"];
    var DEFAULT_USER_INCLUDES = ["id", "username", "email"];
    function extractPathForTransaction(req, options = {}) {
      const method = req.method && req.method.toUpperCase();
      let path4 = "";
      let source = "url";
      if (options.customRoute || req.route) {
        path4 = options.customRoute || `${req.baseUrl || ""}${req.route && req.route.path}`;
        source = "route";
      } else if (req.originalUrl || req.url) {
        path4 = utils.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
      }
      let name = "";
      if (options.method && method) {
        name += method;
      }
      if (options.method && options.path) {
        name += " ";
      }
      if (options.path && path4) {
        name += path4;
      }
      return [name, source];
    }
    function extractTransaction(req, type) {
      switch (type) {
        case "path": {
          return extractPathForTransaction(req, { path: true })[0];
        }
        case "handler": {
          return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || "<anonymous>";
        }
        case "methodPath":
        default: {
          return extractPathForTransaction(req, { path: true, method: true })[0];
        }
      }
    }
    function extractUserData(user, keys) {
      const extractedUser = {};
      const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;
      attributes.forEach((key) => {
        if (user && key in user) {
          extractedUser[key] = user[key];
        }
      });
      return extractedUser;
    }
    function extractRequestData(req, options) {
      const { include = DEFAULT_REQUEST_INCLUDES } = options || {};
      const requestData = {};
      const headers = req.headers || {};
      const method = req.method;
      const host = req.hostname || req.host || headers.host || "<no host>";
      const protocol = req.protocol === "https" || req.socket && req.socket.encrypted ? "https" : "http";
      const originalUrl = req.originalUrl || req.url || "";
      const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;
      include.forEach((key) => {
        switch (key) {
          case "headers": {
            requestData.headers = headers;
            if (!include.includes("cookies")) {
              delete requestData.headers.cookie;
            }
            break;
          }
          case "method": {
            requestData.method = method;
            break;
          }
          case "url": {
            requestData.url = absoluteUrl;
            break;
          }
          case "cookies": {
            requestData.cookies = // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can
            // come off in v8
            req.cookies || headers.cookie && cookie.parse(headers.cookie) || {};
            break;
          }
          case "query_string": {
            requestData.query_string = extractQueryParams(req);
            break;
          }
          case "data": {
            if (method === "GET" || method === "HEAD") {
              break;
            }
            if (req.body !== void 0) {
              requestData.data = utils.isString(req.body) ? req.body : JSON.stringify(utils.normalize(req.body));
            }
            break;
          }
          default: {
            if ({}.hasOwnProperty.call(req, key)) {
              requestData[key] = req[key];
            }
          }
        }
      });
      return requestData;
    }
    function addRequestDataToEvent(event, req, options) {
      const include = {
        ...DEFAULT_INCLUDES,
        ..._optionalChain([options, "optionalAccess", (_) => _.include])
      };
      if (include.request) {
        const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, { include: include.request }) : extractRequestData(req);
        event.request = {
          ...event.request,
          ...extractedRequestData
        };
      }
      if (include.user) {
        const extractedUser = req.user && utils.isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};
        if (Object.keys(extractedUser).length) {
          event.user = {
            ...event.user,
            ...extractedUser
          };
        }
      }
      if (include.ip) {
        const ip = req.ip || req.socket && req.socket.remoteAddress;
        if (ip) {
          event.user = {
            ...event.user,
            ip_address: ip
          };
        }
      }
      if (include.transaction && !event.transaction) {
        event.transaction = extractTransaction(req, include.transaction);
      }
      return event;
    }
    function extractQueryParams(req) {
      let originalUrl = req.originalUrl || req.url || "";
      if (!originalUrl) {
        return;
      }
      if (originalUrl.startsWith("/")) {
        originalUrl = `http://dogs.are.great${originalUrl}`;
      }
      return req.query || typeof URL !== void 0 && new URL(originalUrl).search.replace("?", "") || // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node
      url.parse(originalUrl).query || void 0;
    }
    exports.DEFAULT_USER_INCLUDES = DEFAULT_USER_INCLUDES;
    exports.addRequestDataToEvent = addRequestDataToEvent;
    exports.extractPathForTransaction = extractPathForTransaction;
    exports.extractRequestData = extractRequestData;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/requestdata.js
var require_requestdata3 = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/requestdata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var requestdata = require_requestdata2();
    var DEFAULT_OPTIONS = {
      include: {
        cookies: true,
        data: true,
        headers: true,
        ip: false,
        query_string: true,
        url: true,
        user: {
          id: true,
          username: true,
          email: true
        }
      },
      transactionNamingScheme: "methodPath"
    };
    var RequestData = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "RequestData";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = RequestData.id;
      }
      /**
       * Function for adding request data to event. Defaults to `addRequestDataToEvent` from `@sentry/node` for now, but
       * left as a property so this integration can be moved to `@sentry/core` as a base class in case we decide to use
       * something similar in browser-based SDKs in the future.
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        RequestData.prototype.__init.call(this);
        this._addRequestData = requestdata.addRequestDataToEvent;
        this._options = {
          ...DEFAULT_OPTIONS,
          ...options,
          include: {
            // @ts-ignore It's mad because `method` isn't a known `include` key. (It's only here and not set by default in
            // `addRequestDataToEvent` for legacy reasons. TODO (v8): Change that.)
            method: true,
            ...DEFAULT_OPTIONS.include,
            ...options.include,
            user: options.include && typeof options.include.user === "boolean" ? options.include.user : {
              ...DEFAULT_OPTIONS.include.user,
              // Unclear why TS still thinks `options.include.user` could be a boolean at this point
              ...(options.include || {}).user
            }
          }
        };
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor, getCurrentHub) {
        const { transactionNamingScheme } = this._options;
        addGlobalEventProcessor((event) => {
          const hub = getCurrentHub();
          const self2 = hub.getIntegration(RequestData);
          const { sdkProcessingMetadata = {} } = event;
          const req = sdkProcessingMetadata.request;
          if (!self2 || !req) {
            return event;
          }
          const addRequestDataOptions = sdkProcessingMetadata.requestDataOptionsFromExpressHandler || sdkProcessingMetadata.requestDataOptionsFromGCPWrapper || convertReqDataIntegrationOptsToAddReqDataOpts(this._options);
          const processedEvent = this._addRequestData(event, req, addRequestDataOptions);
          if (event.type === "transaction" || transactionNamingScheme === "handler") {
            return processedEvent;
          }
          const reqWithTransaction = req;
          const transaction = reqWithTransaction._sentryTransaction;
          if (transaction) {
            const shouldIncludeMethodInTransactionName = getSDKName(hub) === "sentry.javascript.nextjs" ? transaction.name.startsWith("/api") : transactionNamingScheme !== "path";
            const [transactionValue] = utils.extractPathForTransaction(req, {
              path: true,
              method: shouldIncludeMethodInTransactionName,
              customRoute: transaction.name
            });
            processedEvent.transaction = transactionValue;
          }
          return processedEvent;
        });
      }
    };
    RequestData.__initStatic();
    function convertReqDataIntegrationOptsToAddReqDataOpts(integrationOptions) {
      const {
        transactionNamingScheme,
        include: { ip, user, ...requestOptions }
      } = integrationOptions;
      const requestIncludeKeys = [];
      for (const [key, value] of Object.entries(requestOptions)) {
        if (value) {
          requestIncludeKeys.push(key);
        }
      }
      let addReqDataUserOpt;
      if (user === void 0) {
        addReqDataUserOpt = true;
      } else if (typeof user === "boolean") {
        addReqDataUserOpt = user;
      } else {
        const userIncludeKeys = [];
        for (const [key, value] of Object.entries(user)) {
          if (value) {
            userIncludeKeys.push(key);
          }
        }
        addReqDataUserOpt = userIncludeKeys;
      }
      return {
        include: {
          ip,
          user: addReqDataUserOpt,
          request: requestIncludeKeys.length !== 0 ? requestIncludeKeys : void 0,
          transaction: transactionNamingScheme
        }
      };
    }
    function getSDKName(hub) {
      try {
        return hub.getClient().getOptions()._metadata.sdk.name;
      } catch (err) {
        return void 0;
      }
    }
    exports.RequestData = RequestData;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/localvariables.js
var require_localvariables = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/localvariables.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var lru_map = require_lru();
    var nodeVersion = require_nodeVersion();
    function createCallbackList(complete) {
      let callbacks = [];
      let completedCalled = false;
      function checkedComplete(result) {
        callbacks = [];
        if (completedCalled) {
          return;
        }
        completedCalled = true;
        complete(result);
      }
      callbacks.push(checkedComplete);
      function add2(fn) {
        callbacks.push(fn);
      }
      function next(result) {
        const popped = callbacks.pop() || checkedComplete;
        try {
          popped(result);
        } catch (_) {
          checkedComplete(result);
        }
      }
      return { add: add2, next };
    }
    var AsyncSession = class {
      /** Throws if inspector API is not available */
      constructor() {
        const { Session } = __require("inspector");
        this._session = new Session();
      }
      /** @inheritdoc */
      configureAndConnect(onPause, captureAll) {
        this._session.connect();
        this._session.on("Debugger.paused", (event) => {
          onPause(event, () => {
            this._session.post("Debugger.resume");
          });
        });
        this._session.post("Debugger.enable");
        this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
      }
      /** @inheritdoc */
      getLocalVariables(objectId, complete) {
        this._getProperties(objectId, (props) => {
          const { add: add2, next } = createCallbackList(complete);
          for (const prop of props) {
            if (_optionalChain([prop, "optionalAccess", (_2) => _2.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
              const id = prop.value.objectId;
              add2((vars) => this._unrollArray(id, prop.name, vars, next));
            } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
              const id = prop.value.objectId;
              add2((vars) => this._unrollObject(id, prop.name, vars, next));
            } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value, "optionalAccess", (_11) => _11.value]) || _optionalChain([prop, "optionalAccess", (_12) => _12.value, "optionalAccess", (_13) => _13.description])) {
              add2((vars) => this._unrollOther(prop, vars, next));
            }
          }
          next({});
        });
      }
      /**
       * Gets all the PropertyDescriptors of an object
       */
      _getProperties(objectId, next) {
        this._session.post(
          "Runtime.getProperties",
          {
            objectId,
            ownProperties: true
          },
          (err, params) => {
            if (err) {
              next([]);
            } else {
              next(params.result);
            }
          }
        );
      }
      /**
       * Unrolls an array property
       */
      _unrollArray(objectId, name, vars, next) {
        this._getProperties(objectId, (props) => {
          vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_14) => _14.value, "optionalAccess", (_15) => _15.value]));
          next(vars);
        });
      }
      /**
       * Unrolls an object property
       */
      _unrollObject(objectId, name, vars, next) {
        this._getProperties(objectId, (props) => {
          vars[name] = props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_16) => _16.value, "optionalAccess", (_17) => _17.value])]).reduce((obj, [key, val]) => {
            obj[key] = val;
            return obj;
          }, {});
          next(vars);
        });
      }
      /**
       * Unrolls other properties
       */
      _unrollOther(prop, vars, next) {
        if (_optionalChain([prop, "optionalAccess", (_18) => _18.value, "optionalAccess", (_19) => _19.value])) {
          vars[prop.name] = prop.value.value;
        } else if (_optionalChain([prop, "optionalAccess", (_20) => _20.value, "optionalAccess", (_21) => _21.description]) && _optionalChain([prop, "optionalAccess", (_22) => _22.value, "optionalAccess", (_23) => _23.type]) !== "function") {
          vars[prop.name] = `<${prop.value.description}>`;
        }
        next(vars);
      }
    };
    function tryNewAsyncSession() {
      try {
        return new AsyncSession();
      } catch (e2) {
        return void 0;
      }
    }
    function isAnonymous(name) {
      return name !== void 0 && ["", "?", "<anonymous>"].includes(name);
    }
    function functionNamesMatch(a, b) {
      return a === b || isAnonymous(a) && isAnonymous(b);
    }
    function hashFrames(frames) {
      if (frames === void 0) {
        return;
      }
      return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
    }
    function hashFromStack(stackParser, stack) {
      if (stack === void 0) {
        return void 0;
      }
      return hashFrames(stackParser(stack, 1));
    }
    var LocalVariables = class {
      static __initStatic() {
        this.id = "LocalVariables";
      }
      __init() {
        this.name = LocalVariables.id;
      }
      __init2() {
        this._cachedFrames = new lru_map.LRUMap(20);
      }
      constructor(_options = {}, _session = tryNewAsyncSession()) {
        this._options = _options;
        this._session = _session;
        LocalVariables.prototype.__init.call(this);
        LocalVariables.prototype.__init2.call(this);
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor, getCurrentHub) {
        this._setup(addGlobalEventProcessor, _optionalChain([getCurrentHub, "call", (_24) => _24(), "access", (_25) => _25.getClient, "call", (_26) => _26(), "optionalAccess", (_27) => _27.getOptions, "call", (_28) => _28()]));
      }
      /** Setup in a way that's easier to call from tests */
      _setup(addGlobalEventProcessor, clientOptions) {
        if (this._session && _optionalChain([clientOptions, "optionalAccess", (_29) => _29.includeLocalVariables])) {
          const unsupportedNodeVersion = (nodeVersion.NODE_VERSION.major || 0) < 18;
          if (unsupportedNodeVersion) {
            utils.logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
            return;
          }
          this._session.configureAndConnect(
            (ev, complete) => this._handlePaused(clientOptions.stackParser, ev, complete),
            !!this._options.captureAllExceptions
          );
          addGlobalEventProcessor(async (event) => this._addLocalVariables(event));
        }
      }
      /**
       * Handle the pause event
       */
      _handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
        if (reason !== "exception" && reason !== "promiseRejection") {
          complete();
          return;
        }
        const exceptionHash = hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_30) => _30.description]));
        if (exceptionHash == void 0) {
          complete();
          return;
        }
        const { add: add2, next } = createCallbackList((frames) => {
          this._cachedFrames.set(exceptionHash, frames);
          complete();
        });
        for (let i2 = 0; i2 < Math.min(callFrames.length, 5); i2++) {
          const { scopeChain, functionName, this: obj } = callFrames[i2];
          const localScope = scopeChain.find((scope) => scope.type === "local");
          const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
          if (_optionalChain([localScope, "optionalAccess", (_31) => _31.object, "access", (_32) => _32.objectId]) === void 0) {
            add2((frames) => {
              frames[i2] = { function: fn };
              next(frames);
            });
          } else {
            const id = localScope.object.objectId;
            add2(
              (frames) => _optionalChain([this, "access", (_33) => _33._session, "optionalAccess", (_34) => _34.getLocalVariables, "call", (_35) => _35(id, (vars) => {
                frames[i2] = { function: fn, vars };
                next(frames);
              })])
            );
          }
        }
        next([]);
      }
      /**
       * Adds local variables event stack frames.
       */
      _addLocalVariables(event) {
        for (const exception of _optionalChain([event, "optionalAccess", (_36) => _36.exception, "optionalAccess", (_37) => _37.values]) || []) {
          this._addLocalVariablesToException(exception);
        }
        return event;
      }
      /**
       * Adds local variables to the exception stack frames.
       */
      _addLocalVariablesToException(exception) {
        const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_38) => _38.stacktrace, "optionalAccess", (_39) => _39.frames]));
        if (hash === void 0) {
          return;
        }
        const cachedFrames = this._cachedFrames.delete(hash);
        if (cachedFrames === void 0) {
          return;
        }
        const frameCount = _optionalChain([exception, "access", (_40) => _40.stacktrace, "optionalAccess", (_41) => _41.frames, "optionalAccess", (_42) => _42.length]) || 0;
        for (let i2 = 0; i2 < frameCount; i2++) {
          const frameIndex = frameCount - i2 - 1;
          if (!_optionalChain([exception, "optionalAccess", (_43) => _43.stacktrace, "optionalAccess", (_44) => _44.frames, "optionalAccess", (_45) => _45[frameIndex]]) || !cachedFrames[i2]) {
            break;
          }
          if (
            // We need to have vars to add
            cachedFrames[i2].vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
            exception.stacktrace.frames[frameIndex].in_app === false || // The function names need to match
            !functionNamesMatch(exception.stacktrace.frames[frameIndex].function, cachedFrames[i2].function)
          ) {
            continue;
          }
          exception.stacktrace.frames[frameIndex].vars = cachedFrames[i2].vars;
        }
      }
    };
    LocalVariables.__initStatic();
    exports.LocalVariables = LocalVariables;
    exports.createCallbackList = createCallbackList;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/undici/index.js
var require_undici = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/undici/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var nodeVersion = require_nodeVersion();
    var http3 = require_http2();
    exports.ChannelName = void 0;
    (function(ChannelName) {
      const RequestCreate = "undici:request:create";
      ChannelName["RequestCreate"] = RequestCreate;
      const RequestEnd = "undici:request:headers";
      ChannelName["RequestEnd"] = RequestEnd;
      const RequestError = "undici:request:error";
      ChannelName["RequestError"] = RequestError;
    })(exports.ChannelName || (exports.ChannelName = {}));
    var Undici = class {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Undici";
      }
      /**
       * @inheritDoc
       */
      __init() {
        this.name = Undici.id;
      }
      constructor(_options = {}) {
        Undici.prototype.__init.call(this);
        this._options = {
          breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
          shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest || (() => true)
        };
      }
      /**
       * @inheritDoc
       */
      setupOnce(_addGlobalEventProcessor, getCurrentHub) {
        if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major < 16) {
          return;
        }
        let ds;
        try {
          ds = utils.dynamicRequire(module, "diagnostics_channel");
        } catch (e2) {
        }
        if (!ds || !ds.subscribe) {
          return;
        }
        ds.subscribe(exports.ChannelName.RequestCreate, (message) => {
          const hub = getCurrentHub();
          if (!hub.getIntegration(Undici)) {
            return;
          }
          const { request } = message;
          const url = new URL(request.path, request.origin);
          const stringUrl = url.toString();
          if (http3.isSentryRequest(stringUrl) || request.__sentry__ !== void 0) {
            return;
          }
          const client = hub.getClient();
          const scope = hub.getScope();
          const activeSpan = scope.getSpan();
          if (activeSpan && client) {
            const clientOptions = client.getOptions();
            const shouldCreateSpan = this._options.shouldCreateSpanForRequest(stringUrl);
            if (shouldCreateSpan) {
              const method = request.method || "GET";
              const data = {
                "http.method": method
              };
              const params = url.searchParams.toString();
              if (params) {
                data["http.query"] = `?${params}`;
              }
              if (url.hash) {
                data["http.fragment"] = url.hash;
              }
              const span = activeSpan.startChild({
                op: "http.client",
                description: `${method} ${utils.stripUrlQueryAndFragment(stringUrl)}`,
                data
              });
              request.__sentry__ = span;
              const shouldPropagate = clientOptions.tracePropagationTargets ? utils.stringMatchesSomePattern(stringUrl, clientOptions.tracePropagationTargets) : true;
              if (shouldPropagate) {
                request.addHeader("sentry-trace", span.toTraceparent());
                if (span.transaction) {
                  const dynamicSamplingContext = span.transaction.getDynamicSamplingContext();
                  const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
                  if (sentryBaggageHeader) {
                    request.addHeader("baggage", sentryBaggageHeader);
                  }
                }
              }
            }
          }
        });
        ds.subscribe(exports.ChannelName.RequestEnd, (message) => {
          const hub = getCurrentHub();
          if (!hub.getIntegration(Undici)) {
            return;
          }
          const { request, response } = message;
          const url = new URL(request.path, request.origin);
          const stringUrl = url.toString();
          if (http3.isSentryRequest(stringUrl)) {
            return;
          }
          const span = request.__sentry__;
          if (span) {
            span.setHttpStatus(response.statusCode);
            span.finish();
          }
          if (this._options.breadcrumbs) {
            hub.addBreadcrumb(
              {
                category: "http",
                data: {
                  method: request.method,
                  status_code: response.statusCode,
                  url: stringUrl
                },
                type: "http"
              },
              {
                event: "response",
                request,
                response
              }
            );
          }
        });
        ds.subscribe(exports.ChannelName.RequestError, (message) => {
          const hub = getCurrentHub();
          if (!hub.getIntegration(Undici)) {
            return;
          }
          const { request } = message;
          const url = new URL(request.path, request.origin);
          const stringUrl = url.toString();
          if (http3.isSentryRequest(stringUrl)) {
            return;
          }
          const span = request.__sentry__;
          if (span) {
            span.setStatus("internal_error");
            span.finish();
          }
          if (this._options.breadcrumbs) {
            hub.addBreadcrumb(
              {
                category: "http",
                data: {
                  method: request.method,
                  url: stringUrl
                },
                level: "error",
                type: "http"
              },
              {
                event: "error",
                request
              }
            );
          }
        });
      }
    };
    Undici.__initStatic();
    exports.Undici = Undici;
  }
});

// ../../node_modules/@sentry/node/cjs/module.js
var require_module = __commonJS({
  "../../node_modules/@sentry/node/cjs/module.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var path4 = __require("path");
    var isWindowsPlatform = path4.sep === "\\";
    function normalizeWindowsPath(path5) {
      return path5.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
    }
    function getModule(filename, normalizeWindowsPathSeparator = isWindowsPlatform) {
      if (!filename) {
        return;
      }
      const normalizedFilename = normalizeWindowsPathSeparator ? normalizeWindowsPath(filename) : filename;
      let { root, dir, base: basename, ext } = path4.posix.parse(normalizedFilename);
      const base = __require && __require.main && __require.main.filename && dir || global.process.cwd();
      const normalizedBase = `${base}/`;
      let file = basename;
      if (ext === ".js") {
        file = file.slice(0, file.length - ".js".length);
      }
      if (!root && !dir) {
        dir = ".";
      }
      let n = dir.lastIndexOf("/node_modules/");
      if (n > -1) {
        return `${dir.slice(n + 14).replace(/\//g, ".")}:${file}`;
      }
      n = `${dir}/`.lastIndexOf(normalizedBase, 0);
      if (n === 0) {
        let moduleName = dir.slice(normalizedBase.length).replace(/\//g, ".");
        if (moduleName) {
          moduleName += ":";
        }
        moduleName += file;
        return moduleName;
      }
      return file;
    }
    exports.getModule = getModule;
  }
});

// ../../node_modules/@sentry/node/cjs/sdk.js
var require_sdk2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/sdk.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var index$1 = require_async();
    var client = require_client2();
    var console2 = require_console();
    var http3 = require_http3();
    var onuncaughtexception = require_onuncaughtexception();
    var onunhandledrejection = require_onunhandledrejection();
    var linkederrors = require_linkederrors();
    var modules = require_modules();
    var contextlines = require_contextlines();
    var context = require_context();
    var requestdata = require_requestdata3();
    var localvariables = require_localvariables();
    var index = require_undici();
    var module$1 = require_module();
    var http$1 = require_http();
    var defaultIntegrations = [
      // Common
      new core.Integrations.InboundFilters(),
      new core.Integrations.FunctionToString(),
      // Native Wrappers
      new console2.Console(),
      new http3.Http(),
      new index.Undici(),
      // Global Handlers
      new onuncaughtexception.OnUncaughtException(),
      new onunhandledrejection.OnUnhandledRejection(),
      // Event Info
      new contextlines.ContextLines(),
      new localvariables.LocalVariables(),
      new context.Context(),
      new modules.Modules(),
      new requestdata.RequestData(),
      // Misc
      new linkederrors.LinkedErrors()
    ];
    function init3(options = {}) {
      const carrier = core.getMainCarrier();
      index$1.setNodeAsyncContextStrategy();
      const autoloadedIntegrations = _optionalChain([carrier, "access", (_) => _.__SENTRY__, "optionalAccess", (_2) => _2.integrations]) || [];
      options.defaultIntegrations = options.defaultIntegrations === false ? [] : [
        ...Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations,
        ...autoloadedIntegrations
      ];
      if (options.dsn === void 0 && process.env.SENTRY_DSN) {
        options.dsn = process.env.SENTRY_DSN;
      }
      if (options.tracesSampleRate === void 0 && process.env.SENTRY_TRACES_SAMPLE_RATE) {
        const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
        if (isFinite(tracesSampleRate)) {
          options.tracesSampleRate = tracesSampleRate;
        }
      }
      if (options.release === void 0) {
        const detectedRelease = getSentryRelease();
        if (detectedRelease !== void 0) {
          options.release = detectedRelease;
        } else {
          options.autoSessionTracking = false;
        }
      }
      if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
        options.environment = process.env.SENTRY_ENVIRONMENT;
      }
      if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
        options.autoSessionTracking = true;
      }
      if (options.instrumenter === void 0) {
        options.instrumenter = "sentry";
      }
      const clientOptions = {
        ...options,
        stackParser: utils.stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
        integrations: core.getIntegrationsToSetup(options),
        transport: options.transport || http$1.makeNodeTransport
      };
      core.initAndBind(client.NodeClient, clientOptions);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
    }
    function lastEventId() {
      return core.getCurrentHub().lastEventId();
    }
    async function flush(timeout) {
      const client2 = core.getCurrentHub().getClient();
      if (client2) {
        return client2.flush(timeout);
      }
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Cannot flush events. No client defined.");
      return Promise.resolve(false);
    }
    async function close(timeout) {
      const client2 = core.getCurrentHub().getClient();
      if (client2) {
        return client2.close(timeout);
      }
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Cannot flush events and disable SDK. No client defined.");
      return Promise.resolve(false);
    }
    function isAutoSessionTrackingEnabled(client2) {
      if (client2 === void 0) {
        return false;
      }
      const clientOptions = client2 && client2.getOptions();
      if (clientOptions && clientOptions.autoSessionTracking !== void 0) {
        return clientOptions.autoSessionTracking;
      }
      return false;
    }
    function getSentryRelease(fallback) {
      if (process.env.SENTRY_RELEASE) {
        return process.env.SENTRY_RELEASE;
      }
      if (utils.GLOBAL_OBJ.SENTRY_RELEASE && utils.GLOBAL_OBJ.SENTRY_RELEASE.id) {
        return utils.GLOBAL_OBJ.SENTRY_RELEASE.id;
      }
      return (
        // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
        process.env.GITHUB_SHA || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
        process.env.COMMIT_REF || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
        process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || // Zeit (now known as Vercel)
        process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || fallback
      );
    }
    function captureCheckIn(checkIn, upsertMonitorConfig) {
      const capturedCheckIn = checkIn.status !== "in_progress" && checkIn.checkInId ? checkIn : { ...checkIn, checkInId: utils.uuid4() };
      const client2 = core.getCurrentHub().getClient();
      if (client2) {
        client2.captureCheckIn(capturedCheckIn, upsertMonitorConfig);
      } else {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn("Cannot capture check in. No client defined.");
      }
      return capturedCheckIn.checkInId;
    }
    var defaultStackParser = utils.createStackParser(utils.nodeStackLineParser(module$1.getModule));
    function startSessionTracking() {
      const hub = core.getCurrentHub();
      hub.startSession();
      process.on("beforeExit", () => {
        const session = _optionalChain([hub, "access", (_3) => _3.getScope, "call", (_4) => _4(), "optionalAccess", (_5) => _5.getSession, "call", (_6) => _6()]);
        const terminalStates = ["exited", "crashed"];
        if (session && !terminalStates.includes(session.status))
          hub.endSession();
      });
    }
    exports.captureCheckIn = captureCheckIn;
    exports.close = close;
    exports.defaultIntegrations = defaultIntegrations;
    exports.defaultStackParser = defaultStackParser;
    exports.flush = flush;
    exports.getSentryRelease = getSentryRelease;
    exports.init = init3;
    exports.isAutoSessionTrackingEnabled = isAutoSessionTrackingEnabled;
    exports.lastEventId = lastEventId;
  }
});

// ../../node_modules/@sentry/node/cjs/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@sentry/node/cjs/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs7 = __require("fs");
    var path4 = __require("path");
    function deepReadDirSync(targetDir) {
      const targetDirAbsPath = path4.resolve(targetDir);
      if (!fs7.existsSync(targetDirAbsPath)) {
        throw new Error(`Cannot read contents of ${targetDirAbsPath}. Directory does not exist.`);
      }
      if (!fs7.statSync(targetDirAbsPath).isDirectory()) {
        throw new Error(`Cannot read contents of ${targetDirAbsPath}, because it is not a directory.`);
      }
      const deepReadCurrentDir = (currentDirAbsPath) => {
        return fs7.readdirSync(currentDirAbsPath).reduce((absPaths, itemName) => {
          const itemAbsPath = path4.join(currentDirAbsPath, itemName);
          if (fs7.statSync(itemAbsPath).isDirectory()) {
            return absPaths.concat(deepReadCurrentDir(itemAbsPath));
          }
          absPaths.push(itemAbsPath);
          return absPaths;
        }, []);
      };
      return deepReadCurrentDir(targetDirAbsPath).map((absPath) => path4.relative(targetDirAbsPath, absPath));
    }
    exports.deepReadDirSync = deepReadDirSync;
  }
});

// ../../node_modules/@sentry/node/cjs/requestDataDeprecated.js
var require_requestDataDeprecated = __commonJS({
  "../../node_modules/@sentry/node/cjs/requestDataDeprecated.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var requestdata = require_requestdata2();
    function extractRequestData(req, keys) {
      return requestdata.extractRequestData(req, { include: keys });
    }
    function parseRequest(event, req, options = {}) {
      return requestdata.addRequestDataToEvent(event, req, { include: options });
    }
    exports.extractRequestData = extractRequestData;
    exports.parseRequest = parseRequest;
  }
});

// ../../node_modules/@sentry/node/cjs/handlers.js
var require_handlers = __commonJS({
  "../../node_modules/@sentry/node/cjs/handlers.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_buildPolyfills();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var requestdata = require_requestdata2();
    var sdk = require_sdk2();
    var requestDataDeprecated = require_requestDataDeprecated();
    function tracingHandler() {
      return function sentryTracingMiddleware(req, res, next) {
        const hub = core.getCurrentHub();
        const options = _optionalChain([hub, "access", (_) => _.getClient, "call", (_2) => _2(), "optionalAccess", (_3) => _3.getOptions, "call", (_4) => _4()]);
        if (!options || options.instrumenter !== "sentry" || _optionalChain([req, "access", (_5) => _5.method, "optionalAccess", (_6) => _6.toUpperCase, "call", (_7) => _7()]) === "OPTIONS" || _optionalChain([req, "access", (_8) => _8.method, "optionalAccess", (_9) => _9.toUpperCase, "call", (_10) => _10()]) === "HEAD") {
          return next();
        }
        if (!core.hasTracingEnabled(options)) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.warn(
            "Sentry `tracingHandler` is being used, but tracing is disabled. Please enable tracing by setting either `tracesSampleRate` or `tracesSampler` in your `Sentry.init()` options."
          );
          return next();
        }
        const traceparentData = req.headers && utils.isString(req.headers["sentry-trace"]) && utils.extractTraceparentData(req.headers["sentry-trace"]);
        const incomingBaggageHeaders = _optionalChain([req, "access", (_11) => _11.headers, "optionalAccess", (_12) => _12.baggage]);
        const dynamicSamplingContext = utils.baggageHeaderToDynamicSamplingContext(incomingBaggageHeaders);
        const [name, source] = utils.extractPathForTransaction(req, { path: true, method: true });
        const transaction = core.startTransaction(
          {
            name,
            op: "http.server",
            ...traceparentData,
            metadata: {
              dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
              // The request should already have been stored in `scope.sdkProcessingMetadata` (which will become
              // `event.sdkProcessingMetadata` the same way the metadata here will) by `sentryRequestMiddleware`, but on the
              // off chance someone is using `sentryTracingMiddleware` without `sentryRequestMiddleware`, it doesn't hurt to
              // be sure
              request: req,
              source
            }
          },
          // extra context passed to the tracesSampler
          { request: requestdata.extractRequestData(req) }
        );
        hub.configureScope((scope) => {
          scope.setSpan(transaction);
        });
        res.__sentry_transaction = transaction;
        res.once("finish", () => {
          setImmediate(() => {
            utils.addRequestDataToTransaction(transaction, req);
            transaction.setHttpStatus(res.statusCode);
            transaction.finish();
          });
        });
        next();
      };
    }
    function convertReqHandlerOptsToAddReqDataOpts(reqHandlerOptions = {}) {
      let addRequestDataOptions;
      if ("include" in reqHandlerOptions) {
        addRequestDataOptions = { include: reqHandlerOptions.include };
      } else {
        const { ip, request, transaction, user } = reqHandlerOptions;
        if (ip || request || transaction || user) {
          addRequestDataOptions = { include: utils.dropUndefinedKeys({ ip, request, transaction, user }) };
        }
      }
      return addRequestDataOptions;
    }
    function requestHandler(options) {
      const requestDataOptions = convertReqHandlerOptsToAddReqDataOpts(options);
      const currentHub = core.getCurrentHub();
      const client = currentHub.getClient();
      if (client && sdk.isAutoSessionTrackingEnabled(client)) {
        client.initSessionFlusher();
        const scope = currentHub.getScope();
        if (scope && scope.getSession()) {
          scope.setSession();
        }
      }
      return function sentryRequestMiddleware(req, res, next) {
        if (options && options.flushTimeout && options.flushTimeout > 0) {
          const _end = res.end;
          res.end = function(chunk, encoding, cb) {
            void sdk.flush(options.flushTimeout).then(() => {
              _end.call(this, chunk, encoding, cb);
            }).then(null, (e2) => {
              (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && utils.logger.error(e2);
              _end.call(this, chunk, encoding, cb);
            });
          };
        }
        core.runWithAsyncContext(() => {
          const currentHub2 = core.getCurrentHub();
          currentHub2.configureScope((scope) => {
            scope.setSDKProcessingMetadata({
              request: req,
              // TODO (v8): Stop passing this
              requestDataOptionsFromExpressHandler: requestDataOptions
            });
            const client2 = currentHub2.getClient();
            if (sdk.isAutoSessionTrackingEnabled(client2)) {
              const scope2 = currentHub2.getScope();
              if (scope2) {
                scope2.setRequestSession({ status: "ok" });
              }
            }
          });
          res.once("finish", () => {
            const client2 = currentHub2.getClient();
            if (sdk.isAutoSessionTrackingEnabled(client2)) {
              setImmediate(() => {
                if (client2 && client2._captureRequestSession) {
                  client2._captureRequestSession();
                }
              });
            }
          });
          next();
        });
      };
    }
    function getStatusCodeFromResponse(error) {
      const statusCode = error.status || error.statusCode || error.status_code || error.output && error.output.statusCode;
      return statusCode ? parseInt(statusCode, 10) : 500;
    }
    function defaultShouldHandleError(error) {
      const status = getStatusCodeFromResponse(error);
      return status >= 500;
    }
    function errorHandler(options) {
      return function sentryErrorMiddleware(error, _req, res, next) {
        const shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;
        if (shouldHandleError(error)) {
          core.withScope((_scope) => {
            _scope.setSDKProcessingMetadata({ request: _req });
            const transaction = res.__sentry_transaction;
            if (transaction && _scope.getSpan() === void 0) {
              _scope.setSpan(transaction);
            }
            const client = core.getCurrentHub().getClient();
            if (client && sdk.isAutoSessionTrackingEnabled(client)) {
              const isSessionAggregatesMode = client._sessionFlusher !== void 0;
              if (isSessionAggregatesMode) {
                const requestSession = _scope.getRequestSession();
                if (requestSession && requestSession.status !== void 0) {
                  requestSession.status = "crashed";
                }
              }
            }
            const eventId = core.captureException(error);
            res.sentry = eventId;
            next(error);
          });
          return;
        }
        next(error);
      };
    }
    function trpcMiddleware(options = {}) {
      return function({ path: path4, type, next, rawInput }) {
        const hub = core.getCurrentHub();
        const clientOptions = _optionalChain([hub, "access", (_13) => _13.getClient, "call", (_14) => _14(), "optionalAccess", (_15) => _15.getOptions, "call", (_16) => _16()]);
        const sentryTransaction = _optionalChain([hub, "access", (_17) => _17.getScope, "call", (_18) => _18(), "optionalAccess", (_19) => _19.getTransaction, "call", (_20) => _20()]);
        if (sentryTransaction) {
          sentryTransaction.setName(`trpc/${path4}`, "route");
          sentryTransaction.op = "rpc.server";
          const trpcContext = {
            procedure_type: type
          };
          if (options.attachRpcInput !== void 0 ? options.attachRpcInput : _optionalChain([clientOptions, "optionalAccess", (_21) => _21.sendDefaultPii])) {
            trpcContext.input = utils.normalize(rawInput);
          }
          sentryTransaction.setContext("trpc", trpcContext);
        }
        return next();
      };
    }
    exports.extractRequestData = requestDataDeprecated.extractRequestData;
    exports.parseRequest = requestDataDeprecated.parseRequest;
    exports.errorHandler = errorHandler;
    exports.requestHandler = requestHandler;
    exports.tracingHandler = tracingHandler;
    exports.trpcMiddleware = trpcMiddleware;
  }
});

// ../../node_modules/@sentry/node/cjs/integrations/index.js
var require_integrations2 = __commonJS({
  "../../node_modules/@sentry/node/cjs/integrations/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var console2 = require_console();
    var http3 = require_http3();
    var onuncaughtexception = require_onuncaughtexception();
    var onunhandledrejection = require_onunhandledrejection();
    var linkederrors = require_linkederrors();
    var modules = require_modules();
    var contextlines = require_contextlines();
    var context = require_context();
    var requestdata = require_requestdata3();
    var localvariables = require_localvariables();
    var index = require_undici();
    exports.Console = console2.Console;
    exports.Http = http3.Http;
    exports.OnUncaughtException = onuncaughtexception.OnUncaughtException;
    exports.OnUnhandledRejection = onunhandledrejection.OnUnhandledRejection;
    exports.LinkedErrors = linkederrors.LinkedErrors;
    exports.Modules = modules.Modules;
    exports.ContextLines = contextlines.ContextLines;
    exports.Context = context.Context;
    exports.RequestData = requestdata.RequestData;
    exports.LocalVariables = localvariables.LocalVariables;
    exports.Undici = index.Undici;
  }
});

// ../../node_modules/@sentry/node/cjs/tracing/integrations.js
var require_integrations3 = __commonJS({
  "../../node_modules/@sentry/node/cjs/tracing/integrations.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tracing = require_cjs3();
    exports.Apollo = tracing.Apollo;
    exports.Express = tracing.Express;
    exports.GraphQL = tracing.GraphQL;
    exports.Mongo = tracing.Mongo;
    exports.Mysql = tracing.Mysql;
    exports.Postgres = tracing.Postgres;
    exports.Prisma = tracing.Prisma;
  }
});

// ../../node_modules/@sentry/node/cjs/index.js
var require_cjs4 = __commonJS({
  "../../node_modules/@sentry/node/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var index = require_tracing2();
    var client = require_client2();
    var http3 = require_http();
    var sdk = require_sdk2();
    var requestdata = require_requestdata2();
    var utils = require_utils3();
    var handlers = require_handlers();
    var index$1 = require_integrations2();
    var integrations = require_integrations3();
    var INTEGRATIONS = {
      ...core.Integrations,
      ...index$1,
      ...integrations
    };
    exports.Hub = core.Hub;
    exports.SDK_VERSION = core.SDK_VERSION;
    exports.Scope = core.Scope;
    exports.addBreadcrumb = core.addBreadcrumb;
    exports.addGlobalEventProcessor = core.addGlobalEventProcessor;
    exports.captureEvent = core.captureEvent;
    exports.captureException = core.captureException;
    exports.captureMessage = core.captureMessage;
    exports.configureScope = core.configureScope;
    exports.createTransport = core.createTransport;
    exports.extractTraceparentData = core.extractTraceparentData;
    exports.getActiveTransaction = core.getActiveTransaction;
    exports.getCurrentHub = core.getCurrentHub;
    exports.getHubFromCarrier = core.getHubFromCarrier;
    exports.makeMain = core.makeMain;
    exports.runWithAsyncContext = core.runWithAsyncContext;
    exports.setContext = core.setContext;
    exports.setExtra = core.setExtra;
    exports.setExtras = core.setExtras;
    exports.setTag = core.setTag;
    exports.setTags = core.setTags;
    exports.setUser = core.setUser;
    exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
    exports.startTransaction = core.startTransaction;
    exports.trace = core.trace;
    exports.withScope = core.withScope;
    exports.autoDiscoverNodePerformanceMonitoringIntegrations = index.autoDiscoverNodePerformanceMonitoringIntegrations;
    exports.NodeClient = client.NodeClient;
    exports.makeNodeTransport = http3.makeNodeTransport;
    exports.captureCheckIn = sdk.captureCheckIn;
    exports.close = sdk.close;
    exports.defaultIntegrations = sdk.defaultIntegrations;
    exports.defaultStackParser = sdk.defaultStackParser;
    exports.flush = sdk.flush;
    exports.getSentryRelease = sdk.getSentryRelease;
    exports.init = sdk.init;
    exports.lastEventId = sdk.lastEventId;
    exports.DEFAULT_USER_INCLUDES = requestdata.DEFAULT_USER_INCLUDES;
    exports.addRequestDataToEvent = requestdata.addRequestDataToEvent;
    exports.extractRequestData = requestdata.extractRequestData;
    exports.deepReadDirSync = utils.deepReadDirSync;
    exports.Handlers = handlers;
    exports.Integrations = INTEGRATIONS;
  }
});

// ../../node_modules/async-lock/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/async-lock/lib/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var AsyncLock = function(opts) {
      opts = opts || {};
      this.Promise = opts.Promise || Promise;
      this.queues = /* @__PURE__ */ Object.create(null);
      this.domainReentrant = opts.domainReentrant || false;
      if (this.domainReentrant) {
        if (typeof process === "undefined" || typeof process.domain === "undefined") {
          throw new Error(
            "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
          );
        }
        this.domains = /* @__PURE__ */ Object.create(null);
      }
      this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
      this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;
      this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;
      if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {
        this.maxPending = opts.maxPending;
      } else {
        this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
      }
    };
    AsyncLock.DEFAULT_TIMEOUT = 0;
    AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0;
    AsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0;
    AsyncLock.DEFAULT_MAX_PENDING = 1e3;
    AsyncLock.prototype.acquire = function(key, fn, cb, opts) {
      if (Array.isArray(key)) {
        return this._acquireBatch(key, fn, cb, opts);
      }
      if (typeof fn !== "function") {
        throw new Error("You must pass a function to execute");
      }
      var deferredResolve = null;
      var deferredReject = null;
      var deferred = null;
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
        deferred = new this.Promise(function(resolve2, reject) {
          deferredResolve = resolve2;
          deferredReject = reject;
        });
      }
      opts = opts || {};
      var resolved = false;
      var timer = null;
      var occupationTimer = null;
      var executionTimer = null;
      var self2 = this;
      var done = function(locked, err, ret) {
        if (occupationTimer) {
          clearTimeout(occupationTimer);
          occupationTimer = null;
        }
        if (executionTimer) {
          clearTimeout(executionTimer);
          executionTimer = null;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length === 0) {
            delete self2.queues[key];
          }
          if (self2.domainReentrant) {
            delete self2.domains[key];
          }
        }
        if (!resolved) {
          if (!deferred) {
            if (typeof cb === "function") {
              cb(err, ret);
            }
          } else {
            if (err) {
              deferredReject(err);
            } else {
              deferredResolve(ret);
            }
          }
          resolved = true;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length > 0) {
            self2.queues[key].shift()();
          }
        }
      };
      var exec2 = function(locked) {
        if (resolved) {
          return done(locked);
        }
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (self2.domainReentrant && locked) {
          self2.domains[key] = process.domain;
        }
        var maxExecutionTime = opts.maxExecutionTime || self2.maxExecutionTime;
        if (maxExecutionTime) {
          executionTimer = setTimeout(function() {
            if (!!self2.queues[key]) {
              done(locked, new Error("Maximum execution time is exceeded " + key));
            }
          }, maxExecutionTime);
        }
        if (fn.length === 1) {
          var called = false;
          try {
            fn(function(err, ret) {
              if (!called) {
                called = true;
                done(locked, err, ret);
              }
            });
          } catch (err) {
            if (!called) {
              called = true;
              done(locked, err);
            }
          }
        } else {
          self2._promiseTry(function() {
            return fn();
          }).then(function(ret) {
            done(locked, void 0, ret);
          }, function(error) {
            done(locked, error);
          });
        }
      };
      if (self2.domainReentrant && !!process.domain) {
        exec2 = process.domain.bind(exec2);
      }
      if (!self2.queues[key]) {
        self2.queues[key] = [];
        exec2(true);
      } else if (self2.domainReentrant && !!process.domain && process.domain === self2.domains[key]) {
        exec2(false);
      } else if (self2.queues[key].length >= self2.maxPending) {
        done(false, new Error("Too many pending tasks in queue " + key));
      } else {
        var taskFn = function() {
          exec2(true);
        };
        if (opts.skipQueue) {
          self2.queues[key].unshift(taskFn);
        } else {
          self2.queues[key].push(taskFn);
        }
        var timeout = opts.timeout || self2.timeout;
        if (timeout) {
          timer = setTimeout(function() {
            timer = null;
            done(false, new Error("async-lock timed out in queue " + key));
          }, timeout);
        }
      }
      var maxOccupationTime = opts.maxOccupationTime || self2.maxOccupationTime;
      if (maxOccupationTime) {
        occupationTimer = setTimeout(function() {
          if (!!self2.queues[key]) {
            done(false, new Error("Maximum occupation time is exceeded in queue " + key));
          }
        }, maxOccupationTime);
      }
      if (deferred) {
        return deferred;
      }
    };
    AsyncLock.prototype._acquireBatch = function(keys, fn, cb, opts) {
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
      }
      var self2 = this;
      var getFn = function(key, fn2) {
        return function(cb2) {
          self2.acquire(key, fn2, cb2, opts);
        };
      };
      var fnx = keys.reduceRight(function(prev, key) {
        return getFn(key, prev);
      }, fn);
      if (typeof cb === "function") {
        fnx(cb);
      } else {
        return new this.Promise(function(resolve2, reject) {
          if (fnx.length === 1) {
            fnx(function(err, ret) {
              if (err) {
                reject(err);
              } else {
                resolve2(ret);
              }
            });
          } else {
            resolve2(fnx());
          }
        });
      }
    };
    AsyncLock.prototype.isBusy = function(key) {
      if (!key) {
        return Object.keys(this.queues).length > 0;
      } else {
        return !!this.queues[key];
      }
    };
    AsyncLock.prototype._promiseTry = function(fn) {
      try {
        return this.Promise.resolve(fn());
      } catch (e2) {
        return this.Promise.reject(e2);
      }
    };
    module.exports = AsyncLock;
  }
});

// ../../node_modules/async-lock/index.js
var require_async_lock = __commonJS({
  "../../node_modules/async-lock/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = require_lib2();
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    try {
      util2 = __require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module.exports = util2.inherits;
    } catch (e2) {
      module.exports = require_inherits_browser();
    }
    var util2;
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var buffer = __require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../../node_modules/sha.js/hash.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var Buffer4 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer4.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer4.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i2 = 0; i2 < remainder; i2++) {
          block[assigned + i2] = data[offset + i2];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// ../../node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/sha.js/sha1.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s2, b, c, d) {
      if (s2 === 0)
        return b & c | ~b & d;
      if (s2 === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e2 = this._e | 0;
      for (var i2 = 0; i2 < 16; ++i2)
        W2[i2] = M.readInt32BE(i2 * 4);
      for (; i2 < 80; ++i2)
        W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
      for (var j = 0; j < 80; ++j) {
        var s2 = ~~(j / 20);
        var t2 = rotl5(a) + ft(s2, b, c, d) + e2 + W2[j] + K[s2] | 0;
        e2 = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t2;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e2 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer4.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// ../../node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/crc-32/crc32.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i2 = 0, L = bstr.length; i2 < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i2++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i2 = 0;
        for (; i2 < L; )
          C = Tf[B[i2++] ^ C & 255] ^ Te[B[i2++] ^ C >> 8 & 255] ^ Td[B[i2++] ^ C >> 16 & 255] ^ Tc[B[i2++] ^ C >>> 24] ^ Tb[B[i2++]] ^ Ta[B[i2++]] ^ T9[B[i2++]] ^ T8[B[i2++]] ^ T7[B[i2++]] ^ T6[B[i2++]] ^ T5[B[i2++]] ^ T4[B[i2++]] ^ T3[B[i2++]] ^ T2[B[i2++]] ^ T1[B[i2++]] ^ T0[B[i2++]];
        L += 15;
        while (i2 < L)
          C = C >>> 8 ^ T0[(C ^ B[i2++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i2 = 0, L = str.length, c = 0, d = 0; i2 < L; ) {
          c = str.charCodeAt(i2++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i2++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS({
  "../../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_common2();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits(s2, value, length) {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    }
    function send_code(s2, c, tree) {
      send_bits(
        s2,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h2;
      var n, m2;
      var bits;
      var xbits;
      var f3;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE; h2++) {
        n = s2.heap[h2];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f3 = tree[n * 2];
        s2.opt_len += f3 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f3 * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s2.bl_count[bits];
        while (n !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n, m2, depth) {
      var _n2 = n * 2;
      var _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
    }
    function pqdownheap(s2, tree, k) {
      var v = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller(tree, v, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m2;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s2, tree, n);
      }
      node = elems;
      do {
        n = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
        tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// ../../node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t2 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// ../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_common2();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f3) {
      return (f3 << 1) - (f3 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b) {
      s2.pending_buf[s2.pending++] = b;
    }
    function putShortMSB(s2, b) {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p, n, m2, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n = s2.hash_size;
          p = n;
          do {
            m2 = s2.head[--p];
            s2.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m2 = s2.prev[--p];
            s2.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_common2();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i2 = 0, len = buf.length; i2 < len; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i2, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// ../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var zlib_deflate = require_deflate();
    var utils = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_common2();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_common2();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME2 = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME2;
            case NAME2:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// ../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var zlib_inflate = require_inflate();
    var utils = require_common2();
    var strings = require_strings();
    var c = require_constants2();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// ../../node_modules/pako/index.js
var require_pako = __commonJS({
  "../../node_modules/pako/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var assign = require_common2().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants2 = require_constants2();
    var pako = {};
    assign(pako, deflate, inflate, constants2);
    module.exports = pako;
  }
});

// ../../node_modules/pify/index.js
var require_pify = __commonJS({
  "../../node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var processFn = (fn, options) => function(...args) {
      const P = options.promiseModule;
      return new P((resolve2, reject) => {
        if (options.multiArgs) {
          args.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve2(result);
              }
            } else {
              resolve2(result);
            }
          });
        } else if (options.errorFirst) {
          args.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve2(result);
            }
          });
        } else {
          args.push(resolve2);
        }
        fn.apply(this, args);
      });
    };
    module.exports = (input, options) => {
      options = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objType = typeof input;
      if (!(input !== null && (objType === "object" || objType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType}\``);
      }
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options.include ? options.include.some(match) : !options.exclude.some(match);
      };
      let ret;
      if (objType === "function") {
        ret = function(...args) {
          return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options) : property;
      }
      return ret;
    };
  }
});

// ../../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/ignore/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE2 = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE2 : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE2
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule
        /(^|[^\\]+)\\\*(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path4, originalPath, doThrow) => {
      if (!isString(path4)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path4) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path4)) {
        const r2 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r2} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path4) => REGEX_TEST_INVALID_PATH.test(path4);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path4, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path4);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path4 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path4,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path4, cache, checkUnignored, slices);
      }
      _t(path4, cache, checkUnignored, slices) {
        if (path4 in cache) {
          return cache[path4];
        }
        if (!slices) {
          slices = path4.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path4] = this._testOne(path4, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path4] = parent.ignored ? parent : this._testOne(path4, checkUnignored);
      }
      ignores(path4) {
        return this._test(path4, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path4) => !this.ignores(path4);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path4) {
        return this._test(path4, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path4) => checkPath(path4 && checkPath.convert(path4), path4, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path4) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path4) || isNotRelative(path4);
    }
  }
});

// ../../node_modules/clean-git-ref/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/clean-git-ref/lib/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function replaceAll(str, search, replacement) {
      search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), "g");
      return str.replace(search, replacement);
    }
    var CleanGitRef = {
      clean: function clean(value) {
        if (typeof value !== "string") {
          throw new Error("Expected a string, received: " + value);
        }
        value = replaceAll(value, "./", "/");
        value = replaceAll(value, "..", ".");
        value = replaceAll(value, " ", "-");
        value = replaceAll(value, /^[~^:?*\\\-]/g, "");
        value = replaceAll(value, /[~^:?*\\]/g, "-");
        value = replaceAll(value, /[~^:?*\\\-]$/g, "");
        value = replaceAll(value, "@{", "-");
        value = replaceAll(value, /\.$/g, "");
        value = replaceAll(value, /\/$/g, "");
        value = replaceAll(value, /\.lock$/g, "");
        return value;
      }
    };
    module.exports = CleanGitRef;
  }
});

// ../../node_modules/diff3/onp.js
var require_onp = __commonJS({
  "../../node_modules/diff3/onp.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function(a_, b_) {
      var a = a_, b = b_, m2 = a.length, n = b.length, reverse = false, ed = null, offset = m2 + 1, path4 = [], pathposi = [], ses = [], lcs = "", SES_DELETE = -1, SES_COMMON = 0, SES_ADD = 1;
      var tmp1, tmp2;
      var init3 = function() {
        if (m2 >= n) {
          tmp1 = a;
          tmp2 = m2;
          a = b;
          b = tmp1;
          m2 = n;
          n = tmp2;
          reverse = true;
          offset = m2 + 1;
        }
      };
      var P = function(x2, y, k) {
        return {
          "x": x2,
          "y": y,
          "k": k
        };
      };
      var seselem = function(elem, t2) {
        return {
          "elem": elem,
          "t": t2
        };
      };
      var snake = function(k, p, pp) {
        var r2, x2, y;
        if (p > pp) {
          r2 = path4[k - 1 + offset];
        } else {
          r2 = path4[k + 1 + offset];
        }
        y = Math.max(p, pp);
        x2 = y - k;
        while (x2 < m2 && y < n && a[x2] === b[y]) {
          ++x2;
          ++y;
        }
        path4[k + offset] = pathposi.length;
        pathposi[pathposi.length] = new P(x2, y, r2);
        return y;
      };
      var recordseq = function(epc) {
        var x_idx, y_idx, px_idx, py_idx, i2;
        x_idx = y_idx = 1;
        px_idx = py_idx = 0;
        for (i2 = epc.length - 1; i2 >= 0; --i2) {
          while (px_idx < epc[i2].x || py_idx < epc[i2].y) {
            if (epc[i2].y - epc[i2].x > py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(b[py_idx], SES_DELETE);
              } else {
                ses[ses.length] = new seselem(b[py_idx], SES_ADD);
              }
              ++y_idx;
              ++py_idx;
            } else if (epc[i2].y - epc[i2].x < py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(a[px_idx], SES_ADD);
              } else {
                ses[ses.length] = new seselem(a[px_idx], SES_DELETE);
              }
              ++x_idx;
              ++px_idx;
            } else {
              ses[ses.length] = new seselem(a[px_idx], SES_COMMON);
              lcs += a[px_idx];
              ++x_idx;
              ++y_idx;
              ++px_idx;
              ++py_idx;
            }
          }
        }
      };
      init3();
      return {
        SES_DELETE: -1,
        SES_COMMON: 0,
        SES_ADD: 1,
        editdistance: function() {
          return ed;
        },
        getlcs: function() {
          return lcs;
        },
        getses: function() {
          return ses;
        },
        compose: function() {
          var delta, size, fp, p, r2, epc, i2, k;
          delta = n - m2;
          size = m2 + n + 3;
          fp = {};
          for (i2 = 0; i2 < size; ++i2) {
            fp[i2] = -1;
            path4[i2] = -1;
          }
          p = -1;
          do {
            ++p;
            for (k = -p; k <= delta - 1; ++k) {
              fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
            }
            for (k = delta + p; k >= delta + 1; --k) {
              fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset] + 1, fp[delta + 1 + offset]);
          } while (fp[delta + offset] !== n);
          ed = delta + 2 * p;
          r2 = path4[delta + offset];
          epc = [];
          while (r2 !== -1) {
            epc[epc.length] = new P(pathposi[r2].x, pathposi[r2].y, null);
            r2 = pathposi[r2].k;
          }
          recordseq(epc);
        }
      };
    };
  }
});

// ../../node_modules/diff3/diff3.js
var require_diff3 = __commonJS({
  "../../node_modules/diff3/diff3.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var onp = require_onp();
    function longestCommonSubsequence(file1, file2) {
      var diff = new onp(file1, file2);
      diff.compose();
      var ses = diff.getses();
      var root;
      var prev;
      var file1RevIdx = file1.length - 1, file2RevIdx = file2.length - 1;
      for (var i2 = ses.length - 1; i2 >= 0; --i2) {
        if (ses[i2].t === diff.SES_COMMON) {
          if (prev) {
            prev.chain = {
              file1index: file1RevIdx,
              file2index: file2RevIdx,
              chain: null
            };
            prev = prev.chain;
          } else {
            root = {
              file1index: file1RevIdx,
              file2index: file2RevIdx,
              chain: null
            };
            prev = root;
          }
          file1RevIdx--;
          file2RevIdx--;
        } else if (ses[i2].t === diff.SES_DELETE) {
          file1RevIdx--;
        } else if (ses[i2].t === diff.SES_ADD) {
          file2RevIdx--;
        }
      }
      var tail = {
        file1index: -1,
        file2index: -1,
        chain: null
      };
      if (!prev) {
        return tail;
      }
      prev.chain = tail;
      return root;
    }
    function diffIndices(file1, file2) {
      var result = [];
      var tail1 = file1.length;
      var tail2 = file2.length;
      for (var candidate = longestCommonSubsequence(file1, file2); candidate !== null; candidate = candidate.chain) {
        var mismatchLength1 = tail1 - candidate.file1index - 1;
        var mismatchLength2 = tail2 - candidate.file2index - 1;
        tail1 = candidate.file1index;
        tail2 = candidate.file2index;
        if (mismatchLength1 || mismatchLength2) {
          result.push({
            file1: [tail1 + 1, mismatchLength1],
            file2: [tail2 + 1, mismatchLength2]
          });
        }
      }
      result.reverse();
      return result;
    }
    function diff3MergeIndices(a, o, b) {
      var i2;
      var m1 = diffIndices(o, a);
      var m2 = diffIndices(o, b);
      var hunks = [];
      function addHunk(h2, side2) {
        hunks.push([h2.file1[0], side2, h2.file1[1], h2.file2[0], h2.file2[1]]);
      }
      for (i2 = 0; i2 < m1.length; i2++) {
        addHunk(m1[i2], 0);
      }
      for (i2 = 0; i2 < m2.length; i2++) {
        addHunk(m2[i2], 2);
      }
      hunks.sort(function(x2, y) {
        return x2[0] - y[0];
      });
      var result = [];
      var commonOffset = 0;
      function copyCommon(targetOffset) {
        if (targetOffset > commonOffset) {
          result.push([1, commonOffset, targetOffset - commonOffset]);
          commonOffset = targetOffset;
        }
      }
      for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
        var firstHunkIndex = hunkIndex;
        var hunk = hunks[hunkIndex];
        var regionLhs = hunk[0];
        var regionRhs = regionLhs + hunk[2];
        while (hunkIndex < hunks.length - 1) {
          var maybeOverlapping = hunks[hunkIndex + 1];
          var maybeLhs = maybeOverlapping[0];
          if (maybeLhs > regionRhs)
            break;
          regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
          hunkIndex++;
        }
        copyCommon(regionLhs);
        if (firstHunkIndex == hunkIndex) {
          if (hunk[4] > 0) {
            result.push([hunk[1], hunk[3], hunk[4]]);
          }
        } else {
          var regions = {
            0: [a.length, -1, o.length, -1],
            2: [b.length, -1, o.length, -1]
          };
          for (i2 = firstHunkIndex; i2 <= hunkIndex; i2++) {
            hunk = hunks[i2];
            var side = hunk[1];
            var r2 = regions[side];
            var oLhs = hunk[0];
            var oRhs = oLhs + hunk[2];
            var abLhs = hunk[3];
            var abRhs = abLhs + hunk[4];
            r2[0] = Math.min(abLhs, r2[0]);
            r2[1] = Math.max(abRhs, r2[1]);
            r2[2] = Math.min(oLhs, r2[2]);
            r2[3] = Math.max(oRhs, r2[3]);
          }
          var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
          var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
          var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
          var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
          result.push([
            -1,
            aLhs,
            aRhs - aLhs,
            regionLhs,
            regionRhs - regionLhs,
            bLhs,
            bRhs - bLhs
          ]);
        }
        commonOffset = regionRhs;
      }
      copyCommon(o.length);
      return result;
    }
    function diff3Merge(a, o, b) {
      var result = [];
      var files = [a, o, b];
      var indices = diff3MergeIndices(a, o, b);
      var okLines = [];
      function flushOk() {
        if (okLines.length) {
          result.push({
            ok: okLines
          });
        }
        okLines = [];
      }
      function pushOk(xs) {
        for (var j = 0; j < xs.length; j++) {
          okLines.push(xs[j]);
        }
      }
      function isTrueConflict(rec) {
        if (rec[2] != rec[6])
          return true;
        var aoff = rec[1];
        var boff = rec[5];
        for (var j = 0; j < rec[2]; j++) {
          if (a[j + aoff] != b[j + boff])
            return true;
        }
        return false;
      }
      for (var i2 = 0; i2 < indices.length; i2++) {
        var x2 = indices[i2];
        var side = x2[0];
        if (side == -1) {
          if (!isTrueConflict(x2)) {
            pushOk(files[0].slice(x2[1], x2[1] + x2[2]));
          } else {
            flushOk();
            result.push({
              conflict: {
                a: a.slice(x2[1], x2[1] + x2[2]),
                aIndex: x2[1],
                o: o.slice(x2[3], x2[3] + x2[4]),
                oIndex: x2[3],
                b: b.slice(x2[5], x2[5] + x2[6]),
                bIndex: x2[5]
              }
            });
          }
        } else {
          pushOk(files[side].slice(x2[1], x2[1] + x2[2]));
        }
      }
      flushOk();
      return result;
    }
    module.exports = diff3Merge;
  }
});

// ../../node_modules/isomorphic-git/index.cjs
var require_isomorphic_git = __commonJS({
  "../../node_modules/isomorphic-git/index.cjs"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var AsyncLock = _interopDefault(require_async_lock());
    var Hash = _interopDefault(require_sha1());
    var crc32 = _interopDefault(require_crc32());
    var pako = _interopDefault(require_pako());
    var pify = _interopDefault(require_pify());
    var ignore = _interopDefault(require_ignore());
    var cleanGitRef = _interopDefault(require_lib3());
    var diff3Merge = _interopDefault(require_diff3());
    var BaseError = class extends Error {
      constructor(message) {
        super(message);
        this.caller = "";
      }
      toJSON() {
        return {
          code: this.code,
          data: this.data,
          caller: this.caller,
          message: this.message,
          stack: this.stack
        };
      }
      fromJSON(json) {
        const e2 = new BaseError(json.message);
        e2.code = json.code;
        e2.data = json.data;
        e2.caller = json.caller;
        e2.stack = json.stack;
        return e2;
      }
      get isIsomorphicGitError() {
        return true;
      }
    };
    var UnmergedPathsError = class extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepaths) {
        super(
          `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
        );
        this.code = this.name = UnmergedPathsError.code;
        this.data = { filepaths };
      }
    };
    UnmergedPathsError.code = "UnmergedPathsError";
    var InternalError = class extends BaseError {
      /**
       * @param {string} message
       */
      constructor(message) {
        super(
          `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
        );
        this.code = this.name = InternalError.code;
        this.data = { message };
      }
    };
    InternalError.code = "InternalError";
    var UnsafeFilepathError = class extends BaseError {
      /**
       * @param {string} filepath
       */
      constructor(filepath) {
        super(`The filepath "${filepath}" contains unsafe character sequences`);
        this.code = this.name = UnsafeFilepathError.code;
        this.data = { filepath };
      }
    };
    UnsafeFilepathError.code = "UnsafeFilepathError";
    var BufferCursor = class {
      constructor(buffer) {
        this.buffer = buffer;
        this._start = 0;
      }
      eof() {
        return this._start >= this.buffer.length;
      }
      tell() {
        return this._start;
      }
      seek(n) {
        this._start = n;
      }
      slice(n) {
        const r2 = this.buffer.slice(this._start, this._start + n);
        this._start += n;
        return r2;
      }
      toString(enc, length) {
        const r2 = this.buffer.toString(enc, this._start, this._start + length);
        this._start += length;
        return r2;
      }
      write(value, length, enc) {
        const r2 = this.buffer.write(value, this._start, length, enc);
        this._start += length;
        return r2;
      }
      copy(source, start, end) {
        const r2 = source.copy(this.buffer, this._start, start, end);
        this._start += r2;
        return r2;
      }
      readUInt8() {
        const r2 = this.buffer.readUInt8(this._start);
        this._start += 1;
        return r2;
      }
      writeUInt8(value) {
        const r2 = this.buffer.writeUInt8(value, this._start);
        this._start += 1;
        return r2;
      }
      readUInt16BE() {
        const r2 = this.buffer.readUInt16BE(this._start);
        this._start += 2;
        return r2;
      }
      writeUInt16BE(value) {
        const r2 = this.buffer.writeUInt16BE(value, this._start);
        this._start += 2;
        return r2;
      }
      readUInt32BE() {
        const r2 = this.buffer.readUInt32BE(this._start);
        this._start += 4;
        return r2;
      }
      writeUInt32BE(value) {
        const r2 = this.buffer.writeUInt32BE(value, this._start);
        this._start += 4;
        return r2;
      }
    };
    function compareStrings(a, b) {
      return -(a < b) || +(a > b);
    }
    function comparePath(a, b) {
      return compareStrings(a.path, b.path);
    }
    function normalizeMode(mode) {
      let type = mode > 0 ? mode >> 12 : 0;
      if (type !== 4 && type !== 8 && type !== 10 && type !== 14) {
        type = 8;
      }
      let permissions = mode & 511;
      if (permissions & 73) {
        permissions = 493;
      } else {
        permissions = 420;
      }
      if (type !== 8)
        permissions = 0;
      return (type << 12) + permissions;
    }
    var MAX_UINT32 = 2 ** 32;
    function SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {
      if (givenSeconds !== void 0 && givenNanoseconds !== void 0) {
        return [givenSeconds, givenNanoseconds];
      }
      if (milliseconds === void 0) {
        milliseconds = date.valueOf();
      }
      const seconds = Math.floor(milliseconds / 1e3);
      const nanoseconds = (milliseconds - seconds * 1e3) * 1e6;
      return [seconds, nanoseconds];
    }
    function normalizeStats(e2) {
      const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
        e2.ctimeSeconds,
        e2.ctimeNanoseconds,
        e2.ctimeMs,
        e2.ctime
      );
      const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
        e2.mtimeSeconds,
        e2.mtimeNanoseconds,
        e2.mtimeMs,
        e2.mtime
      );
      return {
        ctimeSeconds: ctimeSeconds % MAX_UINT32,
        ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
        mtimeSeconds: mtimeSeconds % MAX_UINT32,
        mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
        dev: e2.dev % MAX_UINT32,
        ino: e2.ino % MAX_UINT32,
        mode: normalizeMode(e2.mode % MAX_UINT32),
        uid: e2.uid % MAX_UINT32,
        gid: e2.gid % MAX_UINT32,
        // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
        // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
        size: e2.size > -1 ? e2.size % MAX_UINT32 : 0
      };
    }
    function toHex(buffer) {
      let hex = "";
      for (const byte of new Uint8Array(buffer)) {
        if (byte < 16)
          hex += "0";
        hex += byte.toString(16);
      }
      return hex;
    }
    var supportsSubtleSHA1 = null;
    async function shasum(buffer) {
      if (supportsSubtleSHA1 === null) {
        supportsSubtleSHA1 = await testSubtleSHA1();
      }
      return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);
    }
    function shasumSync(buffer) {
      return new Hash().update(buffer).digest("hex");
    }
    async function subtleSHA1(buffer) {
      const hash = await crypto.subtle.digest("SHA-1", buffer);
      return toHex(hash);
    }
    async function testSubtleSHA1() {
      try {
        const hash = await subtleSHA1(new Uint8Array([]));
        if (hash === "da39a3ee5e6b4b0d3255bfef95601890afd80709")
          return true;
      } catch (_) {
      }
      return false;
    }
    function parseCacheEntryFlags(bits) {
      return {
        assumeValid: Boolean(bits & 32768),
        extended: Boolean(bits & 16384),
        stage: (bits & 12288) >> 12,
        nameLength: bits & 4095
      };
    }
    function renderCacheEntryFlags(entry) {
      const flags = entry.flags;
      flags.extended = false;
      flags.nameLength = Math.min(Buffer.from(entry.path).length, 4095);
      return (flags.assumeValid ? 32768 : 0) + (flags.extended ? 16384 : 0) + ((flags.stage & 3) << 12) + (flags.nameLength & 4095);
    }
    var GitIndex = class {
      /*::
       _entries: Map<string, CacheEntry>
       _dirty: boolean // Used to determine if index needs to be saved to filesystem
       */
      constructor(entries, unmergedPaths) {
        this._dirty = false;
        this._unmergedPaths = unmergedPaths || /* @__PURE__ */ new Set();
        this._entries = entries || /* @__PURE__ */ new Map();
      }
      _addEntry(entry) {
        if (entry.flags.stage === 0) {
          entry.stages = [entry];
          this._entries.set(entry.path, entry);
          this._unmergedPaths.delete(entry.path);
        } else {
          let existingEntry = this._entries.get(entry.path);
          if (!existingEntry) {
            this._entries.set(entry.path, entry);
            existingEntry = entry;
          }
          existingEntry.stages[entry.flags.stage] = entry;
          this._unmergedPaths.add(entry.path);
        }
      }
      static async from(buffer) {
        if (Buffer.isBuffer(buffer)) {
          return GitIndex.fromBuffer(buffer);
        } else if (buffer === null) {
          return new GitIndex(null);
        } else {
          throw new InternalError("invalid type passed to GitIndex.from");
        }
      }
      static async fromBuffer(buffer) {
        if (buffer.length === 0) {
          throw new InternalError("Index file is empty (.git/index)");
        }
        const index2 = new GitIndex();
        const reader = new BufferCursor(buffer);
        const magic = reader.toString("utf8", 4);
        if (magic !== "DIRC") {
          throw new InternalError(`Invalid dircache magic file number: ${magic}`);
        }
        const shaComputed = await shasum(buffer.slice(0, -20));
        const shaClaimed = buffer.slice(-20).toString("hex");
        if (shaClaimed !== shaComputed) {
          throw new InternalError(
            `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
          );
        }
        const version3 = reader.readUInt32BE();
        if (version3 !== 2) {
          throw new InternalError(`Unsupported dircache version: ${version3}`);
        }
        const numEntries = reader.readUInt32BE();
        let i2 = 0;
        while (!reader.eof() && i2 < numEntries) {
          const entry = {};
          entry.ctimeSeconds = reader.readUInt32BE();
          entry.ctimeNanoseconds = reader.readUInt32BE();
          entry.mtimeSeconds = reader.readUInt32BE();
          entry.mtimeNanoseconds = reader.readUInt32BE();
          entry.dev = reader.readUInt32BE();
          entry.ino = reader.readUInt32BE();
          entry.mode = reader.readUInt32BE();
          entry.uid = reader.readUInt32BE();
          entry.gid = reader.readUInt32BE();
          entry.size = reader.readUInt32BE();
          entry.oid = reader.slice(20).toString("hex");
          const flags = reader.readUInt16BE();
          entry.flags = parseCacheEntryFlags(flags);
          const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
          if (pathlength < 1) {
            throw new InternalError(`Got a path length of: ${pathlength}`);
          }
          entry.path = reader.toString("utf8", pathlength);
          if (entry.path.includes("..\\") || entry.path.includes("../")) {
            throw new UnsafeFilepathError(entry.path);
          }
          let padding = 8 - (reader.tell() - 12) % 8;
          if (padding === 0)
            padding = 8;
          while (padding--) {
            const tmp = reader.readUInt8();
            if (tmp !== 0) {
              throw new InternalError(
                `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
              );
            } else if (reader.eof()) {
              throw new InternalError("Unexpected end of file");
            }
          }
          entry.stages = [];
          index2._addEntry(entry);
          i2++;
        }
        return index2;
      }
      get unmergedPaths() {
        return [...this._unmergedPaths];
      }
      get entries() {
        return [...this._entries.values()].sort(comparePath);
      }
      get entriesMap() {
        return this._entries;
      }
      get entriesFlat() {
        return [...this.entries].flatMap((entry) => {
          return entry.stages.length > 1 ? entry.stages.filter((x2) => x2) : entry;
        });
      }
      *[Symbol.iterator]() {
        for (const entry of this.entries) {
          yield entry;
        }
      }
      insert({ filepath, stats, oid, stage = 0 }) {
        if (!stats) {
          stats = {
            ctimeSeconds: 0,
            ctimeNanoseconds: 0,
            mtimeSeconds: 0,
            mtimeNanoseconds: 0,
            dev: 0,
            ino: 0,
            mode: 0,
            uid: 0,
            gid: 0,
            size: 0
          };
        }
        stats = normalizeStats(stats);
        const bfilepath = Buffer.from(filepath);
        const entry = {
          ctimeSeconds: stats.ctimeSeconds,
          ctimeNanoseconds: stats.ctimeNanoseconds,
          mtimeSeconds: stats.mtimeSeconds,
          mtimeNanoseconds: stats.mtimeNanoseconds,
          dev: stats.dev,
          ino: stats.ino,
          // We provide a fallback value for `mode` here because not all fs
          // implementations assign it, but we use it in GitTree.
          // '100644' is for a "regular non-executable file"
          mode: stats.mode || 33188,
          uid: stats.uid,
          gid: stats.gid,
          size: stats.size,
          path: filepath,
          oid,
          flags: {
            assumeValid: false,
            extended: false,
            stage,
            nameLength: bfilepath.length < 4095 ? bfilepath.length : 4095
          },
          stages: []
        };
        this._addEntry(entry);
        this._dirty = true;
      }
      delete({ filepath }) {
        if (this._entries.has(filepath)) {
          this._entries.delete(filepath);
        } else {
          for (const key of this._entries.keys()) {
            if (key.startsWith(filepath + "/")) {
              this._entries.delete(key);
            }
          }
        }
        if (this._unmergedPaths.has(filepath)) {
          this._unmergedPaths.delete(filepath);
        }
        this._dirty = true;
      }
      clear() {
        this._entries.clear();
        this._dirty = true;
      }
      has({ filepath }) {
        return this._entries.has(filepath);
      }
      render() {
        return this.entries.map((entry) => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`).join("\n");
      }
      static async _entryToBuffer(entry) {
        const bpath = Buffer.from(entry.path);
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat2 = normalizeStats(entry);
        writer.writeUInt32BE(stat2.ctimeSeconds);
        writer.writeUInt32BE(stat2.ctimeNanoseconds);
        writer.writeUInt32BE(stat2.mtimeSeconds);
        writer.writeUInt32BE(stat2.mtimeNanoseconds);
        writer.writeUInt32BE(stat2.dev);
        writer.writeUInt32BE(stat2.ino);
        writer.writeUInt32BE(stat2.mode);
        writer.writeUInt32BE(stat2.uid);
        writer.writeUInt32BE(stat2.gid);
        writer.writeUInt32BE(stat2.size);
        writer.write(entry.oid, 20, "hex");
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, "utf8");
        return written;
      }
      async toObject() {
        const header = Buffer.alloc(12);
        const writer = new BufferCursor(header);
        writer.write("DIRC", 4, "utf8");
        writer.writeUInt32BE(2);
        writer.writeUInt32BE(this.entriesFlat.length);
        let entryBuffers = [];
        for (const entry of this.entries) {
          entryBuffers.push(GitIndex._entryToBuffer(entry));
          if (entry.stages.length > 1) {
            for (const stage of entry.stages) {
              if (stage && stage !== entry) {
                entryBuffers.push(GitIndex._entryToBuffer(stage));
              }
            }
          }
        }
        entryBuffers = await Promise.all(entryBuffers);
        const body = Buffer.concat(entryBuffers);
        const main = Buffer.concat([header, body]);
        const sum = await shasum(main);
        return Buffer.concat([main, Buffer.from(sum, "hex")]);
      }
    };
    function compareStats(entry, stats) {
      const e2 = normalizeStats(entry);
      const s2 = normalizeStats(stats);
      const staleness = e2.mode !== s2.mode || e2.mtimeSeconds !== s2.mtimeSeconds || e2.ctimeSeconds !== s2.ctimeSeconds || e2.uid !== s2.uid || e2.gid !== s2.gid || e2.ino !== s2.ino || e2.size !== s2.size;
      return staleness;
    }
    var lock = null;
    var IndexCache = Symbol("IndexCache");
    function createCache() {
      return {
        map: /* @__PURE__ */ new Map(),
        stats: /* @__PURE__ */ new Map()
      };
    }
    async function updateCachedIndexFile(fs7, filepath, cache) {
      const stat2 = await fs7.lstat(filepath);
      const rawIndexFile = await fs7.read(filepath);
      const index2 = await GitIndex.from(rawIndexFile);
      cache.map.set(filepath, index2);
      cache.stats.set(filepath, stat2);
    }
    async function isIndexStale(fs7, filepath, cache) {
      const savedStats = cache.stats.get(filepath);
      if (savedStats === void 0)
        return true;
      const currStats = await fs7.lstat(filepath);
      if (savedStats === null)
        return false;
      if (currStats === null)
        return false;
      return compareStats(savedStats, currStats);
    }
    var GitIndexManager = class {
      /**
       *
       * @param {object} opts
       * @param {import('../models/FileSystem.js').FileSystem} opts.fs
       * @param {string} opts.gitdir
       * @param {object} opts.cache
       * @param {bool} opts.allowUnmerged
       * @param {function(GitIndex): any} closure
       */
      static async acquire({ fs: fs7, gitdir, cache, allowUnmerged = true }, closure) {
        if (!cache[IndexCache])
          cache[IndexCache] = createCache();
        const filepath = `${gitdir}/index`;
        if (lock === null)
          lock = new AsyncLock({ maxPending: Infinity });
        let result;
        let unmergedPaths = [];
        await lock.acquire(filepath, async () => {
          if (await isIndexStale(fs7, filepath, cache[IndexCache])) {
            await updateCachedIndexFile(fs7, filepath, cache[IndexCache]);
          }
          const index2 = cache[IndexCache].map.get(filepath);
          unmergedPaths = index2.unmergedPaths;
          if (unmergedPaths.length && !allowUnmerged)
            throw new UnmergedPathsError(unmergedPaths);
          result = await closure(index2);
          if (index2._dirty) {
            const buffer = await index2.toObject();
            await fs7.write(filepath, buffer);
            cache[IndexCache].stats.set(filepath, await fs7.lstat(filepath));
            index2._dirty = false;
          }
        });
        return result;
      }
    };
    function basename(path4) {
      const last = Math.max(path4.lastIndexOf("/"), path4.lastIndexOf("\\"));
      if (last > -1) {
        path4 = path4.slice(last + 1);
      }
      return path4;
    }
    function dirname2(path4) {
      const last = Math.max(path4.lastIndexOf("/"), path4.lastIndexOf("\\"));
      if (last === -1)
        return ".";
      if (last === 0)
        return "/";
      return path4.slice(0, last);
    }
    function flatFileListToDirectoryStructure(files) {
      const inodes = /* @__PURE__ */ new Map();
      const mkdir = function(name) {
        if (!inodes.has(name)) {
          const dir = {
            type: "tree",
            fullpath: name,
            basename: basename(name),
            metadata: {},
            children: []
          };
          inodes.set(name, dir);
          dir.parent = mkdir(dirname2(name));
          if (dir.parent && dir.parent !== dir)
            dir.parent.children.push(dir);
        }
        return inodes.get(name);
      };
      const mkfile = function(name, metadata) {
        if (!inodes.has(name)) {
          const file = {
            type: "blob",
            fullpath: name,
            basename: basename(name),
            metadata,
            // This recursively generates any missing parent folders.
            parent: mkdir(dirname2(name)),
            children: []
          };
          if (file.parent)
            file.parent.children.push(file);
          inodes.set(name, file);
        }
        return inodes.get(name);
      };
      mkdir(".");
      for (const file of files) {
        mkfile(file.path, file);
      }
      return inodes;
    }
    function mode2type(mode) {
      switch (mode) {
        case 16384:
          return "tree";
        case 33188:
          return "blob";
        case 33261:
          return "blob";
        case 40960:
          return "blob";
        case 57344:
          return "commit";
      }
      throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);
    }
    var GitWalkerIndex = class {
      constructor({ fs: fs7, gitdir, cache }) {
        this.treePromise = GitIndexManager.acquire(
          { fs: fs7, gitdir, cache },
          async function(index2) {
            return flatFileListToDirectoryStructure(index2.entries);
          }
        );
        const walker = this;
        this.ConstructEntry = class StageEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const tree = await this.treePromise;
        const inode = tree.get(filepath);
        if (!inode)
          return null;
        if (inode.type === "blob")
          return null;
        if (inode.type !== "tree") {
          throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
        }
        const names = inode.children.map((inode2) => inode2.fullpath);
        names.sort(compareStrings);
        return names;
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          if (!inode) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          const stats = inode.type === "tree" ? {} : normalizeStats(inode.metadata);
          entry._type = inode.type === "tree" ? "tree" : mode2type(stats.mode);
          entry._mode = stats.mode;
          if (inode.type === "tree") {
            entry._stat = void 0;
          } else {
            entry._stat = stats;
          }
        }
        return entry._stat;
      }
      async content(_entry) {
      }
      async oid(entry) {
        if (entry._oid === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          entry._oid = inode.metadata.oid;
        }
        return entry._oid;
      }
    };
    var GitWalkSymbol = Symbol("GitWalkSymbol");
    function STAGE() {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: function({ fs: fs7, gitdir, cache }) {
          return new GitWalkerIndex({ fs: fs7, gitdir, cache });
        }
      });
      Object.freeze(o);
      return o;
    }
    var NotFoundError = class extends BaseError {
      /**
       * @param {string} what
       */
      constructor(what) {
        super(`Could not find ${what}.`);
        this.code = this.name = NotFoundError.code;
        this.data = { what };
      }
    };
    NotFoundError.code = "NotFoundError";
    var ObjectTypeError = class extends BaseError {
      /**
       * @param {string} oid
       * @param {'blob'|'commit'|'tag'|'tree'} actual
       * @param {'blob'|'commit'|'tag'|'tree'} expected
       * @param {string} [filepath]
       */
      constructor(oid, actual, expected, filepath) {
        super(
          `Object ${oid} ${filepath ? `at ${filepath}` : ""}was anticipated to be a ${expected} but it is a ${actual}.`
        );
        this.code = this.name = ObjectTypeError.code;
        this.data = { oid, actual, expected, filepath };
      }
    };
    ObjectTypeError.code = "ObjectTypeError";
    var InvalidOidError = class extends BaseError {
      /**
       * @param {string} value
       */
      constructor(value) {
        super(`Expected a 40-char hex object id but saw "${value}".`);
        this.code = this.name = InvalidOidError.code;
        this.data = { value };
      }
    };
    InvalidOidError.code = "InvalidOidError";
    var NoRefspecError = class extends BaseError {
      /**
       * @param {string} remote
       */
      constructor(remote) {
        super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`);
        this.code = this.name = NoRefspecError.code;
        this.data = { remote };
      }
    };
    NoRefspecError.code = "NoRefspecError";
    var GitPackedRefs = class {
      constructor(text) {
        this.refs = /* @__PURE__ */ new Map();
        this.parsedConfig = [];
        if (text) {
          let key = null;
          this.parsedConfig = text.trim().split("\n").map((line) => {
            if (/^\s*#/.test(line)) {
              return { line, comment: true };
            }
            const i2 = line.indexOf(" ");
            if (line.startsWith("^")) {
              const value = line.slice(1);
              this.refs.set(key + "^{}", value);
              return { line, ref: key, peeled: value };
            } else {
              const value = line.slice(0, i2);
              key = line.slice(i2 + 1);
              this.refs.set(key, value);
              return { line, ref: key, oid: value };
            }
          });
        }
        return this;
      }
      static from(text) {
        return new GitPackedRefs(text);
      }
      delete(ref) {
        this.parsedConfig = this.parsedConfig.filter((entry) => entry.ref !== ref);
        this.refs.delete(ref);
      }
      toString() {
        return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
      }
    };
    var GitRefSpec = class {
      constructor({ remotePath, localPath, force, matchPrefix }) {
        Object.assign(this, {
          remotePath,
          localPath,
          force,
          matchPrefix
        });
      }
      static from(refspec) {
        const [
          forceMatch,
          remotePath,
          remoteGlobMatch,
          localPath,
          localGlobMatch
        ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
        const force = forceMatch === "+";
        const remoteIsGlob = remoteGlobMatch === "*";
        const localIsGlob = localGlobMatch === "*";
        if (remoteIsGlob !== localIsGlob) {
          throw new InternalError("Invalid refspec");
        }
        return new GitRefSpec({
          remotePath,
          localPath,
          force,
          matchPrefix: remoteIsGlob
        });
      }
      translate(remoteBranch) {
        if (this.matchPrefix) {
          if (remoteBranch.startsWith(this.remotePath)) {
            return this.localPath + remoteBranch.replace(this.remotePath, "");
          }
        } else {
          if (remoteBranch === this.remotePath)
            return this.localPath;
        }
        return null;
      }
      reverseTranslate(localBranch) {
        if (this.matchPrefix) {
          if (localBranch.startsWith(this.localPath)) {
            return this.remotePath + localBranch.replace(this.localPath, "");
          }
        } else {
          if (localBranch === this.localPath)
            return this.remotePath;
        }
        return null;
      }
    };
    var GitRefSpecSet = class {
      constructor(rules = []) {
        this.rules = rules;
      }
      static from(refspecs) {
        const rules = [];
        for (const refspec of refspecs) {
          rules.push(GitRefSpec.from(refspec));
        }
        return new GitRefSpecSet(rules);
      }
      add(refspec) {
        const rule = GitRefSpec.from(refspec);
        this.rules.push(rule);
      }
      translate(remoteRefs) {
        const result = [];
        for (const rule of this.rules) {
          for (const remoteRef of remoteRefs) {
            const localRef = rule.translate(remoteRef);
            if (localRef) {
              result.push([remoteRef, localRef]);
            }
          }
        }
        return result;
      }
      translateOne(remoteRef) {
        let result = null;
        for (const rule of this.rules) {
          const localRef = rule.translate(remoteRef);
          if (localRef) {
            result = localRef;
          }
        }
        return result;
      }
      localNamespaces() {
        return this.rules.filter((rule) => rule.matchPrefix).map((rule) => rule.localPath.replace(/\/$/, ""));
      }
    };
    function compareRefNames(a, b) {
      const _a = a.replace(/\^\{\}$/, "");
      const _b = b.replace(/\^\{\}$/, "");
      const tmp = -(_a < _b) || +(_a > _b);
      if (tmp === 0) {
        return a.endsWith("^{}") ? 1 : -1;
      }
      return tmp;
    }
    function normalizePath2(path4) {
      return path4.replace(/\/\.\//g, "/").replace(/\/{2,}/g, "/").replace(/^\/\.$/, "/").replace(/^\.\/$/, ".").replace(/^\.\//, "").replace(/\/\.$/, "").replace(/(.+)\/$/, "$1").replace(/^$/, ".");
    }
    function join(...parts) {
      return normalizePath2(parts.map(normalizePath2).join("/"));
    }
    var num = (val) => {
      val = val.toLowerCase();
      let n = parseInt(val);
      if (val.endsWith("k"))
        n *= 1024;
      if (val.endsWith("m"))
        n *= 1024 * 1024;
      if (val.endsWith("g"))
        n *= 1024 * 1024 * 1024;
      return n;
    };
    var bool = (val) => {
      val = val.trim().toLowerCase();
      if (val === "true" || val === "yes" || val === "on")
        return true;
      if (val === "false" || val === "no" || val === "off")
        return false;
      throw Error(
        `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
      );
    };
    var schema = {
      core: {
        filemode: bool,
        bare: bool,
        logallrefupdates: bool,
        symlinks: bool,
        ignorecase: bool,
        bigFileThreshold: num
      }
    };
    var SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
    var SECTION_REGEX = /^[A-Za-z0-9-.]+$/;
    var VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
    var VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;
    var VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;
    var extractSectionLine = (line) => {
      const matches = SECTION_LINE_REGEX.exec(line);
      if (matches != null) {
        const [section, subsection] = matches.slice(1);
        return [section, subsection];
      }
      return null;
    };
    var extractVariableLine = (line) => {
      const matches = VARIABLE_LINE_REGEX.exec(line);
      if (matches != null) {
        const [name, rawValue = "true"] = matches.slice(1);
        const valueWithoutComments = removeComments(rawValue);
        const valueWithoutQuotes = removeQuotes(valueWithoutComments);
        return [name, valueWithoutQuotes];
      }
      return null;
    };
    var removeComments = (rawValue) => {
      const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
      if (commentMatches == null) {
        return rawValue;
      }
      const [valueWithoutComment, comment] = commentMatches.slice(1);
      if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {
        return `${valueWithoutComment}${comment}`;
      }
      return valueWithoutComment;
    };
    var hasOddNumberOfQuotes = (text) => {
      const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
      return numberOfQuotes % 2 !== 0;
    };
    var removeQuotes = (text) => {
      return text.split("").reduce((newText, c, idx, text2) => {
        const isQuote = c === '"' && text2[idx - 1] !== "\\";
        const isEscapeForQuote = c === "\\" && text2[idx + 1] === '"';
        if (isQuote || isEscapeForQuote) {
          return newText;
        }
        return newText + c;
      }, "");
    };
    var lower2 = (text) => {
      return text != null ? text.toLowerCase() : null;
    };
    var getPath = (section, subsection, name) => {
      return [lower2(section), subsection, lower2(name)].filter((a) => a != null).join(".");
    };
    var normalizePath$1 = (path4) => {
      const pathSegments = path4.split(".");
      const section = pathSegments.shift();
      const name = pathSegments.pop();
      const subsection = pathSegments.length ? pathSegments.join(".") : void 0;
      return {
        section,
        subsection,
        name,
        path: getPath(section, subsection, name),
        sectionPath: getPath(section, subsection, null)
      };
    };
    var findLastIndex = (array, callback) => {
      return array.reduce((lastIndex, item, index2) => {
        return callback(item) ? index2 : lastIndex;
      }, -1);
    };
    var GitConfig = class {
      constructor(text) {
        let section = null;
        let subsection = null;
        this.parsedConfig = text.split("\n").map((line) => {
          let name = null;
          let value = null;
          const trimmedLine = line.trim();
          const extractedSection = extractSectionLine(trimmedLine);
          const isSection = extractedSection != null;
          if (isSection) {
            ;
            [section, subsection] = extractedSection;
          } else {
            const extractedVariable = extractVariableLine(trimmedLine);
            const isVariable = extractedVariable != null;
            if (isVariable) {
              ;
              [name, value] = extractedVariable;
            }
          }
          const path4 = getPath(section, subsection, name);
          return { line, isSection, section, subsection, name, value, path: path4 };
        });
      }
      static from(text) {
        return new GitConfig(text);
      }
      async get(path4, getall = false) {
        const normalizedPath = normalizePath$1(path4).path;
        const allValues = this.parsedConfig.filter((config3) => config3.path === normalizedPath).map(({ section, name, value }) => {
          const fn = schema[section] && schema[section][name];
          return fn ? fn(value) : value;
        });
        return getall ? allValues : allValues.pop();
      }
      async getall(path4) {
        return this.get(path4, true);
      }
      async getSubsections(section) {
        return this.parsedConfig.filter((config3) => config3.section === section && config3.isSection).map((config3) => config3.subsection);
      }
      async deleteSection(section, subsection) {
        this.parsedConfig = this.parsedConfig.filter(
          (config3) => !(config3.section === section && config3.subsection === subsection)
        );
      }
      async append(path4, value) {
        return this.set(path4, value, true);
      }
      async set(path4, value, append = false) {
        const {
          section,
          subsection,
          name,
          path: normalizedPath,
          sectionPath
        } = normalizePath$1(path4);
        const configIndex = findLastIndex(
          this.parsedConfig,
          (config3) => config3.path === normalizedPath
        );
        if (value == null) {
          if (configIndex !== -1) {
            this.parsedConfig.splice(configIndex, 1);
          }
        } else {
          if (configIndex !== -1) {
            const config3 = this.parsedConfig[configIndex];
            const modifiedConfig = Object.assign({}, config3, {
              name,
              value,
              modified: true
            });
            if (append) {
              this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
            } else {
              this.parsedConfig[configIndex] = modifiedConfig;
            }
          } else {
            const sectionIndex = this.parsedConfig.findIndex(
              (config3) => config3.path === sectionPath
            );
            const newConfig = {
              section,
              subsection,
              name,
              value,
              modified: true,
              path: normalizedPath
            };
            if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
              if (sectionIndex >= 0) {
                this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
              } else {
                const newSection = {
                  section,
                  subsection,
                  modified: true,
                  path: sectionPath
                };
                this.parsedConfig.push(newSection, newConfig);
              }
            }
          }
        }
      }
      toString() {
        return this.parsedConfig.map(({ line, section, subsection, name, value, modified: modified2 = false }) => {
          if (!modified2) {
            return line;
          }
          if (name != null && value != null) {
            if (typeof value === "string" && /[#;]/.test(value)) {
              return `	${name} = "${value}"`;
            }
            return `	${name} = ${value}`;
          }
          if (subsection != null) {
            return `[${section} "${subsection}"]`;
          }
          return `[${section}]`;
        }).join("\n");
      }
    };
    var GitConfigManager = class {
      static async get({ fs: fs7, gitdir }) {
        const text = await fs7.read(`${gitdir}/config`, { encoding: "utf8" });
        return GitConfig.from(text);
      }
      static async save({ fs: fs7, gitdir, config: config3 }) {
        await fs7.write(`${gitdir}/config`, config3.toString(), {
          encoding: "utf8"
        });
      }
    };
    var refpaths = (ref) => [
      `${ref}`,
      `refs/${ref}`,
      `refs/tags/${ref}`,
      `refs/heads/${ref}`,
      `refs/remotes/${ref}`,
      `refs/remotes/${ref}/HEAD`
    ];
    var GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
    var GitRefManager = class {
      static async updateRemoteRefs({
        fs: fs7,
        gitdir,
        remote,
        refs,
        symrefs,
        tags,
        refspecs = void 0,
        prune = false,
        pruneTags = false
      }) {
        for (const value of refs.values()) {
          if (!value.match(/[0-9a-f]{40}/)) {
            throw new InvalidOidError(value);
          }
        }
        const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
        if (!refspecs) {
          refspecs = await config3.getall(`remote.${remote}.fetch`);
          if (refspecs.length === 0) {
            throw new NoRefspecError(remote);
          }
          refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
        }
        const refspec = GitRefSpecSet.from(refspecs);
        const actualRefsToWrite = /* @__PURE__ */ new Map();
        if (pruneTags) {
          const tags2 = await GitRefManager.listRefs({
            fs: fs7,
            gitdir,
            filepath: "refs/tags"
          });
          await GitRefManager.deleteRefs({
            fs: fs7,
            gitdir,
            refs: tags2.map((tag2) => `refs/tags/${tag2}`)
          });
        }
        if (tags) {
          for (const serverRef of refs.keys()) {
            if (serverRef.startsWith("refs/tags") && !serverRef.endsWith("^{}")) {
              if (!await GitRefManager.exists({ fs: fs7, gitdir, ref: serverRef })) {
                const oid = refs.get(serverRef);
                actualRefsToWrite.set(serverRef, oid);
              }
            }
          }
        }
        const refTranslations = refspec.translate([...refs.keys()]);
        for (const [serverRef, translatedRef] of refTranslations) {
          const value = refs.get(serverRef);
          actualRefsToWrite.set(translatedRef, value);
        }
        const symrefTranslations = refspec.translate([...symrefs.keys()]);
        for (const [serverRef, translatedRef] of symrefTranslations) {
          const value = symrefs.get(serverRef);
          const symtarget = refspec.translateOne(value);
          if (symtarget) {
            actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
          }
        }
        const pruned = [];
        if (prune) {
          for (const filepath of refspec.localNamespaces()) {
            const refs2 = (await GitRefManager.listRefs({
              fs: fs7,
              gitdir,
              filepath
            })).map((file) => `${filepath}/${file}`);
            for (const ref of refs2) {
              if (!actualRefsToWrite.has(ref)) {
                pruned.push(ref);
              }
            }
          }
          if (pruned.length > 0) {
            await GitRefManager.deleteRefs({ fs: fs7, gitdir, refs: pruned });
          }
        }
        for (const [key, value] of actualRefsToWrite) {
          await fs7.write(join(gitdir, key), `${value.trim()}
`, "utf8");
        }
        return { pruned };
      }
      // TODO: make this less crude?
      static async writeRef({ fs: fs7, gitdir, ref, value }) {
        if (!value.match(/[0-9a-f]{40}/)) {
          throw new InvalidOidError(value);
        }
        await fs7.write(join(gitdir, ref), `${value.trim()}
`, "utf8");
      }
      static async writeSymbolicRef({ fs: fs7, gitdir, ref, value }) {
        await fs7.write(join(gitdir, ref), `ref: ${value.trim()}
`, "utf8");
      }
      static async deleteRef({ fs: fs7, gitdir, ref }) {
        return GitRefManager.deleteRefs({ fs: fs7, gitdir, refs: [ref] });
      }
      static async deleteRefs({ fs: fs7, gitdir, refs }) {
        await Promise.all(refs.map((ref) => fs7.rm(join(gitdir, ref))));
        let text = await fs7.read(`${gitdir}/packed-refs`, { encoding: "utf8" });
        const packed = GitPackedRefs.from(text);
        const beforeSize = packed.refs.size;
        for (const ref of refs) {
          if (packed.refs.has(ref)) {
            packed.delete(ref);
          }
        }
        if (packed.refs.size < beforeSize) {
          text = packed.toString();
          await fs7.write(`${gitdir}/packed-refs`, text, { encoding: "utf8" });
        }
      }
      /**
       * @param {object} args
       * @param {import('../models/FileSystem.js').FileSystem} args.fs
       * @param {string} args.gitdir
       * @param {string} args.ref
       * @param {number} [args.depth]
       * @returns {Promise<string>}
       */
      static async resolve({ fs: fs7, gitdir, ref, depth = void 0 }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return ref;
          }
        }
        let sha;
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return GitRefManager.resolve({ fs: fs7, gitdir, ref, depth });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await GitRefManager.packedRefs({ fs: fs7, gitdir });
        const allpaths = refpaths(ref).filter((p) => !GIT_FILES.includes(p));
        for (const ref2 of allpaths) {
          sha = await fs7.read(`${gitdir}/${ref2}`, { encoding: "utf8" }) || packedMap.get(ref2);
          if (sha) {
            return GitRefManager.resolve({ fs: fs7, gitdir, ref: sha.trim(), depth });
          }
        }
        throw new NotFoundError(ref);
      }
      static async exists({ fs: fs7, gitdir, ref }) {
        try {
          await GitRefManager.expand({ fs: fs7, gitdir, ref });
          return true;
        } catch (err) {
          return false;
        }
      }
      static async expand({ fs: fs7, gitdir, ref }) {
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await GitRefManager.packedRefs({ fs: fs7, gitdir });
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          if (await fs7.exists(`${gitdir}/${ref2}`))
            return ref2;
          if (packedMap.has(ref2))
            return ref2;
        }
        throw new NotFoundError(ref);
      }
      static async expandAgainstMap({ ref, map }) {
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          if (await map.has(ref2))
            return ref2;
        }
        throw new NotFoundError(ref);
      }
      static resolveAgainstMap({ ref, fullref = ref, depth = void 0, map }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return { fullref, oid: ref };
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return { fullref, oid: ref };
        }
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const sha = map.get(ref2);
          if (sha) {
            return GitRefManager.resolveAgainstMap({
              ref: sha.trim(),
              fullref: ref2,
              depth,
              map
            });
          }
        }
        throw new NotFoundError(ref);
      }
      static async packedRefs({ fs: fs7, gitdir }) {
        const text = await fs7.read(`${gitdir}/packed-refs`, { encoding: "utf8" });
        const packed = GitPackedRefs.from(text);
        return packed.refs;
      }
      // List all the refs that match the `filepath` prefix
      static async listRefs({ fs: fs7, gitdir, filepath }) {
        const packedMap = GitRefManager.packedRefs({ fs: fs7, gitdir });
        let files = null;
        try {
          files = await fs7.readdirDeep(`${gitdir}/${filepath}`);
          files = files.map((x2) => x2.replace(`${gitdir}/${filepath}/`, ""));
        } catch (err) {
          files = [];
        }
        for (let key of (await packedMap).keys()) {
          if (key.startsWith(filepath)) {
            key = key.replace(filepath + "/", "");
            if (!files.includes(key)) {
              files.push(key);
            }
          }
        }
        files.sort(compareRefNames);
        return files;
      }
      static async listBranches({ fs: fs7, gitdir, remote }) {
        if (remote) {
          return GitRefManager.listRefs({
            fs: fs7,
            gitdir,
            filepath: `refs/remotes/${remote}`
          });
        } else {
          return GitRefManager.listRefs({ fs: fs7, gitdir, filepath: `refs/heads` });
        }
      }
      static async listTags({ fs: fs7, gitdir }) {
        const tags = await GitRefManager.listRefs({
          fs: fs7,
          gitdir,
          filepath: `refs/tags`
        });
        return tags.filter((x2) => !x2.endsWith("^{}"));
      }
    };
    function compareTreeEntryPath(a, b) {
      return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b));
    }
    function appendSlashIfDir(entry) {
      return entry.mode === "040000" ? entry.path + "/" : entry.path;
    }
    function mode2type$1(mode) {
      switch (mode) {
        case "040000":
          return "tree";
        case "100644":
          return "blob";
        case "100755":
          return "blob";
        case "120000":
          return "blob";
        case "160000":
          return "commit";
      }
      throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
    }
    function parseBuffer(buffer) {
      const _entries = [];
      let cursor = 0;
      while (cursor < buffer.length) {
        const space = buffer.indexOf(32, cursor);
        if (space === -1) {
          throw new InternalError(
            `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
          );
        }
        const nullchar = buffer.indexOf(0, cursor);
        if (nullchar === -1) {
          throw new InternalError(
            `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
          );
        }
        let mode = buffer.slice(cursor, space).toString("utf8");
        if (mode === "40000")
          mode = "040000";
        const type = mode2type$1(mode);
        const path4 = buffer.slice(space + 1, nullchar).toString("utf8");
        if (path4.includes("\\") || path4.includes("/")) {
          throw new UnsafeFilepathError(path4);
        }
        const oid = buffer.slice(nullchar + 1, nullchar + 21).toString("hex");
        cursor = nullchar + 21;
        _entries.push({ mode, path: path4, oid, type });
      }
      return _entries;
    }
    function limitModeToAllowed(mode) {
      if (typeof mode === "number") {
        mode = mode.toString(8);
      }
      if (mode.match(/^0?4.*/))
        return "040000";
      if (mode.match(/^1006.*/))
        return "100644";
      if (mode.match(/^1007.*/))
        return "100755";
      if (mode.match(/^120.*/))
        return "120000";
      if (mode.match(/^160.*/))
        return "160000";
      throw new InternalError(`Could not understand file mode: ${mode}`);
    }
    function nudgeIntoShape(entry) {
      if (!entry.oid && entry.sha) {
        entry.oid = entry.sha;
      }
      entry.mode = limitModeToAllowed(entry.mode);
      if (!entry.type) {
        entry.type = mode2type$1(entry.mode);
      }
      return entry;
    }
    var GitTree = class {
      constructor(entries) {
        if (Buffer.isBuffer(entries)) {
          this._entries = parseBuffer(entries);
        } else if (Array.isArray(entries)) {
          this._entries = entries.map(nudgeIntoShape);
        } else {
          throw new InternalError("invalid type passed to GitTree constructor");
        }
        this._entries.sort(comparePath);
      }
      static from(tree) {
        return new GitTree(tree);
      }
      render() {
        return this._entries.map((entry) => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join("\n");
      }
      toObject() {
        const entries = [...this._entries];
        entries.sort(compareTreeEntryPath);
        return Buffer.concat(
          entries.map((entry) => {
            const mode = Buffer.from(entry.mode.replace(/^0/, ""));
            const space = Buffer.from(" ");
            const path4 = Buffer.from(entry.path, "utf8");
            const nullchar = Buffer.from([0]);
            const oid = Buffer.from(entry.oid, "hex");
            return Buffer.concat([mode, space, path4, nullchar, oid]);
          })
        );
      }
      /**
       * @returns {TreeEntry[]}
       */
      entries() {
        return this._entries;
      }
      *[Symbol.iterator]() {
        for (const entry of this._entries) {
          yield entry;
        }
      }
    };
    var GitObject = class {
      static wrap({ type, object }) {
        return Buffer.concat([
          Buffer.from(`${type} ${object.byteLength.toString()}\0`),
          Buffer.from(object)
        ]);
      }
      static unwrap(buffer) {
        const s2 = buffer.indexOf(32);
        const i2 = buffer.indexOf(0);
        const type = buffer.slice(0, s2).toString("utf8");
        const length = buffer.slice(s2 + 1, i2).toString("utf8");
        const actualLength = buffer.length - (i2 + 1);
        if (parseInt(length) !== actualLength) {
          throw new InternalError(
            `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
          );
        }
        return {
          type,
          object: Buffer.from(buffer.slice(i2 + 1))
        };
      }
    };
    async function readObjectLoose({ fs: fs7, gitdir, oid }) {
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      const file = await fs7.read(`${gitdir}/${source}`);
      if (!file) {
        return null;
      }
      return { object: file, format: "deflated", source };
    }
    function applyDelta(delta, source) {
      const reader = new BufferCursor(delta);
      const sourceSize = readVarIntLE(reader);
      if (sourceSize !== source.byteLength) {
        throw new InternalError(
          `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
        );
      }
      const targetSize = readVarIntLE(reader);
      let target;
      const firstOp = readOp(reader, source);
      if (firstOp.byteLength === targetSize) {
        target = firstOp;
      } else {
        target = Buffer.alloc(targetSize);
        const writer = new BufferCursor(target);
        writer.copy(firstOp);
        while (!reader.eof()) {
          writer.copy(readOp(reader, source));
        }
        const tell = writer.tell();
        if (targetSize !== tell) {
          throw new InternalError(
            `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
          );
        }
      }
      return target;
    }
    function readVarIntLE(reader) {
      let result = 0;
      let shift = 0;
      let byte = null;
      do {
        byte = reader.readUInt8();
        result |= (byte & 127) << shift;
        shift += 7;
      } while (byte & 128);
      return result;
    }
    function readCompactLE(reader, flags, size) {
      let result = 0;
      let shift = 0;
      while (size--) {
        if (flags & 1) {
          result |= reader.readUInt8() << shift;
        }
        flags >>= 1;
        shift += 8;
      }
      return result;
    }
    function readOp(reader, source) {
      const byte = reader.readUInt8();
      const COPY = 128;
      const OFFS = 15;
      const SIZE = 112;
      if (byte & COPY) {
        const offset = readCompactLE(reader, byte & OFFS, 4);
        let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);
        if (size === 0)
          size = 65536;
        return source.slice(offset, offset + size);
      } else {
        return reader.slice(byte);
      }
    }
    function fromValue(value) {
      let queue = [value];
      return {
        next() {
          return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
        },
        return() {
          queue = [];
          return {};
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    function getIterator(iterable) {
      if (iterable[Symbol.asyncIterator]) {
        return iterable[Symbol.asyncIterator]();
      }
      if (iterable[Symbol.iterator]) {
        return iterable[Symbol.iterator]();
      }
      if (iterable.next) {
        return iterable;
      }
      return fromValue(iterable);
    }
    var StreamReader = class {
      constructor(stream) {
        this.stream = getIterator(stream);
        this.buffer = null;
        this.cursor = 0;
        this.undoCursor = 0;
        this.started = false;
        this._ended = false;
        this._discardedBytes = 0;
      }
      eof() {
        return this._ended && this.cursor === this.buffer.length;
      }
      tell() {
        return this._discardedBytes + this.cursor;
      }
      async byte() {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended)
            return;
        }
        this._moveCursor(1);
        return this.buffer[this.undoCursor];
      }
      async chunk() {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended)
            return;
        }
        this._moveCursor(this.buffer.length);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async read(n) {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor + n > this.buffer.length) {
          this._trim();
          await this._accumulate(n);
        }
        this._moveCursor(n);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async skip(n) {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor + n > this.buffer.length) {
          this._trim();
          await this._accumulate(n);
        }
        this._moveCursor(n);
      }
      async undo() {
        this.cursor = this.undoCursor;
      }
      async _next() {
        this.started = true;
        let { done, value } = await this.stream.next();
        if (done) {
          this._ended = true;
        }
        if (value) {
          value = Buffer.from(value);
        }
        return value;
      }
      _trim() {
        this.buffer = this.buffer.slice(this.undoCursor);
        this.cursor -= this.undoCursor;
        this._discardedBytes += this.undoCursor;
        this.undoCursor = 0;
      }
      _moveCursor(n) {
        this.undoCursor = this.cursor;
        this.cursor += n;
        if (this.cursor > this.buffer.length) {
          this.cursor = this.buffer.length;
        }
      }
      async _accumulate(n) {
        if (this._ended)
          return;
        const buffers = [this.buffer];
        while (this.cursor + n > lengthBuffers(buffers)) {
          const nextbuffer = await this._next();
          if (this._ended)
            break;
          buffers.push(nextbuffer);
        }
        this.buffer = Buffer.concat(buffers);
      }
      async _loadnext() {
        this._discardedBytes += this.buffer.length;
        this.undoCursor = 0;
        this.cursor = 0;
        this.buffer = await this._next();
      }
      async _init() {
        this.buffer = await this._next();
      }
    };
    function lengthBuffers(buffers) {
      return buffers.reduce((acc, buffer) => acc + buffer.length, 0);
    }
    async function listpack(stream, onData) {
      const reader = new StreamReader(stream);
      let PACK = await reader.read(4);
      PACK = PACK.toString("utf8");
      if (PACK !== "PACK") {
        throw new InternalError(`Invalid PACK header '${PACK}'`);
      }
      let version3 = await reader.read(4);
      version3 = version3.readUInt32BE(0);
      if (version3 !== 2) {
        throw new InternalError(`Invalid packfile version: ${version3}`);
      }
      let numObjects = await reader.read(4);
      numObjects = numObjects.readUInt32BE(0);
      if (numObjects < 1)
        return;
      while (!reader.eof() && numObjects--) {
        const offset = reader.tell();
        const { type, length, ofs, reference } = await parseHeader(reader);
        const inflator = new pako.Inflate();
        while (!inflator.result) {
          const chunk = await reader.chunk();
          if (!chunk)
            break;
          inflator.push(chunk, false);
          if (inflator.err) {
            throw new InternalError(`Pako error: ${inflator.msg}`);
          }
          if (inflator.result) {
            if (inflator.result.length !== length) {
              throw new InternalError(
                `Inflated object size is different from that stated in packfile.`
              );
            }
            await reader.undo();
            await reader.read(chunk.length - inflator.strm.avail_in);
            const end = reader.tell();
            await onData({
              data: inflator.result,
              type,
              num: numObjects,
              offset,
              end,
              reference,
              ofs
            });
          }
        }
      }
    }
    async function parseHeader(reader) {
      let byte = await reader.byte();
      const type = byte >> 4 & 7;
      let length = byte & 15;
      if (byte & 128) {
        let shift = 4;
        do {
          byte = await reader.byte();
          length |= (byte & 127) << shift;
          shift += 7;
        } while (byte & 128);
      }
      let ofs;
      let reference;
      if (type === 6) {
        let shift = 0;
        ofs = 0;
        const bytes = [];
        do {
          byte = await reader.byte();
          ofs |= (byte & 127) << shift;
          shift += 7;
          bytes.push(byte);
        } while (byte & 128);
        reference = Buffer.from(bytes);
      }
      if (type === 7) {
        const buf = await reader.read(20);
        reference = buf;
      }
      return { type, length, ofs, reference };
    }
    var supportsDecompressionStream = false;
    async function inflate(buffer) {
      if (supportsDecompressionStream === null) {
        supportsDecompressionStream = testDecompressionStream();
      }
      return supportsDecompressionStream ? browserInflate(buffer) : pako.inflate(buffer);
    }
    async function browserInflate(buffer) {
      const ds = new DecompressionStream("deflate");
      const d = new Blob([buffer]).stream().pipeThrough(ds);
      return new Uint8Array(await new Response(d).arrayBuffer());
    }
    function testDecompressionStream() {
      try {
        const ds = new DecompressionStream("deflate");
        if (ds)
          return true;
      } catch (_) {
      }
      return false;
    }
    function decodeVarInt(reader) {
      const bytes = [];
      let byte = 0;
      let multibyte = 0;
      do {
        byte = reader.readUInt8();
        const lastSeven = byte & 127;
        bytes.push(lastSeven);
        multibyte = byte & 128;
      } while (multibyte);
      return bytes.reduce((a, b) => a + 1 << 7 | b, -1);
    }
    function otherVarIntDecode(reader, startWith) {
      let result = startWith;
      let shift = 4;
      let byte = null;
      do {
        byte = reader.readUInt8();
        result |= (byte & 127) << shift;
        shift += 7;
      } while (byte & 128);
      return result;
    }
    var GitPackIndex = class {
      constructor(stuff) {
        Object.assign(this, stuff);
        this.offsetCache = {};
      }
      static async fromIdx({ idx, getExternalRefDelta }) {
        const reader = new BufferCursor(idx);
        const magic = reader.slice(4).toString("hex");
        if (magic !== "ff744f63") {
          return;
        }
        const version3 = reader.readUInt32BE();
        if (version3 !== 2) {
          throw new InternalError(
            `Unable to read version ${version3} packfile IDX. (Only version 2 supported)`
          );
        }
        if (idx.byteLength > 2048 * 1024 * 1024) {
          throw new InternalError(
            `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
          );
        }
        reader.seek(reader.tell() + 4 * 255);
        const size = reader.readUInt32BE();
        const hashes = [];
        for (let i2 = 0; i2 < size; i2++) {
          const hash = reader.slice(20).toString("hex");
          hashes[i2] = hash;
        }
        reader.seek(reader.tell() + 4 * size);
        const offsets = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < size; i2++) {
          offsets.set(hashes[i2], reader.readUInt32BE());
        }
        const packfileSha = reader.slice(20).toString("hex");
        return new GitPackIndex({
          hashes,
          crcs: {},
          offsets,
          packfileSha,
          getExternalRefDelta
        });
      }
      static async fromPack({ pack, getExternalRefDelta, onProgress }) {
        const listpackTypes = {
          1: "commit",
          2: "tree",
          3: "blob",
          4: "tag",
          6: "ofs-delta",
          7: "ref-delta"
        };
        const offsetToObject = {};
        const packfileSha = pack.slice(-20).toString("hex");
        const hashes = [];
        const crcs = {};
        const offsets = /* @__PURE__ */ new Map();
        let totalObjectCount = null;
        let lastPercent = null;
        await listpack([pack], async ({ data, type, reference, offset, num: num2 }) => {
          if (totalObjectCount === null)
            totalObjectCount = num2;
          const percent = Math.floor(
            (totalObjectCount - num2) * 100 / totalObjectCount
          );
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Receiving objects",
                loaded: totalObjectCount - num2,
                total: totalObjectCount
              });
            }
          }
          lastPercent = percent;
          type = listpackTypes[type];
          if (["commit", "tree", "blob", "tag"].includes(type)) {
            offsetToObject[offset] = {
              type,
              offset
            };
          } else if (type === "ofs-delta") {
            offsetToObject[offset] = {
              type,
              offset
            };
          } else if (type === "ref-delta") {
            offsetToObject[offset] = {
              type,
              offset
            };
          }
        });
        const offsetArray = Object.keys(offsetToObject).map(Number);
        for (const [i2, start] of offsetArray.entries()) {
          const end = i2 + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i2 + 1];
          const o = offsetToObject[start];
          const crc = crc32.buf(pack.slice(start, end)) >>> 0;
          o.end = end;
          o.crc = crc;
        }
        const p = new GitPackIndex({
          pack: Promise.resolve(pack),
          packfileSha,
          crcs,
          hashes,
          offsets,
          getExternalRefDelta
        });
        lastPercent = null;
        let count = 0;
        const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let offset in offsetToObject) {
          offset = Number(offset);
          const percent = Math.floor(count * 100 / totalObjectCount);
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Resolving deltas",
                loaded: count,
                total: totalObjectCount
              });
            }
          }
          count++;
          lastPercent = percent;
          const o = offsetToObject[offset];
          if (o.oid)
            continue;
          try {
            p.readDepth = 0;
            p.externalReadDepth = 0;
            const { type, object } = await p.readSlice({ start: offset });
            objectsByDepth[p.readDepth] += 1;
            const oid = await shasum(GitObject.wrap({ type, object }));
            o.oid = oid;
            hashes.push(oid);
            offsets.set(oid, offset);
            crcs[oid] = o.crc;
          } catch (err) {
            continue;
          }
        }
        hashes.sort();
        return p;
      }
      async toBuffer() {
        const buffers = [];
        const write = (str, encoding) => {
          buffers.push(Buffer.from(str, encoding));
        };
        write("ff744f63", "hex");
        write("00000002", "hex");
        const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
        for (let i2 = 0; i2 < 256; i2++) {
          let count = 0;
          for (const hash of this.hashes) {
            if (parseInt(hash.slice(0, 2), 16) <= i2)
              count++;
          }
          fanoutBuffer.writeUInt32BE(count);
        }
        buffers.push(fanoutBuffer.buffer);
        for (const hash of this.hashes) {
          write(hash, "hex");
        }
        const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash of this.hashes) {
          crcsBuffer.writeUInt32BE(this.crcs[hash]);
        }
        buffers.push(crcsBuffer.buffer);
        const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash of this.hashes) {
          offsetsBuffer.writeUInt32BE(this.offsets.get(hash));
        }
        buffers.push(offsetsBuffer.buffer);
        write(this.packfileSha, "hex");
        const totalBuffer = Buffer.concat(buffers);
        const sha = await shasum(totalBuffer);
        const shaBuffer = Buffer.alloc(20);
        shaBuffer.write(sha, "hex");
        return Buffer.concat([totalBuffer, shaBuffer]);
      }
      async load({ pack }) {
        this.pack = pack;
      }
      async unload() {
        this.pack = null;
      }
      async read({ oid }) {
        if (!this.offsets.get(oid)) {
          if (this.getExternalRefDelta) {
            this.externalReadDepth++;
            return this.getExternalRefDelta(oid);
          } else {
            throw new InternalError(`Could not read object ${oid} from packfile`);
          }
        }
        const start = this.offsets.get(oid);
        return this.readSlice({ start });
      }
      async readSlice({ start }) {
        if (this.offsetCache[start]) {
          return Object.assign({}, this.offsetCache[start]);
        }
        this.readDepth++;
        const types4 = {
          16: "commit",
          32: "tree",
          48: "blob",
          64: "tag",
          96: "ofs_delta",
          112: "ref_delta"
        };
        if (!this.pack) {
          throw new InternalError(
            "Tried to read from a GitPackIndex with no packfile loaded into memory"
          );
        }
        const raw2 = (await this.pack).slice(start);
        const reader = new BufferCursor(raw2);
        const byte = reader.readUInt8();
        const btype = byte & 112;
        let type = types4[btype];
        if (type === void 0) {
          throw new InternalError("Unrecognized type: 0b" + btype.toString(2));
        }
        const lastFour = byte & 15;
        let length = lastFour;
        const multibyte = byte & 128;
        if (multibyte) {
          length = otherVarIntDecode(reader, lastFour);
        }
        let base = null;
        let object = null;
        if (type === "ofs_delta") {
          const offset = decodeVarInt(reader);
          const baseOffset = start - offset;
          ({ object: base, type } = await this.readSlice({ start: baseOffset }));
        }
        if (type === "ref_delta") {
          const oid = reader.slice(20).toString("hex");
          ({ object: base, type } = await this.read({ oid }));
        }
        const buffer = raw2.slice(reader.tell());
        object = Buffer.from(await inflate(buffer));
        if (object.byteLength !== length) {
          throw new InternalError(
            `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
          );
        }
        if (base) {
          object = Buffer.from(applyDelta(object, base));
        }
        if (this.readDepth > 3) {
          this.offsetCache[start] = { type, object };
        }
        return { type, format: "content", object };
      }
    };
    var PackfileCache = Symbol("PackfileCache");
    async function loadPackIndex({
      fs: fs7,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    }) {
      const idx = await fs7.read(filename);
      return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
    }
    function readPackIndex({
      fs: fs7,
      cache,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    }) {
      if (!cache[PackfileCache])
        cache[PackfileCache] = /* @__PURE__ */ new Map();
      let p = cache[PackfileCache].get(filename);
      if (!p) {
        p = loadPackIndex({
          fs: fs7,
          filename,
          getExternalRefDelta,
          emitter,
          emitterPrefix
        });
        cache[PackfileCache].set(filename, p);
      }
      return p;
    }
    async function readObjectPacked({
      fs: fs7,
      cache,
      gitdir,
      oid,
      format = "content",
      getExternalRefDelta
    }) {
      let list = await fs7.readdir(join(gitdir, "objects/pack"));
      list = list.filter((x2) => x2.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs: fs7,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error)
          throw new InternalError(p.error);
        if (p.offsets.has(oid)) {
          if (!p.pack) {
            const packFile = indexFile.replace(/idx$/, "pack");
            p.pack = fs7.read(packFile);
          }
          const result = await p.read({ oid, getExternalRefDelta });
          result.format = "content";
          result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
          return result;
        }
      }
      return null;
    }
    async function _readObject({
      fs: fs7,
      cache,
      gitdir,
      oid,
      format = "content"
    }) {
      const getExternalRefDelta = (oid2) => _readObject({ fs: fs7, cache, gitdir, oid: oid2 });
      let result;
      if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
        result = { format: "wrapped", object: Buffer.from(`tree 0\0`) };
      }
      if (!result) {
        result = await readObjectLoose({ fs: fs7, gitdir, oid });
      }
      if (!result) {
        result = await readObjectPacked({
          fs: fs7,
          cache,
          gitdir,
          oid,
          getExternalRefDelta
        });
      }
      if (!result) {
        throw new NotFoundError(oid);
      }
      if (format === "deflated") {
        return result;
      }
      if (result.format === "deflated") {
        result.object = Buffer.from(await inflate(result.object));
        result.format = "wrapped";
      }
      if (result.format === "wrapped") {
        if (format === "wrapped" && result.format === "wrapped") {
          return result;
        }
        const sha = await shasum(result.object);
        if (sha !== oid) {
          throw new InternalError(
            `SHA check failed! Expected ${oid}, computed ${sha}`
          );
        }
        const { object, type } = GitObject.unwrap(result.object);
        result.type = type;
        result.object = object;
        result.format = "content";
      }
      if (result.format === "content") {
        if (format === "content")
          return result;
        return;
      }
      throw new InternalError(`invalid format "${result.format}"`);
    }
    var AlreadyExistsError = class extends BaseError {
      /**
       * @param {'note'|'remote'|'tag'|'branch'} noun
       * @param {string} where
       * @param {boolean} canForce
       */
      constructor(noun, where, canForce = true) {
        super(
          `Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ""}`
        );
        this.code = this.name = AlreadyExistsError.code;
        this.data = { noun, where, canForce };
      }
    };
    AlreadyExistsError.code = "AlreadyExistsError";
    var AmbiguousError = class extends BaseError {
      /**
       * @param {'oids'|'refs'} nouns
       * @param {string} short
       * @param {string[]} matches
       */
      constructor(nouns, short, matches) {
        super(
          `Found multiple ${nouns} matching "${short}" (${matches.join(
            ", "
          )}). Use a longer abbreviation length to disambiguate them.`
        );
        this.code = this.name = AmbiguousError.code;
        this.data = { nouns, short, matches };
      }
    };
    AmbiguousError.code = "AmbiguousError";
    var CheckoutConflictError = class extends BaseError {
      /**
       * @param {string[]} filepaths
       */
      constructor(filepaths) {
        super(
          `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
            ", "
          )}`
        );
        this.code = this.name = CheckoutConflictError.code;
        this.data = { filepaths };
      }
    };
    CheckoutConflictError.code = "CheckoutConflictError";
    var CommitNotFetchedError = class extends BaseError {
      /**
       * @param {string} ref
       * @param {string} oid
       */
      constructor(ref, oid) {
        super(
          `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
        );
        this.code = this.name = CommitNotFetchedError.code;
        this.data = { ref, oid };
      }
    };
    CommitNotFetchedError.code = "CommitNotFetchedError";
    var EmptyServerResponseError = class extends BaseError {
      constructor() {
        super(`Empty response from git server.`);
        this.code = this.name = EmptyServerResponseError.code;
        this.data = {};
      }
    };
    EmptyServerResponseError.code = "EmptyServerResponseError";
    var FastForwardError = class extends BaseError {
      constructor() {
        super(`A simple fast-forward merge was not possible.`);
        this.code = this.name = FastForwardError.code;
        this.data = {};
      }
    };
    FastForwardError.code = "FastForwardError";
    var GitPushError = class extends BaseError {
      /**
       * @param {string} prettyDetails
       * @param {PushResult} result
       */
      constructor(prettyDetails, result) {
        super(`One or more branches were not updated: ${prettyDetails}`);
        this.code = this.name = GitPushError.code;
        this.data = { prettyDetails, result };
      }
    };
    GitPushError.code = "GitPushError";
    var HttpError = class extends BaseError {
      /**
       * @param {number} statusCode
       * @param {string} statusMessage
       * @param {string} response
       */
      constructor(statusCode, statusMessage, response) {
        super(`HTTP Error: ${statusCode} ${statusMessage}`);
        this.code = this.name = HttpError.code;
        this.data = { statusCode, statusMessage, response };
      }
    };
    HttpError.code = "HttpError";
    var InvalidFilepathError = class extends BaseError {
      /**
       * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
       */
      constructor(reason) {
        let message = "invalid filepath";
        if (reason === "leading-slash" || reason === "trailing-slash") {
          message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
        } else if (reason === "directory") {
          message = `"filepath" should not be a directory.`;
        }
        super(message);
        this.code = this.name = InvalidFilepathError.code;
        this.data = { reason };
      }
    };
    InvalidFilepathError.code = "InvalidFilepathError";
    var InvalidRefNameError = class extends BaseError {
      /**
       * @param {string} ref
       * @param {string} suggestion
       * @param {boolean} canForce
       */
      constructor(ref, suggestion) {
        super(
          `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
        );
        this.code = this.name = InvalidRefNameError.code;
        this.data = { ref, suggestion };
      }
    };
    InvalidRefNameError.code = "InvalidRefNameError";
    var MaxDepthError = class extends BaseError {
      /**
       * @param {number} depth
       */
      constructor(depth) {
        super(`Maximum search depth of ${depth} exceeded.`);
        this.code = this.name = MaxDepthError.code;
        this.data = { depth };
      }
    };
    MaxDepthError.code = "MaxDepthError";
    var MergeNotSupportedError = class extends BaseError {
      constructor() {
        super(`Merges with conflicts are not supported yet.`);
        this.code = this.name = MergeNotSupportedError.code;
        this.data = {};
      }
    };
    MergeNotSupportedError.code = "MergeNotSupportedError";
    var MergeConflictError = class extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepaths) {
        super(
          `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
        );
        this.code = this.name = MergeConflictError.code;
        this.data = { filepaths };
      }
    };
    MergeConflictError.code = "MergeConflictError";
    var MissingNameError = class extends BaseError {
      /**
       * @param {'author'|'committer'|'tagger'} role
       */
      constructor(role) {
        super(
          `No name was provided for ${role} in the argument or in the .git/config file.`
        );
        this.code = this.name = MissingNameError.code;
        this.data = { role };
      }
    };
    MissingNameError.code = "MissingNameError";
    var MissingParameterError = class extends BaseError {
      /**
       * @param {string} parameter
       */
      constructor(parameter) {
        super(
          `The function requires a "${parameter}" parameter but none was provided.`
        );
        this.code = this.name = MissingParameterError.code;
        this.data = { parameter };
      }
    };
    MissingParameterError.code = "MissingParameterError";
    var MultipleGitError = class extends BaseError {
      /**
       * @param {Error[]} errors
       * @param {string} message
       */
      constructor(errors) {
        super(
          `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
        );
        this.code = this.name = MultipleGitError.code;
        this.data = { errors };
        this.errors = errors;
      }
    };
    MultipleGitError.code = "MultipleGitError";
    var ParseError = class extends BaseError {
      /**
       * @param {string} expected
       * @param {string} actual
       */
      constructor(expected, actual) {
        super(`Expected "${expected}" but received "${actual}".`);
        this.code = this.name = ParseError.code;
        this.data = { expected, actual };
      }
    };
    ParseError.code = "ParseError";
    var PushRejectedError = class extends BaseError {
      /**
       * @param {'not-fast-forward'|'tag-exists'} reason
       */
      constructor(reason) {
        let message = "";
        if (reason === "not-fast-forward") {
          message = " because it was not a simple fast-forward";
        } else if (reason === "tag-exists") {
          message = " because tag already exists";
        }
        super(`Push rejected${message}. Use "force: true" to override.`);
        this.code = this.name = PushRejectedError.code;
        this.data = { reason };
      }
    };
    PushRejectedError.code = "PushRejectedError";
    var RemoteCapabilityError = class extends BaseError {
      /**
       * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
       * @param {'depth'|'since'|'exclude'|'relative'} parameter
       */
      constructor(capability, parameter) {
        super(
          `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
        );
        this.code = this.name = RemoteCapabilityError.code;
        this.data = { capability, parameter };
      }
    };
    RemoteCapabilityError.code = "RemoteCapabilityError";
    var SmartHttpError = class extends BaseError {
      /**
       * @param {string} preview
       * @param {string} response
       */
      constructor(preview, response) {
        super(
          `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
        );
        this.code = this.name = SmartHttpError.code;
        this.data = { preview, response };
      }
    };
    SmartHttpError.code = "SmartHttpError";
    var UnknownTransportError = class extends BaseError {
      /**
       * @param {string} url
       * @param {string} transport
       * @param {string} [suggestion]
       */
      constructor(url, transport, suggestion) {
        super(
          `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
        );
        this.code = this.name = UnknownTransportError.code;
        this.data = { url, transport, suggestion };
      }
    };
    UnknownTransportError.code = "UnknownTransportError";
    var UrlParseError = class extends BaseError {
      /**
       * @param {string} url
       */
      constructor(url) {
        super(`Cannot parse remote URL: "${url}"`);
        this.code = this.name = UrlParseError.code;
        this.data = { url };
      }
    };
    UrlParseError.code = "UrlParseError";
    var UserCanceledError = class extends BaseError {
      constructor() {
        super(`The operation was canceled.`);
        this.code = this.name = UserCanceledError.code;
        this.data = {};
      }
    };
    UserCanceledError.code = "UserCanceledError";
    var IndexResetError = class extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepath) {
        super(
          `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`
        );
        this.code = this.name = IndexResetError.code;
        this.data = { filepath };
      }
    };
    IndexResetError.code = "IndexResetError";
    var Errors = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AlreadyExistsError,
      AmbiguousError,
      CheckoutConflictError,
      CommitNotFetchedError,
      EmptyServerResponseError,
      FastForwardError,
      GitPushError,
      HttpError,
      InternalError,
      InvalidFilepathError,
      InvalidOidError,
      InvalidRefNameError,
      MaxDepthError,
      MergeNotSupportedError,
      MergeConflictError,
      MissingNameError,
      MissingParameterError,
      MultipleGitError,
      NoRefspecError,
      NotFoundError,
      ObjectTypeError,
      ParseError,
      PushRejectedError,
      RemoteCapabilityError,
      SmartHttpError,
      UnknownTransportError,
      UnsafeFilepathError,
      UrlParseError,
      UserCanceledError,
      UnmergedPathsError,
      IndexResetError
    });
    function formatAuthor({ name, email, timestamp, timezoneOffset }) {
      timezoneOffset = formatTimezoneOffset(timezoneOffset);
      return `${name} <${email}> ${timestamp} ${timezoneOffset}`;
    }
    function formatTimezoneOffset(minutes) {
      const sign = simpleSign(negateExceptForZero(minutes));
      minutes = Math.abs(minutes);
      const hours = Math.floor(minutes / 60);
      minutes -= hours * 60;
      let strHours = String(hours);
      let strMinutes = String(minutes);
      if (strHours.length < 2)
        strHours = "0" + strHours;
      if (strMinutes.length < 2)
        strMinutes = "0" + strMinutes;
      return (sign === -1 ? "-" : "+") + strHours + strMinutes;
    }
    function simpleSign(n) {
      return Math.sign(n) || (Object.is(n, -0) ? -1 : 1);
    }
    function negateExceptForZero(n) {
      return n === 0 ? n : -n;
    }
    function normalizeNewlines(str) {
      str = str.replace(/\r/g, "");
      str = str.replace(/^\n+/, "");
      str = str.replace(/\n+$/, "") + "\n";
      return str;
    }
    function parseAuthor(author) {
      const [, name, email, timestamp, offset] = author.match(
        /^(.*) <(.*)> (.*) (.*)$/
      );
      return {
        name,
        email,
        timestamp: Number(timestamp),
        timezoneOffset: parseTimezoneOffset(offset)
      };
    }
    function parseTimezoneOffset(offset) {
      let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
      minutes = (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
      return negateExceptForZero$1(minutes);
    }
    function negateExceptForZero$1(n) {
      return n === 0 ? n : -n;
    }
    var GitAnnotatedTag = class {
      constructor(tag2) {
        if (typeof tag2 === "string") {
          this._tag = tag2;
        } else if (Buffer.isBuffer(tag2)) {
          this._tag = tag2.toString("utf8");
        } else if (typeof tag2 === "object") {
          this._tag = GitAnnotatedTag.render(tag2);
        } else {
          throw new InternalError(
            "invalid type passed to GitAnnotatedTag constructor"
          );
        }
      }
      static from(tag2) {
        return new GitAnnotatedTag(tag2);
      }
      static render(obj) {
        return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
      }
      justHeaders() {
        return this._tag.slice(0, this._tag.indexOf("\n\n"));
      }
      message() {
        const tag2 = this.withoutSignature();
        return tag2.slice(tag2.indexOf("\n\n") + 2);
      }
      parse() {
        return Object.assign(this.headers(), {
          message: this.message(),
          gpgsig: this.gpgsig()
        });
      }
      render() {
        return this._tag;
      }
      headers() {
        const headers = this.justHeaders().split("\n");
        const hs = [];
        for (const h2 of headers) {
          if (h2[0] === " ") {
            hs[hs.length - 1] += "\n" + h2.slice(1);
          } else {
            hs.push(h2);
          }
        }
        const obj = {};
        for (const h2 of hs) {
          const key = h2.slice(0, h2.indexOf(" "));
          const value = h2.slice(h2.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.tagger) {
          obj.tagger = parseAuthor(obj.tagger);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      withoutSignature() {
        const tag2 = normalizeNewlines(this._tag);
        if (tag2.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
          return tag2;
        return tag2.slice(0, tag2.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
      }
      gpgsig() {
        if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
          return;
        const signature = this._tag.slice(
          this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return normalizeNewlines(signature);
      }
      payload() {
        return this.withoutSignature() + "\n";
      }
      toObject() {
        return Buffer.from(this._tag, "utf8");
      }
      static async sign(tag2, sign, secretKey) {
        const payload = tag2.payload();
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const signedTag = payload + signature;
        return GitAnnotatedTag.from(signedTag);
      }
    };
    function indent(str) {
      return str.trim().split("\n").map((x2) => " " + x2).join("\n") + "\n";
    }
    function outdent(str) {
      return str.split("\n").map((x2) => x2.replace(/^ /, "")).join("\n");
    }
    var GitCommit = class {
      constructor(commit2) {
        if (typeof commit2 === "string") {
          this._commit = commit2;
        } else if (Buffer.isBuffer(commit2)) {
          this._commit = commit2.toString("utf8");
        } else if (typeof commit2 === "object") {
          this._commit = GitCommit.render(commit2);
        } else {
          throw new InternalError("invalid type passed to GitCommit constructor");
        }
      }
      static fromPayloadSignature({ payload, signature }) {
        const headers = GitCommit.justHeaders(payload);
        const message = GitCommit.justMessage(payload);
        const commit2 = normalizeNewlines(
          headers + "\ngpgsig" + indent(signature) + "\n" + message
        );
        return new GitCommit(commit2);
      }
      static from(commit2) {
        return new GitCommit(commit2);
      }
      toObject() {
        return Buffer.from(this._commit, "utf8");
      }
      // Todo: allow setting the headers and message
      headers() {
        return this.parseHeaders();
      }
      // Todo: allow setting the headers and message
      message() {
        return GitCommit.justMessage(this._commit);
      }
      parse() {
        return Object.assign({ message: this.message() }, this.headers());
      }
      static justMessage(commit2) {
        return normalizeNewlines(commit2.slice(commit2.indexOf("\n\n") + 2));
      }
      static justHeaders(commit2) {
        return commit2.slice(0, commit2.indexOf("\n\n"));
      }
      parseHeaders() {
        const headers = GitCommit.justHeaders(this._commit).split("\n");
        const hs = [];
        for (const h2 of headers) {
          if (h2[0] === " ") {
            hs[hs.length - 1] += "\n" + h2.slice(1);
          } else {
            hs.push(h2);
          }
        }
        const obj = {
          parent: []
        };
        for (const h2 of hs) {
          const key = h2.slice(0, h2.indexOf(" "));
          const value = h2.slice(h2.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.author) {
          obj.author = parseAuthor(obj.author);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      static renderHeaders(obj) {
        let headers = "";
        if (obj.tree) {
          headers += `tree ${obj.tree}
`;
        } else {
          headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`;
        }
        if (obj.parent) {
          if (obj.parent.length === void 0) {
            throw new InternalError(`commit 'parent' property should be an array`);
          }
          for (const p of obj.parent) {
            headers += `parent ${p}
`;
          }
        }
        const author = obj.author;
        headers += `author ${formatAuthor(author)}
`;
        const committer = obj.committer || obj.author;
        headers += `committer ${formatAuthor(committer)}
`;
        if (obj.gpgsig) {
          headers += "gpgsig" + indent(obj.gpgsig);
        }
        return headers;
      }
      static render(obj) {
        return GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message);
      }
      render() {
        return this._commit;
      }
      withoutSignature() {
        const commit2 = normalizeNewlines(this._commit);
        if (commit2.indexOf("\ngpgsig") === -1)
          return commit2;
        const headers = commit2.slice(0, commit2.indexOf("\ngpgsig"));
        const message = commit2.slice(
          commit2.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length
        );
        return normalizeNewlines(headers + "\n" + message);
      }
      isolateSignature() {
        const signature = this._commit.slice(
          this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return outdent(signature);
      }
      static async sign(commit2, sign, secretKey) {
        const payload = commit2.withoutSignature();
        const message = GitCommit.justMessage(commit2._commit);
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const headers = GitCommit.justHeaders(commit2._commit);
        const signedCommit = headers + "\ngpgsig" + indent(signature) + "\n" + message;
        return GitCommit.from(signedCommit);
      }
    };
    async function resolveTree({ fs: fs7, cache, gitdir, oid }) {
      if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
        return { tree: GitTree.from([]), oid };
      }
      const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveTree({ fs: fs7, cache, gitdir, oid });
      }
      if (type === "commit") {
        oid = GitCommit.from(object).parse().tree;
        return resolveTree({ fs: fs7, cache, gitdir, oid });
      }
      if (type !== "tree") {
        throw new ObjectTypeError(oid, type, "tree");
      }
      return { tree: GitTree.from(object), oid };
    }
    var GitWalkerRepo = class {
      constructor({ fs: fs7, gitdir, ref, cache }) {
        this.fs = fs7;
        this.cache = cache;
        this.gitdir = gitdir;
        this.mapPromise = (async () => {
          const map = /* @__PURE__ */ new Map();
          let oid;
          try {
            oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref });
          } catch (e2) {
            if (e2 instanceof NotFoundError) {
              oid = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
            }
          }
          const tree = await resolveTree({ fs: fs7, cache: this.cache, gitdir, oid });
          tree.type = "tree";
          tree.mode = "40000";
          map.set(".", tree);
          return map;
        })();
        const walker = this;
        this.ConstructEntry = class TreeEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs: fs7, cache, gitdir } = this;
        const map = await this.mapPromise;
        const obj = map.get(filepath);
        if (!obj)
          throw new Error(`No obj for ${filepath}`);
        const oid = obj.oid;
        if (!oid)
          throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
        if (obj.type !== "tree") {
          return null;
        }
        const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
        if (type !== obj.type) {
          throw new ObjectTypeError(oid, type, obj.type);
        }
        const tree = GitTree.from(object);
        for (const entry2 of tree) {
          map.set(join(filepath, entry2.path), entry2);
        }
        return tree.entries().map((entry2) => join(filepath, entry2.path));
      }
      async type(entry) {
        if (entry._type === false) {
          const map = await this.mapPromise;
          const { type } = map.get(entry._fullpath);
          entry._type = type;
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          const map = await this.mapPromise;
          const { mode } = map.get(entry._fullpath);
          entry._mode = normalizeMode(parseInt(mode, 8));
        }
        return entry._mode;
      }
      async stat(_entry) {
      }
      async content(entry) {
        if (entry._content === false) {
          const map = await this.mapPromise;
          const { fs: fs7, cache, gitdir } = this;
          const obj = map.get(entry._fullpath);
          const oid = obj.oid;
          const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
          if (type !== "blob") {
            entry._content = void 0;
          } else {
            entry._content = new Uint8Array(object);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const map = await this.mapPromise;
          const obj = map.get(entry._fullpath);
          entry._oid = obj.oid;
        }
        return entry._oid;
      }
    };
    function TREE({ ref = "HEAD" } = {}) {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: function({ fs: fs7, gitdir, cache }) {
          return new GitWalkerRepo({ fs: fs7, gitdir, ref, cache });
        }
      });
      Object.freeze(o);
      return o;
    }
    var GitWalkerFs = class {
      constructor({ fs: fs7, dir, gitdir, cache }) {
        this.fs = fs7;
        this.cache = cache;
        this.dir = dir;
        this.gitdir = gitdir;
        const walker = this;
        this.ConstructEntry = class WorkdirEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs: fs7, dir } = this;
        const names = await fs7.readdir(join(dir, filepath));
        if (names === null)
          return null;
        return names.map((name) => join(filepath, name));
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const { fs: fs7, dir } = this;
          let stat2 = await fs7.lstat(`${dir}/${entry._fullpath}`);
          if (!stat2) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          let type = stat2.isDirectory() ? "tree" : "blob";
          if (type === "blob" && !stat2.isFile() && !stat2.isSymbolicLink()) {
            type = "special";
          }
          entry._type = type;
          stat2 = normalizeStats(stat2);
          entry._mode = stat2.mode;
          if (stat2.size === -1 && entry._actualSize) {
            stat2.size = entry._actualSize;
          }
          entry._stat = stat2;
        }
        return entry._stat;
      }
      async content(entry) {
        if (entry._content === false) {
          const { fs: fs7, dir } = this;
          if (await entry.type() === "tree") {
            entry._content = void 0;
          } else {
            const content = await fs7.read(`${dir}/${entry._fullpath}`);
            entry._actualSize = content.length;
            if (entry._stat && entry._stat.size === -1) {
              entry._stat.size = entry._actualSize;
            }
            entry._content = new Uint8Array(content);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const { fs: fs7, gitdir, cache } = this;
          let oid;
          await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
            const stage = index2.entriesMap.get(entry._fullpath);
            const stats = await entry.stat();
            if (!stage || compareStats(stats, stage)) {
              const content = await entry.content();
              if (content === void 0) {
                oid = void 0;
              } else {
                oid = await shasum(
                  GitObject.wrap({ type: "blob", object: await entry.content() })
                );
                if (stage && oid === stage.oid && stats.mode === stage.mode && compareStats(stats, stage)) {
                  index2.insert({
                    filepath: entry._fullpath,
                    stats,
                    oid
                  });
                }
              }
            } else {
              oid = stage.oid;
            }
          });
          entry._oid = oid;
        }
        return entry._oid;
      }
    };
    function WORKDIR() {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: function({ fs: fs7, dir, gitdir, cache }) {
          return new GitWalkerFs({ fs: fs7, dir, gitdir, cache });
        }
      });
      Object.freeze(o);
      return o;
    }
    function arrayRange(start, end) {
      const length = end - start;
      return Array.from({ length }, (_, i2) => start + i2);
    }
    var flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x2) => acc.concat(x2), []) : (entries) => entries.flat();
    var RunningMinimum = class {
      constructor() {
        this.value = null;
      }
      consider(value) {
        if (value === null || value === void 0)
          return;
        if (this.value === null) {
          this.value = value;
        } else if (value < this.value) {
          this.value = value;
        }
      }
      reset() {
        this.value = null;
      }
    };
    function* unionOfIterators(sets) {
      const min = new RunningMinimum();
      let minimum;
      const heads = [];
      const numsets = sets.length;
      for (let i2 = 0; i2 < numsets; i2++) {
        heads[i2] = sets[i2].next().value;
        if (heads[i2] !== void 0) {
          min.consider(heads[i2]);
        }
      }
      if (min.value === null)
        return;
      while (true) {
        const result = [];
        minimum = min.value;
        min.reset();
        for (let i2 = 0; i2 < numsets; i2++) {
          if (heads[i2] !== void 0 && heads[i2] === minimum) {
            result[i2] = heads[i2];
            heads[i2] = sets[i2].next().value;
          } else {
            result[i2] = null;
          }
          if (heads[i2] !== void 0) {
            min.consider(heads[i2]);
          }
        }
        yield result;
        if (min.value === null)
          return;
      }
    }
    async function _walk({
      fs: fs7,
      cache,
      dir,
      gitdir,
      trees,
      // @ts-ignore
      map = async (_, entry) => entry,
      // The default reducer is a flatmap that filters out undefineds.
      reduce = async (parent, children) => {
        const flatten = flat(children);
        if (parent !== void 0)
          flatten.unshift(parent);
        return flatten;
      },
      // The default iterate function walks all children concurrently
      iterate = (walk2, children) => Promise.all([...children].map(walk2))
    }) {
      const walkers = trees.map(
        (proxy) => proxy[GitWalkSymbol]({ fs: fs7, dir, gitdir, cache })
      );
      const root = new Array(walkers.length).fill(".");
      const range = arrayRange(0, walkers.length);
      const unionWalkerFromReaddir = async (entries) => {
        range.map((i2) => {
          entries[i2] = entries[i2] && new walkers[i2].ConstructEntry(entries[i2]);
        });
        const subdirs = await Promise.all(
          range.map((i2) => entries[i2] ? walkers[i2].readdir(entries[i2]) : [])
        );
        const iterators = subdirs.map((array) => array === null ? [] : array).map((array) => array[Symbol.iterator]());
        return {
          entries,
          children: unionOfIterators(iterators)
        };
      };
      const walk2 = async (root2) => {
        const { entries, children } = await unionWalkerFromReaddir(root2);
        const fullpath = entries.find((entry) => entry && entry._fullpath)._fullpath;
        const parent = await map(fullpath, entries);
        if (parent !== null) {
          let walkedChildren = await iterate(walk2, children);
          walkedChildren = walkedChildren.filter((x2) => x2 !== void 0);
          return reduce(parent, walkedChildren);
        }
      };
      return walk2(root);
    }
    async function rmRecursive(fs7, filepath) {
      const entries = await fs7.readdir(filepath);
      if (entries == null) {
        await fs7.rm(filepath);
      } else if (entries.length) {
        await Promise.all(
          entries.map((entry) => {
            const subpath = join(filepath, entry);
            return fs7.lstat(subpath).then((stat2) => {
              if (!stat2)
                return;
              return stat2.isDirectory() ? rmRecursive(fs7, subpath) : fs7.rm(subpath);
            });
          })
        ).then(() => fs7.rmdir(filepath));
      } else {
        await fs7.rmdir(filepath);
      }
    }
    function isPromiseFs(fs7) {
      const test = (targetFs) => {
        try {
          return targetFs.readFile().catch((e2) => e2);
        } catch (e2) {
          return e2;
        }
      };
      return test(fs7).constructor.name === "Promise";
    }
    var commands = [
      "readFile",
      "writeFile",
      "mkdir",
      "rmdir",
      "unlink",
      "stat",
      "lstat",
      "readdir",
      "readlink",
      "symlink"
    ];
    function bindFs(target, fs7) {
      if (isPromiseFs(fs7)) {
        for (const command of commands) {
          target[`_${command}`] = fs7[command].bind(fs7);
        }
      } else {
        for (const command of commands) {
          target[`_${command}`] = pify(fs7[command].bind(fs7));
        }
      }
      if (isPromiseFs(fs7)) {
        if (fs7.rm)
          target._rm = fs7.rm.bind(fs7);
        else if (fs7.rmdir.length > 1)
          target._rm = fs7.rmdir.bind(fs7);
        else
          target._rm = rmRecursive.bind(null, target);
      } else {
        if (fs7.rm)
          target._rm = pify(fs7.rm.bind(fs7));
        else if (fs7.rmdir.length > 2)
          target._rm = pify(fs7.rmdir.bind(fs7));
        else
          target._rm = rmRecursive.bind(null, target);
      }
    }
    var FileSystem = class {
      constructor(fs7) {
        if (typeof fs7._original_unwrapped_fs !== "undefined")
          return fs7;
        const promises3 = Object.getOwnPropertyDescriptor(fs7, "promises");
        if (promises3 && promises3.enumerable) {
          bindFs(this, fs7.promises);
        } else {
          bindFs(this, fs7);
        }
        this._original_unwrapped_fs = fs7;
      }
      /**
       * Return true if a file exists, false if it doesn't exist.
       * Rethrows errors that aren't related to file existance.
       */
      async exists(filepath, options = {}) {
        try {
          await this._stat(filepath);
          return true;
        } catch (err) {
          if (err.code === "ENOENT" || err.code === "ENOTDIR") {
            return false;
          } else {
            console.log('Unhandled error in "FileSystem.exists()" function', err);
            throw err;
          }
        }
      }
      /**
       * Return the contents of a file if it exists, otherwise returns null.
       *
       * @param {string} filepath
       * @param {object} [options]
       *
       * @returns {Promise<Buffer|string|null>}
       */
      async read(filepath, options = {}) {
        try {
          let buffer = await this._readFile(filepath, options);
          if (typeof buffer !== "string") {
            buffer = Buffer.from(buffer);
          }
          return buffer;
        } catch (err) {
          return null;
        }
      }
      /**
       * Write a file (creating missing directories if need be) without throwing errors.
       *
       * @param {string} filepath
       * @param {Buffer|Uint8Array|string} contents
       * @param {object|string} [options]
       */
      async write(filepath, contents, options = {}) {
        try {
          await this._writeFile(filepath, contents, options);
          return;
        } catch (err) {
          await this.mkdir(dirname2(filepath));
          await this._writeFile(filepath, contents, options);
        }
      }
      /**
       * Make a directory (or series of nested directories) without throwing an error if it already exists.
       */
      async mkdir(filepath, _selfCall = false) {
        try {
          await this._mkdir(filepath);
          return;
        } catch (err) {
          if (err === null)
            return;
          if (err.code === "EEXIST")
            return;
          if (_selfCall)
            throw err;
          if (err.code === "ENOENT") {
            const parent = dirname2(filepath);
            if (parent === "." || parent === "/" || parent === filepath)
              throw err;
            await this.mkdir(parent);
            await this.mkdir(filepath, true);
          }
        }
      }
      /**
       * Delete a file without throwing an error if it is already deleted.
       */
      async rm(filepath) {
        try {
          await this._unlink(filepath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      }
      /**
       * Delete a directory without throwing an error if it is already deleted.
       */
      async rmdir(filepath, opts) {
        try {
          if (opts && opts.recursive) {
            await this._rm(filepath, opts);
          } else {
            await this._rmdir(filepath);
          }
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      }
      /**
       * Read a directory without throwing an error is the directory doesn't exist
       */
      async readdir(filepath) {
        try {
          const names = await this._readdir(filepath);
          names.sort(compareStrings);
          return names;
        } catch (err) {
          if (err.code === "ENOTDIR")
            return null;
          return [];
        }
      }
      /**
       * Return a flast list of all the files nested inside a directory
       *
       * Based on an elegant concurrent recursive solution from SO
       * https://stackoverflow.com/a/45130990/2168416
       */
      async readdirDeep(dir) {
        const subdirs = await this._readdir(dir);
        const files = await Promise.all(
          subdirs.map(async (subdir) => {
            const res = dir + "/" + subdir;
            return (await this._stat(res)).isDirectory() ? this.readdirDeep(res) : res;
          })
        );
        return files.reduce((a, f3) => a.concat(f3), []);
      }
      /**
       * Return the Stats of a file/symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existance.
       */
      async lstat(filename) {
        try {
          const stats = await this._lstat(filename);
          return stats;
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Reads the contents of a symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existance.
       */
      async readlink(filename, opts = { encoding: "buffer" }) {
        try {
          const link = await this._readlink(filename, opts);
          return Buffer.isBuffer(link) ? link : Buffer.from(link);
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Write the contents of buffer to a symlink.
       */
      async writelink(filename, buffer) {
        return this._symlink(buffer.toString("utf8"), filename);
      }
    };
    function assertParameter(name, value) {
      if (value === void 0) {
        throw new MissingParameterError(name);
      }
    }
    async function modified(entry, base) {
      if (!entry && !base)
        return false;
      if (entry && !base)
        return true;
      if (!entry && base)
        return true;
      if (await entry.type() === "tree" && await base.type() === "tree") {
        return false;
      }
      if (await entry.type() === await base.type() && await entry.mode() === await base.mode() && await entry.oid() === await base.oid()) {
        return false;
      }
      return true;
    }
    async function abortMerge({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      commit: commit2 = "HEAD",
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        const fs7 = new FileSystem(_fs);
        const trees = [TREE({ ref: commit2 }), WORKDIR(), STAGE()];
        let unmergedPaths = [];
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          unmergedPaths = index2.unmergedPaths;
        });
        const results = await _walk({
          fs: fs7,
          cache,
          dir,
          gitdir,
          trees,
          map: async function(path4, [head, workdir, index2]) {
            const staged = !await modified(workdir, index2);
            const unmerged = unmergedPaths.includes(path4);
            const unmodified = !await modified(index2, head);
            if (staged || unmerged) {
              return head ? {
                path: path4,
                mode: await head.mode(),
                oid: await head.oid(),
                type: await head.type(),
                content: await head.content()
              } : void 0;
            }
            if (unmodified)
              return false;
            else
              throw new IndexResetError(path4);
          }
        });
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          for (const entry of results) {
            if (entry === false)
              continue;
            if (!entry) {
              await fs7.rmdir(`${dir}/${entry.path}`, { recursive: true });
              index2.delete({ filepath: entry.path });
              continue;
            }
            if (entry.type === "blob") {
              const content = new TextDecoder().decode(entry.content);
              await fs7.write(`${dir}/${entry.path}`, content, { mode: entry.mode });
              index2.insert({
                filepath: entry.path,
                oid: entry.oid,
                stage: 0
              });
            }
          }
        });
      } catch (err) {
        err.caller = "git.abortMerge";
        throw err;
      }
    }
    var GitIgnoreManager = class {
      static async isIgnored({ fs: fs7, dir, gitdir = join(dir, ".git"), filepath }) {
        if (basename(filepath) === ".git")
          return true;
        if (filepath === ".")
          return false;
        let excludes = "";
        const excludesFile = join(gitdir, "info", "exclude");
        if (await fs7.exists(excludesFile)) {
          excludes = await fs7.read(excludesFile, "utf8");
        }
        const pairs = [
          {
            gitignore: join(dir, ".gitignore"),
            filepath
          }
        ];
        const pieces = filepath.split("/").filter(Boolean);
        for (let i2 = 1; i2 < pieces.length; i2++) {
          const folder = pieces.slice(0, i2).join("/");
          const file = pieces.slice(i2).join("/");
          pairs.push({
            gitignore: join(dir, folder, ".gitignore"),
            filepath: file
          });
        }
        let ignoredStatus = false;
        for (const p of pairs) {
          let file;
          try {
            file = await fs7.read(p.gitignore, "utf8");
          } catch (err) {
            if (err.code === "NOENT")
              continue;
          }
          const ign = ignore().add(excludes);
          ign.add(file);
          const parentdir = dirname2(p.filepath);
          if (parentdir !== "." && ign.ignores(parentdir))
            return true;
          if (ignoredStatus) {
            ignoredStatus = !ign.test(p.filepath).unignored;
          } else {
            ignoredStatus = ign.test(p.filepath).ignored;
          }
        }
        return ignoredStatus;
      }
    };
    async function writeObjectLoose({ fs: fs7, gitdir, object, format, oid }) {
      if (format !== "deflated") {
        throw new InternalError(
          "GitObjectStoreLoose expects objects to write to be in deflated format"
        );
      }
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      const filepath = `${gitdir}/${source}`;
      if (!await fs7.exists(filepath))
        await fs7.write(filepath, object);
    }
    var supportsCompressionStream = null;
    async function deflate(buffer) {
      if (supportsCompressionStream === null) {
        supportsCompressionStream = testCompressionStream();
      }
      return supportsCompressionStream ? browserDeflate(buffer) : pako.deflate(buffer);
    }
    async function browserDeflate(buffer) {
      const cs = new CompressionStream("deflate");
      const c = new Blob([buffer]).stream().pipeThrough(cs);
      return new Uint8Array(await new Response(c).arrayBuffer());
    }
    function testCompressionStream() {
      try {
        const cs = new CompressionStream("deflate");
        new Blob([]).stream();
        if (cs)
          return true;
      } catch (_) {
      }
      return false;
    }
    async function _writeObject({
      fs: fs7,
      gitdir,
      type,
      object,
      format = "content",
      oid = void 0,
      dryRun = false
    }) {
      if (format !== "deflated") {
        if (format !== "wrapped") {
          object = GitObject.wrap({ type, object });
        }
        oid = await shasum(object);
        object = Buffer.from(await deflate(object));
      }
      if (!dryRun) {
        await writeObjectLoose({ fs: fs7, gitdir, object, format: "deflated", oid });
      }
      return oid;
    }
    function posixifyPathBuffer(buffer) {
      let idx;
      while (~(idx = buffer.indexOf(92)))
        buffer[idx] = 47;
      return buffer;
    }
    async function add2({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      cache = {},
      force = false,
      parallel = true
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs7 = new FileSystem(_fs);
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async (index2) => {
          return addToIndex({
            dir,
            gitdir,
            fs: fs7,
            filepath,
            index: index2,
            force,
            parallel
          });
        });
      } catch (err) {
        err.caller = "git.add";
        throw err;
      }
    }
    async function addToIndex({
      dir,
      gitdir,
      fs: fs7,
      filepath,
      index: index2,
      force,
      parallel
    }) {
      filepath = Array.isArray(filepath) ? filepath : [filepath];
      const promises3 = filepath.map(async (currentFilepath) => {
        if (!force) {
          const ignored = await GitIgnoreManager.isIgnored({
            fs: fs7,
            dir,
            gitdir,
            filepath: currentFilepath
          });
          if (ignored)
            return;
        }
        const stats = await fs7.lstat(join(dir, currentFilepath));
        if (!stats)
          throw new NotFoundError(currentFilepath);
        if (stats.isDirectory()) {
          const children = await fs7.readdir(join(dir, currentFilepath));
          if (parallel) {
            const promises4 = children.map(
              (child) => addToIndex({
                dir,
                gitdir,
                fs: fs7,
                filepath: [join(currentFilepath, child)],
                index: index2,
                force,
                parallel
              })
            );
            await Promise.all(promises4);
          } else {
            for (const child of children) {
              await addToIndex({
                dir,
                gitdir,
                fs: fs7,
                filepath: [join(currentFilepath, child)],
                index: index2,
                force,
                parallel
              });
            }
          }
        } else {
          const object = stats.isSymbolicLink() ? await fs7.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer) : await fs7.read(join(dir, currentFilepath));
          if (object === null)
            throw new NotFoundError(currentFilepath);
          const oid = await _writeObject({ fs: fs7, gitdir, type: "blob", object });
          index2.insert({ filepath: currentFilepath, stats, oid });
        }
      });
      const settledPromises = await Promise.allSettled(promises3);
      const rejectedPromises = settledPromises.filter((settle) => settle.status === "rejected").map((settle) => settle.reason);
      if (rejectedPromises.length > 1) {
        throw new MultipleGitError(rejectedPromises);
      }
      if (rejectedPromises.length === 1) {
        throw rejectedPromises[0];
      }
      const fulfilledPromises = settledPromises.filter((settle) => settle.status === "fulfilled" && settle.value).map((settle) => settle.value);
      return fulfilledPromises;
    }
    async function _commit({
      fs: fs7,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun = false,
      noUpdateBranch = false,
      ref,
      parent,
      tree
    }) {
      if (!ref) {
        ref = await GitRefManager.resolve({
          fs: fs7,
          gitdir,
          ref: "HEAD",
          depth: 2
        });
      }
      return GitIndexManager.acquire(
        { fs: fs7, gitdir, cache, allowUnmerged: false },
        async function(index2) {
          const inodes = flatFileListToDirectoryStructure(index2.entries);
          const inode = inodes.get(".");
          if (!tree) {
            tree = await constructTree({ fs: fs7, gitdir, inode, dryRun });
          }
          if (!parent) {
            try {
              parent = [
                await GitRefManager.resolve({
                  fs: fs7,
                  gitdir,
                  ref
                })
              ];
            } catch (err) {
              parent = [];
            }
          } else {
            parent = await Promise.all(
              parent.map((p) => {
                return GitRefManager.resolve({ fs: fs7, gitdir, ref: p });
              })
            );
          }
          let comm = GitCommit.from({
            tree,
            parent,
            author,
            committer,
            message
          });
          if (signingKey) {
            comm = await GitCommit.sign(comm, onSign, signingKey);
          }
          const oid = await _writeObject({
            fs: fs7,
            gitdir,
            type: "commit",
            object: comm.toObject(),
            dryRun
          });
          if (!noUpdateBranch && !dryRun) {
            await GitRefManager.writeRef({
              fs: fs7,
              gitdir,
              ref,
              value: oid
            });
          }
          return oid;
        }
      );
    }
    async function constructTree({ fs: fs7, gitdir, inode, dryRun }) {
      const children = inode.children;
      for (const inode2 of children) {
        if (inode2.type === "tree") {
          inode2.metadata.mode = "040000";
          inode2.metadata.oid = await constructTree({ fs: fs7, gitdir, inode: inode2, dryRun });
        }
      }
      const entries = children.map((inode2) => ({
        mode: inode2.metadata.mode,
        path: inode2.basename,
        oid: inode2.metadata.oid,
        type: inode2.type
      }));
      const tree = GitTree.from(entries);
      const oid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "tree",
        object: tree.toObject(),
        dryRun
      });
      return oid;
    }
    async function resolveFilepath({ fs: fs7, cache, gitdir, oid, filepath }) {
      if (filepath.startsWith("/")) {
        throw new InvalidFilepathError("leading-slash");
      } else if (filepath.endsWith("/")) {
        throw new InvalidFilepathError("trailing-slash");
      }
      const _oid = oid;
      const result = await resolveTree({ fs: fs7, cache, gitdir, oid });
      const tree = result.tree;
      if (filepath === "") {
        oid = result.oid;
      } else {
        const pathArray = filepath.split("/");
        oid = await _resolveFilepath({
          fs: fs7,
          cache,
          gitdir,
          tree,
          pathArray,
          oid: _oid,
          filepath
        });
      }
      return oid;
    }
    async function _resolveFilepath({
      fs: fs7,
      cache,
      gitdir,
      tree,
      pathArray,
      oid,
      filepath
    }) {
      const name = pathArray.shift();
      for (const entry of tree) {
        if (entry.path === name) {
          if (pathArray.length === 0) {
            return entry.oid;
          } else {
            const { type, object } = await _readObject({
              fs: fs7,
              cache,
              gitdir,
              oid: entry.oid
            });
            if (type !== "tree") {
              throw new ObjectTypeError(oid, type, "tree", filepath);
            }
            tree = GitTree.from(object);
            return _resolveFilepath({
              fs: fs7,
              cache,
              gitdir,
              tree,
              pathArray,
              oid,
              filepath
            });
          }
        }
      }
      throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
    }
    async function _readTree({
      fs: fs7,
      cache,
      gitdir,
      oid,
      filepath = void 0
    }) {
      if (filepath !== void 0) {
        oid = await resolveFilepath({ fs: fs7, cache, gitdir, oid, filepath });
      }
      const { tree, oid: treeOid } = await resolveTree({ fs: fs7, cache, gitdir, oid });
      const result = {
        oid: treeOid,
        tree: tree.entries()
      };
      return result;
    }
    async function _writeTree({ fs: fs7, gitdir, tree }) {
      const object = GitTree.from(tree).toObject();
      const oid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "tree",
        object,
        format: "content"
      });
      return oid;
    }
    async function _addNote({
      fs: fs7,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey
    }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs: fs7, ref });
      } catch (err) {
        if (!(err instanceof NotFoundError)) {
          throw err;
        }
      }
      const result = await _readTree({
        fs: fs7,
        cache,
        gitdir,
        oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
      });
      let tree = result.tree;
      if (force) {
        tree = tree.filter((entry) => entry.path !== oid);
      } else {
        for (const entry of tree) {
          if (entry.path === oid) {
            throw new AlreadyExistsError("note", oid);
          }
        }
      }
      if (typeof note === "string") {
        note = Buffer.from(note, "utf8");
      }
      const noteOid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "blob",
        object: note,
        format: "content"
      });
      tree.push({ mode: "100644", path: oid, oid: noteOid, type: "blob" });
      const treeOid = await _writeTree({
        fs: fs7,
        gitdir,
        tree
      });
      const commitOid = await _commit({
        fs: fs7,
        cache,
        onSign,
        gitdir,
        ref,
        tree: treeOid,
        parent: parent && [parent],
        message: `Note added by 'isomorphic-git addNote'
`,
        author,
        committer,
        signingKey
      });
      return commitOid;
    }
    async function _getConfig({ fs: fs7, gitdir, path: path4 }) {
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      return config3.get(path4);
    }
    async function normalizeAuthorObject({ fs: fs7, gitdir, author = {} }) {
      let { name, email, timestamp, timezoneOffset } = author;
      name = name || await _getConfig({ fs: fs7, gitdir, path: "user.name" });
      email = email || await _getConfig({ fs: fs7, gitdir, path: "user.email" }) || "";
      if (name === void 0) {
        return void 0;
      }
      timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1e3);
      timezoneOffset = timezoneOffset != null ? timezoneOffset : new Date(timestamp * 1e3).getTimezoneOffset();
      return { name, email, timestamp, timezoneOffset };
    }
    async function normalizeCommitterObject({
      fs: fs7,
      gitdir,
      author,
      committer
    }) {
      committer = Object.assign({}, committer || author);
      if (author) {
        committer.timestamp = committer.timestamp || author.timestamp;
        committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
      }
      committer = await normalizeAuthorObject({ fs: fs7, gitdir, author: committer });
      return committer;
    }
    async function addNote({
      fs: _fs,
      onSign,
      dir,
      gitdir = join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      note,
      force,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        assertParameter("note", note);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs7 = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs: fs7, gitdir, author: _author });
        if (!author)
          throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs: fs7,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer)
          throw new MissingNameError("committer");
        return await _addNote({
          fs: new FileSystem(fs7),
          cache,
          onSign,
          gitdir,
          ref,
          oid,
          note,
          force,
          author,
          committer,
          signingKey
        });
      } catch (err) {
        err.caller = "git.addNote";
        throw err;
      }
    }
    async function _addRemote({ fs: fs7, gitdir, remote, url, force }) {
      if (remote !== cleanGitRef.clean(remote)) {
        throw new InvalidRefNameError(remote, cleanGitRef.clean(remote));
      }
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      if (!force) {
        const remoteNames = await config3.getSubsections("remote");
        if (remoteNames.includes(remote)) {
          if (url !== await config3.get(`remote.${remote}.url`)) {
            throw new AlreadyExistsError("remote", remote);
          }
        }
      }
      await config3.set(`remote.${remote}.url`, url);
      await config3.set(
        `remote.${remote}.fetch`,
        `+refs/heads/*:refs/remotes/${remote}/*`
      );
      await GitConfigManager.save({ fs: fs7, gitdir, config: config3 });
    }
    async function addRemote({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      remote,
      url,
      force = false
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("remote", remote);
        assertParameter("url", url);
        return await _addRemote({
          fs: new FileSystem(fs7),
          gitdir,
          remote,
          url,
          force
        });
      } catch (err) {
        err.caller = "git.addRemote";
        throw err;
      }
    }
    async function _annotatedTag({
      fs: fs7,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message = ref,
      gpgsig,
      object,
      signingKey,
      force = false
    }) {
      ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
      if (!force && await GitRefManager.exists({ fs: fs7, gitdir, ref })) {
        throw new AlreadyExistsError("tag", ref);
      }
      const oid = await GitRefManager.resolve({
        fs: fs7,
        gitdir,
        ref: object || "HEAD"
      });
      const { type } = await _readObject({ fs: fs7, cache, gitdir, oid });
      let tagObject = GitAnnotatedTag.from({
        object: oid,
        type,
        tag: ref.replace("refs/tags/", ""),
        tagger,
        message,
        gpgsig
      });
      if (signingKey) {
        tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
      }
      const value = await _writeObject({
        fs: fs7,
        gitdir,
        type: "tag",
        object: tagObject.toObject()
      });
      await GitRefManager.writeRef({ fs: fs7, gitdir, ref, value });
    }
    async function annotatedTag({
      fs: _fs,
      onSign,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      tagger: _tagger,
      message = ref,
      gpgsig,
      object,
      signingKey,
      force = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs7 = new FileSystem(_fs);
        const tagger = await normalizeAuthorObject({ fs: fs7, gitdir, author: _tagger });
        if (!tagger)
          throw new MissingNameError("tagger");
        return await _annotatedTag({
          fs: fs7,
          cache,
          onSign,
          gitdir,
          ref,
          tagger,
          message,
          gpgsig,
          object,
          signingKey,
          force
        });
      } catch (err) {
        err.caller = "git.annotatedTag";
        throw err;
      }
    }
    async function _branch({
      fs: fs7,
      gitdir,
      ref,
      object,
      checkout: checkout2 = false,
      force = false
    }) {
      if (ref !== cleanGitRef.clean(ref)) {
        throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
      }
      const fullref = `refs/heads/${ref}`;
      if (!force) {
        const exist = await GitRefManager.exists({ fs: fs7, gitdir, ref: fullref });
        if (exist) {
          throw new AlreadyExistsError("branch", ref, false);
        }
      }
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref: object || "HEAD" });
      } catch (e2) {
      }
      if (oid) {
        await GitRefManager.writeRef({ fs: fs7, gitdir, ref: fullref, value: oid });
      }
      if (checkout2) {
        await GitRefManager.writeSymbolicRef({
          fs: fs7,
          gitdir,
          ref: "HEAD",
          value: fullref
        });
      }
    }
    async function branch({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      object,
      checkout: checkout2 = false,
      force = false
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _branch({
          fs: new FileSystem(fs7),
          gitdir,
          ref,
          object,
          checkout: checkout2,
          force
        });
      } catch (err) {
        err.caller = "git.branch";
        throw err;
      }
    }
    var worthWalking = (filepath, root) => {
      if (filepath === "." || root == null || root.length === 0 || root === ".") {
        return true;
      }
      if (root.length >= filepath.length) {
        return root.startsWith(filepath);
      } else {
        return filepath.startsWith(root);
      }
    };
    async function _checkout({
      fs: fs7,
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track = true
    }) {
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref });
      } catch (err) {
        if (ref === "HEAD")
          throw err;
        const remoteRef = `${remote}/${ref}`;
        oid = await GitRefManager.resolve({
          fs: fs7,
          gitdir,
          ref: remoteRef
        });
        if (track) {
          const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
          await config3.set(`branch.${ref}.remote`, remote);
          await config3.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
          await GitConfigManager.save({ fs: fs7, gitdir, config: config3 });
        }
        await GitRefManager.writeRef({
          fs: fs7,
          gitdir,
          ref: `refs/heads/${ref}`,
          value: oid
        });
      }
      if (!noCheckout) {
        let ops;
        try {
          ops = await analyze({
            fs: fs7,
            cache,
            onProgress,
            dir,
            gitdir,
            ref,
            force,
            filepaths
          });
        } catch (err) {
          if (err instanceof NotFoundError && err.data.what === oid) {
            throw new CommitNotFetchedError(ref, oid);
          } else {
            throw err;
          }
        }
        const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
        if (conflicts.length > 0) {
          throw new CheckoutConflictError(conflicts);
        }
        const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
        if (errors.length > 0) {
          throw new InternalError(errors.join(", "));
        }
        if (dryRun) {
          return;
        }
        let count = 0;
        const total = ops.length;
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          await Promise.all(
            ops.filter(
              ([method]) => method === "delete" || method === "delete-index"
            ).map(async function([method, fullpath]) {
              const filepath = `${dir}/${fullpath}`;
              if (method === "delete") {
                await fs7.rm(filepath);
              }
              index2.delete({ filepath: fullpath });
              if (onProgress) {
                await onProgress({
                  phase: "Updating workdir",
                  loaded: ++count,
                  total
                });
              }
            })
          );
        });
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          for (const [method, fullpath] of ops) {
            if (method === "rmdir" || method === "rmdir-index") {
              const filepath = `${dir}/${fullpath}`;
              try {
                if (method === "rmdir-index") {
                  index2.delete({ filepath: fullpath });
                }
                await fs7.rmdir(filepath);
                if (onProgress) {
                  await onProgress({
                    phase: "Updating workdir",
                    loaded: ++count,
                    total
                  });
                }
              } catch (e2) {
                if (e2.code === "ENOTEMPTY") {
                  console.log(
                    `Did not delete ${fullpath} because directory is not empty`
                  );
                } else {
                  throw e2;
                }
              }
            }
          }
        });
        await Promise.all(
          ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_, fullpath]) {
            const filepath = `${dir}/${fullpath}`;
            await fs7.mkdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          })
        );
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          await Promise.all(
            ops.filter(
              ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
            ).map(async function([method, fullpath, oid2, mode, chmod]) {
              const filepath = `${dir}/${fullpath}`;
              try {
                if (method !== "create-index" && method !== "mkdir-index") {
                  const { object } = await _readObject({ fs: fs7, cache, gitdir, oid: oid2 });
                  if (chmod) {
                    await fs7.rm(filepath);
                  }
                  if (mode === 33188) {
                    await fs7.write(filepath, object);
                  } else if (mode === 33261) {
                    await fs7.write(filepath, object, { mode: 511 });
                  } else if (mode === 40960) {
                    await fs7.writelink(filepath, object);
                  } else {
                    throw new InternalError(
                      `Invalid mode 0o${mode.toString(8)} detected in blob ${oid2}`
                    );
                  }
                }
                const stats = await fs7.lstat(filepath);
                if (mode === 33261) {
                  stats.mode = 493;
                }
                if (method === "mkdir-index") {
                  stats.mode = 57344;
                }
                index2.insert({
                  filepath: fullpath,
                  stats,
                  oid: oid2
                });
                if (onProgress) {
                  await onProgress({
                    phase: "Updating workdir",
                    loaded: ++count,
                    total
                  });
                }
              } catch (e2) {
                console.log(e2);
              }
            })
          );
        });
      }
      if (!noUpdateHead) {
        const fullRef = await GitRefManager.expand({ fs: fs7, gitdir, ref });
        if (fullRef.startsWith("refs/heads")) {
          await GitRefManager.writeSymbolicRef({
            fs: fs7,
            gitdir,
            ref: "HEAD",
            value: fullRef
          });
        } else {
          await GitRefManager.writeRef({ fs: fs7, gitdir, ref: "HEAD", value: oid });
        }
      }
    }
    async function analyze({
      fs: fs7,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      force,
      filepaths
    }) {
      let count = 0;
      return _walk({
        fs: fs7,
        cache,
        dir,
        gitdir,
        trees: [TREE({ ref }), WORKDIR(), STAGE()],
        map: async function(fullpath, [commit2, workdir, stage]) {
          if (fullpath === ".")
            return;
          if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
            return null;
          }
          if (onProgress) {
            await onProgress({ phase: "Analyzing workdir", loaded: ++count });
          }
          const key = [!!stage, !!commit2, !!workdir].map(Number).join("");
          switch (key) {
            case "000":
              return;
            case "001":
              if (force && filepaths && filepaths.includes(fullpath)) {
                return ["delete", fullpath];
              }
              return;
            case "010": {
              switch (await commit2.type()) {
                case "tree": {
                  return ["mkdir", fullpath];
                }
                case "blob": {
                  return [
                    "create",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                case "commit": {
                  return [
                    "mkdir-index",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                default: {
                  return [
                    "error",
                    `new entry Unhandled type ${await commit2.type()}`
                  ];
                }
              }
            }
            case "011": {
              switch (`${await commit2.type()}-${await workdir.type()}`) {
                case "tree-tree": {
                  return;
                }
                case "tree-blob":
                case "blob-tree": {
                  return ["conflict", fullpath];
                }
                case "blob-blob": {
                  if (await commit2.oid() !== await workdir.oid()) {
                    if (force) {
                      return [
                        "update",
                        fullpath,
                        await commit2.oid(),
                        await commit2.mode(),
                        await commit2.mode() !== await workdir.mode()
                      ];
                    } else {
                      return ["conflict", fullpath];
                    }
                  } else {
                    if (await commit2.mode() !== await workdir.mode()) {
                      if (force) {
                        return [
                          "update",
                          fullpath,
                          await commit2.oid(),
                          await commit2.mode(),
                          true
                        ];
                      } else {
                        return ["conflict", fullpath];
                      }
                    } else {
                      return [
                        "create-index",
                        fullpath,
                        await commit2.oid(),
                        await commit2.mode()
                      ];
                    }
                  }
                }
                case "commit-tree": {
                  return;
                }
                case "commit-blob": {
                  return ["conflict", fullpath];
                }
                default: {
                  return ["error", `new entry Unhandled type ${commit2.type}`];
                }
              }
            }
            case "100": {
              return ["delete-index", fullpath];
            }
            case "101": {
              switch (await stage.type()) {
                case "tree": {
                  return ["rmdir", fullpath];
                }
                case "blob": {
                  if (await stage.oid() !== await workdir.oid()) {
                    if (force) {
                      return ["delete", fullpath];
                    } else {
                      return ["conflict", fullpath];
                    }
                  } else {
                    return ["delete", fullpath];
                  }
                }
                case "commit": {
                  return ["rmdir-index", fullpath];
                }
                default: {
                  return [
                    "error",
                    `delete entry Unhandled type ${await stage.type()}`
                  ];
                }
              }
            }
            case "110":
            case "111": {
              switch (`${await stage.type()}-${await commit2.type()}`) {
                case "tree-tree": {
                  return;
                }
                case "blob-blob": {
                  if (await stage.oid() === await commit2.oid() && await stage.mode() === await commit2.mode() && !force) {
                    return;
                  }
                  if (workdir) {
                    if (await workdir.oid() !== await stage.oid() && await workdir.oid() !== await commit2.oid()) {
                      if (force) {
                        return [
                          "update",
                          fullpath,
                          await commit2.oid(),
                          await commit2.mode(),
                          await commit2.mode() !== await workdir.mode()
                        ];
                      } else {
                        return ["conflict", fullpath];
                      }
                    }
                  } else if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      await commit2.mode() !== await stage.mode()
                    ];
                  }
                  if (await commit2.mode() !== await stage.mode()) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      true
                    ];
                  }
                  if (await commit2.oid() !== await stage.oid()) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      false
                    ];
                  } else {
                    return;
                  }
                }
                case "tree-blob": {
                  return ["update-dir-to-blob", fullpath, await commit2.oid()];
                }
                case "blob-tree": {
                  return ["update-blob-to-tree", fullpath];
                }
                case "commit-commit": {
                  return [
                    "mkdir-index",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                default: {
                  return [
                    "error",
                    `update entry Unhandled type ${await stage.type()}-${await commit2.type()}`
                  ];
                }
              }
            }
          }
        },
        // Modify the default flat mapping
        reduce: async function(parent, children) {
          children = flat(children);
          if (!parent) {
            return children;
          } else if (parent && parent[0] === "rmdir") {
            children.push(parent);
            return children;
          } else {
            children.unshift(parent);
            return children;
          }
        }
      });
    }
    async function checkout({
      fs: fs7,
      onProgress,
      dir,
      gitdir = join(dir, ".git"),
      remote = "origin",
      ref: _ref,
      filepaths,
      noCheckout = false,
      noUpdateHead = _ref === void 0,
      dryRun = false,
      force = false,
      track = true,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        const ref = _ref || "HEAD";
        return await _checkout({
          fs: new FileSystem(fs7),
          cache,
          onProgress,
          dir,
          gitdir,
          remote,
          ref,
          filepaths,
          noCheckout,
          noUpdateHead,
          dryRun,
          force,
          track
        });
      } catch (err) {
        err.caller = "git.checkout";
        throw err;
      }
    }
    var abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
    function abbreviateRef(ref) {
      const match = abbreviateRx.exec(ref);
      if (match) {
        if (match[1] === "remotes/" && ref.endsWith("/HEAD")) {
          return match[2].slice(0, -5);
        } else {
          return match[2];
        }
      }
      return ref;
    }
    async function _currentBranch({
      fs: fs7,
      gitdir,
      fullname = false,
      test = false
    }) {
      const ref = await GitRefManager.resolve({
        fs: fs7,
        gitdir,
        ref: "HEAD",
        depth: 2
      });
      if (test) {
        try {
          await GitRefManager.resolve({ fs: fs7, gitdir, ref });
        } catch (_) {
          return;
        }
      }
      if (!ref.startsWith("refs/"))
        return;
      return fullname ? ref : abbreviateRef(ref);
    }
    function translateSSHtoHTTP(url) {
      url = url.replace(/^git@([^:]+):/, "https://$1/");
      url = url.replace(/^ssh:\/\//, "https://");
      return url;
    }
    function calculateBasicAuthHeader({ username = "", password = "" }) {
      return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
    }
    async function forAwait(iterable, cb) {
      const iter = getIterator(iterable);
      while (true) {
        const { value, done } = await iter.next();
        if (value)
          await cb(value);
        if (done)
          break;
      }
      if (iter.return)
        iter.return();
    }
    async function collect(iterable) {
      let size = 0;
      const buffers = [];
      await forAwait(iterable, (value) => {
        buffers.push(value);
        size += value.byteLength;
      });
      const result = new Uint8Array(size);
      let nextIndex = 0;
      for (const buffer of buffers) {
        result.set(buffer, nextIndex);
        nextIndex += buffer.byteLength;
      }
      return result;
    }
    function extractAuthFromUrl(url) {
      let userpass = url.match(/^https?:\/\/([^/]+)@/);
      if (userpass == null)
        return { url, auth: {} };
      userpass = userpass[1];
      const [username, password] = userpass.split(":");
      url = url.replace(`${userpass}@`, "");
      return { url, auth: { username, password } };
    }
    function padHex(b, n) {
      const s2 = n.toString(16);
      return "0".repeat(b - s2.length) + s2;
    }
    var GitPktLine = class {
      static flush() {
        return Buffer.from("0000", "utf8");
      }
      static delim() {
        return Buffer.from("0001", "utf8");
      }
      static encode(line) {
        if (typeof line === "string") {
          line = Buffer.from(line);
        }
        const length = line.length + 4;
        const hexlength = padHex(4, length);
        return Buffer.concat([Buffer.from(hexlength, "utf8"), line]);
      }
      static streamReader(stream) {
        const reader = new StreamReader(stream);
        return async function read() {
          try {
            let length = await reader.read(4);
            if (length == null)
              return true;
            length = parseInt(length.toString("utf8"), 16);
            if (length === 0)
              return null;
            if (length === 1)
              return null;
            const buffer = await reader.read(length - 4);
            if (buffer == null)
              return true;
            return buffer;
          } catch (err) {
            console.log("error", err);
            return true;
          }
        };
      }
    };
    async function parseCapabilitiesV2(read) {
      const capabilities2 = {};
      let line;
      while (true) {
        line = await read();
        if (line === true)
          break;
        if (line === null)
          continue;
        line = line.toString("utf8").replace(/\n$/, "");
        const i2 = line.indexOf("=");
        if (i2 > -1) {
          const key = line.slice(0, i2);
          const value = line.slice(i2 + 1);
          capabilities2[key] = value;
        } else {
          capabilities2[line] = true;
        }
      }
      return { protocolVersion: 2, capabilities2 };
    }
    async function parseRefsAdResponse(stream, { service }) {
      const capabilities = /* @__PURE__ */ new Set();
      const refs = /* @__PURE__ */ new Map();
      const symrefs = /* @__PURE__ */ new Map();
      const read = GitPktLine.streamReader(stream);
      let lineOne = await read();
      while (lineOne === null)
        lineOne = await read();
      if (lineOne === true)
        throw new EmptyServerResponseError();
      if (lineOne.includes("version 2")) {
        return parseCapabilitiesV2(read);
      }
      if (lineOne.toString("utf8").replace(/\n$/, "") !== `# service=${service}`) {
        throw new ParseError(`# service=${service}\\n`, lineOne.toString("utf8"));
      }
      let lineTwo = await read();
      while (lineTwo === null)
        lineTwo = await read();
      if (lineTwo === true)
        return { capabilities, refs, symrefs };
      lineTwo = lineTwo.toString("utf8");
      if (lineTwo.includes("version 2")) {
        return parseCapabilitiesV2(read);
      }
      const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\0", "\\x00");
      capabilitiesLine.split(" ").map((x2) => capabilities.add(x2));
      const [ref, name] = splitAndAssert(firstRef, " ", " ");
      refs.set(name, ref);
      while (true) {
        const line = await read();
        if (line === true)
          break;
        if (line !== null) {
          const [ref2, name2] = splitAndAssert(line.toString("utf8"), " ", " ");
          refs.set(name2, ref2);
        }
      }
      for (const cap of capabilities) {
        if (cap.startsWith("symref=")) {
          const m2 = cap.match(/symref=([^:]+):(.*)/);
          if (m2.length === 3) {
            symrefs.set(m2[1], m2[2]);
          }
        }
      }
      return { protocolVersion: 1, capabilities, refs, symrefs };
    }
    function splitAndAssert(line, sep, expected) {
      const split = line.trim().split(sep);
      if (split.length !== 2) {
        throw new ParseError(
          `Two strings separated by '${expected}'`,
          line.toString("utf8")
        );
      }
      return split;
    }
    var corsProxify = (corsProxy, url) => corsProxy.endsWith("?") ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`;
    var updateHeaders = (headers, auth) => {
      if (auth.username || auth.password) {
        headers.Authorization = calculateBasicAuthHeader(auth);
      }
      if (auth.headers) {
        Object.assign(headers, auth.headers);
      }
    };
    var stringifyBody = async (res) => {
      try {
        const data = Buffer.from(await collect(res.body));
        const response = data.toString("utf8");
        const preview = response.length < 256 ? response : response.slice(0, 256) + "...";
        return { preview, response, data };
      } catch (e2) {
        return {};
      }
    };
    var GitRemoteHTTP = class {
      static async capabilities() {
        return ["discover", "connect"];
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {AuthCallback} [args.onAuth]
       * @param {AuthFailureCallback} [args.onAuthFailure]
       * @param {AuthSuccessCallback} [args.onAuthSuccess]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} args.headers
       * @param {1 | 2} args.protocolVersion - Git Protocol Version
       */
      static async discover({
        http: http3,
        onProgress,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service,
        url: _origUrl,
        headers,
        protocolVersion
      }) {
        let { url, auth } = extractAuthFromUrl(_origUrl);
        const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
        if (auth.username || auth.password) {
          headers.Authorization = calculateBasicAuthHeader(auth);
        }
        if (protocolVersion === 2) {
          headers["Git-Protocol"] = "version=2";
        }
        let res;
        let tryAgain;
        let providedAuthBefore = false;
        do {
          res = await http3.request({
            onProgress,
            method: "GET",
            url: `${proxifiedURL}/info/refs?service=${service}`,
            headers
          });
          tryAgain = false;
          if (res.statusCode === 401 || res.statusCode === 203) {
            const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
            if (getAuth) {
              auth = await getAuth(url, {
                ...auth,
                headers: { ...headers }
              });
              if (auth && auth.cancel) {
                throw new UserCanceledError();
              } else if (auth) {
                updateHeaders(headers, auth);
                providedAuthBefore = true;
                tryAgain = true;
              }
            }
          } else if (res.statusCode === 200 && providedAuthBefore && onAuthSuccess) {
            await onAuthSuccess(url, auth);
          }
        } while (tryAgain);
        if (res.statusCode !== 200) {
          const { response } = await stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        if (res.headers["content-type"] === `application/x-${service}-advertisement`) {
          const remoteHTTP = await parseRefsAdResponse(res.body, { service });
          remoteHTTP.auth = auth;
          return remoteHTTP;
        } else {
          const { preview, response, data } = await stringifyBody(res);
          try {
            const remoteHTTP = await parseRefsAdResponse([data], { service });
            remoteHTTP.auth = auth;
            return remoteHTTP;
          } catch (e2) {
            throw new SmartHttpError(preview, response);
          }
        }
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} [args.headers]
       * @param {any} args.body
       * @param {any} args.auth
       */
      static async connect({
        http: http3,
        onProgress,
        corsProxy,
        service,
        url,
        auth,
        body,
        headers
      }) {
        const urlAuth = extractAuthFromUrl(url);
        if (urlAuth)
          url = urlAuth.url;
        if (corsProxy)
          url = corsProxify(corsProxy, url);
        headers["content-type"] = `application/x-${service}-request`;
        headers.accept = `application/x-${service}-result`;
        updateHeaders(headers, auth);
        const res = await http3.request({
          onProgress,
          method: "POST",
          url: `${url}/${service}`,
          body,
          headers
        });
        if (res.statusCode !== 200) {
          const { response } = stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        return res;
      }
    };
    function parseRemoteUrl({ url }) {
      if (url.startsWith("git@")) {
        return {
          transport: "ssh",
          address: url
        };
      }
      const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
      if (matches === null)
        return;
      if (matches[2] === "://") {
        return {
          transport: matches[1],
          address: matches[0]
        };
      }
      if (matches[2] === "::") {
        return {
          transport: matches[1],
          address: matches[3]
        };
      }
    }
    var GitRemoteManager = class {
      static getRemoteHelperFor({ url }) {
        const remoteHelpers = /* @__PURE__ */ new Map();
        remoteHelpers.set("http", GitRemoteHTTP);
        remoteHelpers.set("https", GitRemoteHTTP);
        const parts = parseRemoteUrl({ url });
        if (!parts) {
          throw new UrlParseError(url);
        }
        if (remoteHelpers.has(parts.transport)) {
          return remoteHelpers.get(parts.transport);
        }
        throw new UnknownTransportError(
          url,
          parts.transport,
          parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 0
        );
      }
    };
    var lock$1 = null;
    var GitShallowManager = class {
      static async read({ fs: fs7, gitdir }) {
        if (lock$1 === null)
          lock$1 = new AsyncLock();
        const filepath = join(gitdir, "shallow");
        const oids = /* @__PURE__ */ new Set();
        await lock$1.acquire(filepath, async function() {
          const text = await fs7.read(filepath, { encoding: "utf8" });
          if (text === null)
            return oids;
          if (text.trim() === "")
            return oids;
          text.trim().split("\n").map((oid) => oids.add(oid));
        });
        return oids;
      }
      static async write({ fs: fs7, gitdir, oids }) {
        if (lock$1 === null)
          lock$1 = new AsyncLock();
        const filepath = join(gitdir, "shallow");
        if (oids.size > 0) {
          const text = [...oids].join("\n") + "\n";
          await lock$1.acquire(filepath, async function() {
            await fs7.write(filepath, text, {
              encoding: "utf8"
            });
          });
        } else {
          await lock$1.acquire(filepath, async function() {
            await fs7.rm(filepath);
          });
        }
      }
    };
    async function hasObjectLoose({ fs: fs7, gitdir, oid }) {
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      return fs7.exists(`${gitdir}/${source}`);
    }
    async function hasObjectPacked({
      fs: fs7,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    }) {
      let list = await fs7.readdir(join(gitdir, "objects/pack"));
      list = list.filter((x2) => x2.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs: fs7,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error)
          throw new InternalError(p.error);
        if (p.offsets.has(oid)) {
          return true;
        }
      }
      return false;
    }
    async function hasObject({
      fs: fs7,
      cache,
      gitdir,
      oid,
      format = "content"
    }) {
      const getExternalRefDelta = (oid2) => _readObject({ fs: fs7, cache, gitdir, oid: oid2 });
      let result = await hasObjectLoose({ fs: fs7, gitdir, oid });
      if (!result) {
        result = await hasObjectPacked({
          fs: fs7,
          cache,
          gitdir,
          oid,
          getExternalRefDelta
        });
      }
      return result;
    }
    function emptyPackfile(pack) {
      const pheader = "5041434b";
      const version3 = "00000002";
      const obCount = "00000000";
      const header = pheader + version3 + obCount;
      return pack.slice(0, 12).toString("hex") === header;
    }
    function filterCapabilities(server, client) {
      const serverNames = server.map((cap) => cap.split("=", 1)[0]);
      return client.filter((cap) => {
        const name = cap.split("=", 1)[0];
        return serverNames.includes(name);
      });
    }
    var pkg = {
      name: "isomorphic-git",
      version: "0.0.0-development",
      agent: "git/isomorphic-git@0.0.0-development"
    };
    var FIFO = class {
      constructor() {
        this._queue = [];
      }
      write(chunk) {
        if (this._ended) {
          throw Error("You cannot write to a FIFO that has already been ended!");
        }
        if (this._waiting) {
          const resolve2 = this._waiting;
          this._waiting = null;
          resolve2({ value: chunk });
        } else {
          this._queue.push(chunk);
        }
      }
      end() {
        this._ended = true;
        if (this._waiting) {
          const resolve2 = this._waiting;
          this._waiting = null;
          resolve2({ done: true });
        }
      }
      destroy(err) {
        this._ended = true;
        this.error = err;
      }
      async next() {
        if (this._queue.length > 0) {
          return { value: this._queue.shift() };
        }
        if (this._ended) {
          return { done: true };
        }
        if (this._waiting) {
          throw Error(
            "You cannot call read until the previous call to read has returned!"
          );
        }
        return new Promise((resolve2) => {
          this._waiting = resolve2;
        });
      }
    };
    function findSplit(str) {
      const r2 = str.indexOf("\r");
      const n = str.indexOf("\n");
      if (r2 === -1 && n === -1)
        return -1;
      if (r2 === -1)
        return n + 1;
      if (n === -1)
        return r2 + 1;
      if (n === r2 + 1)
        return n + 1;
      return Math.min(r2, n) + 1;
    }
    function splitLines(input) {
      const output = new FIFO();
      let tmp = "";
      (async () => {
        await forAwait(input, (chunk) => {
          chunk = chunk.toString("utf8");
          tmp += chunk;
          while (true) {
            const i2 = findSplit(tmp);
            if (i2 === -1)
              break;
            output.write(tmp.slice(0, i2));
            tmp = tmp.slice(i2);
          }
        });
        if (tmp.length > 0) {
          output.write(tmp);
        }
        output.end();
      })();
      return output;
    }
    var GitSideBand = class {
      static demux(input) {
        const read = GitPktLine.streamReader(input);
        const packetlines = new FIFO();
        const packfile = new FIFO();
        const progress = new FIFO();
        const nextBit = async function() {
          const line = await read();
          if (line === null)
            return nextBit();
          if (line === true) {
            packetlines.end();
            progress.end();
            packfile.end();
            return;
          }
          switch (line[0]) {
            case 1: {
              packfile.write(line.slice(1));
              break;
            }
            case 2: {
              progress.write(line.slice(1));
              break;
            }
            case 3: {
              const error = line.slice(1);
              progress.write(error);
              packfile.destroy(new Error(error.toString("utf8")));
              return;
            }
            default: {
              packetlines.write(line.slice(0));
            }
          }
          nextBit();
        };
        nextBit();
        return {
          packetlines,
          packfile,
          progress
        };
      }
      // static mux ({
      //   protocol, // 'side-band' or 'side-band-64k'
      //   packetlines,
      //   packfile,
      //   progress,
      //   error
      // }) {
      //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
      //   let output = new PassThrough()
      //   packetlines.on('data', data => {
      //     if (data === null) {
      //       output.write(GitPktLine.flush())
      //     } else {
      //       output.write(GitPktLine.encode(data))
      //     }
      //   })
      //   let packfileWasEmpty = true
      //   let packfileEnded = false
      //   let progressEnded = false
      //   let errorEnded = false
      //   let goodbye = Buffer.concat([
      //     GitPktLine.encode(Buffer.from('010A', 'hex')),
      //     GitPktLine.flush()
      //   ])
      //   packfile
      //     .on('data', data => {
      //       packfileWasEmpty = false
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       packfileEnded = true
      //       if (!packfileWasEmpty) output.write(goodbye)
      //       if (progressEnded && errorEnded) output.end()
      //     })
      //   progress
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       progressEnded = true
      //       if (packfileEnded && errorEnded) output.end()
      //     })
      //   error
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       errorEnded = true
      //       if (progressEnded && packfileEnded) output.end()
      //     })
      //   return output
      // }
    };
    async function parseUploadPackResponse(stream) {
      const { packetlines, packfile, progress } = GitSideBand.demux(stream);
      const shallows = [];
      const unshallows = [];
      const acks = [];
      let nak = false;
      let done = false;
      return new Promise((resolve2, reject) => {
        forAwait(packetlines, (data) => {
          const line = data.toString("utf8").trim();
          if (line.startsWith("shallow")) {
            const oid = line.slice(-41).trim();
            if (oid.length !== 40) {
              reject(new InvalidOidError(oid));
            }
            shallows.push(oid);
          } else if (line.startsWith("unshallow")) {
            const oid = line.slice(-41).trim();
            if (oid.length !== 40) {
              reject(new InvalidOidError(oid));
            }
            unshallows.push(oid);
          } else if (line.startsWith("ACK")) {
            const [, oid, status2] = line.split(" ");
            acks.push({ oid, status: status2 });
            if (!status2)
              done = true;
          } else if (line.startsWith("NAK")) {
            nak = true;
            done = true;
          }
          if (done) {
            resolve2({ shallows, unshallows, acks, nak, packfile, progress });
          }
        });
      });
    }
    function writeUploadPackRequest({
      capabilities = [],
      wants = [],
      haves = [],
      shallows = [],
      depth = null,
      since = null,
      exclude = []
    }) {
      const packstream = [];
      wants = [...new Set(wants)];
      let firstLineCapabilities = ` ${capabilities.join(" ")}`;
      for (const oid of wants) {
        packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`));
        firstLineCapabilities = "";
      }
      for (const oid of shallows) {
        packstream.push(GitPktLine.encode(`shallow ${oid}
`));
      }
      if (depth !== null) {
        packstream.push(GitPktLine.encode(`deepen ${depth}
`));
      }
      if (since !== null) {
        packstream.push(
          GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1e3)}
`)
        );
      }
      for (const oid of exclude) {
        packstream.push(GitPktLine.encode(`deepen-not ${oid}
`));
      }
      packstream.push(GitPktLine.flush());
      for (const oid of haves) {
        packstream.push(GitPktLine.encode(`have ${oid}
`));
      }
      packstream.push(GitPktLine.encode(`done
`));
      return packstream;
    }
    async function _fetch({
      fs: fs7,
      cache,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref: _ref,
      remoteRef: _remoteRef,
      remote: _remote,
      url: _url,
      corsProxy,
      depth = null,
      since = null,
      exclude = [],
      relative = false,
      tags = false,
      singleBranch = false,
      headers = {},
      prune = false,
      pruneTags = false
    }) {
      const ref = _ref || await _currentBranch({ fs: fs7, gitdir, test: true });
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      const remote = _remote || ref && await config3.get(`branch.${ref}.remote`) || "origin";
      const url = _url || await config3.get(`remote.${remote}.url`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remote OR url");
      }
      const remoteRef = _remoteRef || ref && await config3.get(`branch.${ref}.merge`) || _ref || "HEAD";
      if (corsProxy === void 0) {
        corsProxy = await config3.get("http.corsProxy");
      }
      const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
      const remoteHTTP = await GitRemoteHTTP2.discover({
        http: http3,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service: "git-upload-pack",
        url,
        headers,
        protocolVersion: 1
      });
      const auth = remoteHTTP.auth;
      const remoteRefs = remoteHTTP.refs;
      if (remoteRefs.size === 0) {
        return {
          defaultBranch: null,
          fetchHead: null,
          fetchHeadDescription: null
        };
      }
      if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
        throw new RemoteCapabilityError("shallow", "depth");
      }
      if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
        throw new RemoteCapabilityError("deepen-since", "since");
      }
      if (exclude.length > 0 && !remoteHTTP.capabilities.has("deepen-not")) {
        throw new RemoteCapabilityError("deepen-not", "exclude");
      }
      if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
        throw new RemoteCapabilityError("deepen-relative", "relative");
      }
      const { oid, fullref } = GitRefManager.resolveAgainstMap({
        ref: remoteRef,
        map: remoteRefs
      });
      for (const remoteRef2 of remoteRefs.keys()) {
        if (remoteRef2 === fullref || remoteRef2 === "HEAD" || remoteRef2.startsWith("refs/heads/") || tags && remoteRef2.startsWith("refs/tags/")) {
          continue;
        }
        remoteRefs.delete(remoteRef2);
      }
      const capabilities = filterCapabilities(
        [...remoteHTTP.capabilities],
        [
          "multi_ack_detailed",
          "no-done",
          "side-band-64k",
          // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
          // which is necessary for compatibility with git. It was the cause of mysterious
          // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
          // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
          // canonical git it turns out is NOT.
          "ofs-delta",
          `agent=${pkg.agent}`
        ]
      );
      if (relative)
        capabilities.push("deepen-relative");
      const wants = singleBranch ? [oid] : remoteRefs.values();
      const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({
        fs: fs7,
        gitdir,
        filepath: `refs`
      });
      let haves = [];
      for (let ref2 of haveRefs) {
        try {
          ref2 = await GitRefManager.expand({ fs: fs7, gitdir, ref: ref2 });
          const oid2 = await GitRefManager.resolve({ fs: fs7, gitdir, ref: ref2 });
          if (await hasObject({ fs: fs7, cache, gitdir, oid: oid2 })) {
            haves.push(oid2);
          }
        } catch (err) {
        }
      }
      haves = [...new Set(haves)];
      const oids = await GitShallowManager.read({ fs: fs7, gitdir });
      const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
      const packstream = writeUploadPackRequest({
        capabilities,
        wants,
        haves,
        shallows,
        depth,
        since,
        exclude
      });
      const packbuffer = Buffer.from(await collect(packstream));
      const raw2 = await GitRemoteHTTP2.connect({
        http: http3,
        onProgress,
        corsProxy,
        service: "git-upload-pack",
        url,
        auth,
        body: [packbuffer],
        headers
      });
      const response = await parseUploadPackResponse(raw2.body);
      if (raw2.headers) {
        response.headers = raw2.headers;
      }
      for (const oid2 of response.shallows) {
        if (!oids.has(oid2)) {
          try {
            const { object } = await _readObject({ fs: fs7, cache, gitdir, oid: oid2 });
            const commit2 = new GitCommit(object);
            const hasParents = await Promise.all(
              commit2.headers().parent.map((oid3) => hasObject({ fs: fs7, cache, gitdir, oid: oid3 }))
            );
            const haveAllParents = hasParents.length === 0 || hasParents.every((has) => has);
            if (!haveAllParents) {
              oids.add(oid2);
            }
          } catch (err) {
            oids.add(oid2);
          }
        }
      }
      for (const oid2 of response.unshallows) {
        oids.delete(oid2);
      }
      await GitShallowManager.write({ fs: fs7, gitdir, oids });
      if (singleBranch) {
        const refs = /* @__PURE__ */ new Map([[fullref, oid]]);
        const symrefs = /* @__PURE__ */ new Map();
        let bail = 10;
        let key = fullref;
        while (bail--) {
          const value = remoteHTTP.symrefs.get(key);
          if (value === void 0)
            break;
          symrefs.set(key, value);
          key = value;
        }
        const realRef = remoteRefs.get(key);
        if (realRef) {
          refs.set(key, realRef);
        }
        const { pruned } = await GitRefManager.updateRemoteRefs({
          fs: fs7,
          gitdir,
          remote,
          refs,
          symrefs,
          tags,
          prune
        });
        if (prune) {
          response.pruned = pruned;
        }
      } else {
        const { pruned } = await GitRefManager.updateRemoteRefs({
          fs: fs7,
          gitdir,
          remote,
          refs: remoteRefs,
          symrefs: remoteHTTP.symrefs,
          tags,
          prune,
          pruneTags
        });
        if (prune) {
          response.pruned = pruned;
        }
      }
      response.HEAD = remoteHTTP.symrefs.get("HEAD");
      if (response.HEAD === void 0) {
        const { oid: oid2 } = GitRefManager.resolveAgainstMap({
          ref: "HEAD",
          map: remoteRefs
        });
        for (const [key, value] of remoteRefs.entries()) {
          if (key !== "HEAD" && value === oid2) {
            response.HEAD = key;
            break;
          }
        }
      }
      const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
      response.FETCH_HEAD = {
        oid,
        description: `${noun} '${abbreviateRef(fullref)}' of ${url}`
      };
      if (onProgress || onMessage) {
        const lines = splitLines(response.progress);
        forAwait(lines, async (line) => {
          if (onMessage)
            await onMessage(line);
          if (onProgress) {
            const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
            if (matches) {
              await onProgress({
                phase: matches[1].trim(),
                loaded: parseInt(matches[2], 10),
                total: parseInt(matches[3], 10)
              });
            }
          }
        });
      }
      const packfile = Buffer.from(await collect(response.packfile));
      const packfileSha = packfile.slice(-20).toString("hex");
      const res = {
        defaultBranch: response.HEAD,
        fetchHead: response.FETCH_HEAD.oid,
        fetchHeadDescription: response.FETCH_HEAD.description
      };
      if (response.headers) {
        res.headers = response.headers;
      }
      if (prune) {
        res.pruned = response.pruned;
      }
      if (packfileSha !== "" && !emptyPackfile(packfile)) {
        res.packfile = `objects/pack/pack-${packfileSha}.pack`;
        const fullpath = join(gitdir, res.packfile);
        await fs7.write(fullpath, packfile);
        const getExternalRefDelta = (oid2) => _readObject({ fs: fs7, cache, gitdir, oid: oid2 });
        const idx = await GitPackIndex.fromPack({
          pack: packfile,
          getExternalRefDelta,
          onProgress
        });
        await fs7.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
      }
      return res;
    }
    async function _init({
      fs: fs7,
      bare = false,
      dir,
      gitdir = bare ? dir : join(dir, ".git"),
      defaultBranch = "master"
    }) {
      if (await fs7.exists(gitdir + "/config"))
        return;
      let folders = [
        "hooks",
        "info",
        "objects/info",
        "objects/pack",
        "refs/heads",
        "refs/tags"
      ];
      folders = folders.map((dir2) => gitdir + "/" + dir2);
      for (const folder of folders) {
        await fs7.mkdir(folder);
      }
      await fs7.write(
        gitdir + "/config",
        `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${bare}
` + (bare ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"
      );
      await fs7.write(gitdir + "/HEAD", `ref: refs/heads/${defaultBranch}
`);
    }
    async function _clone({
      fs: fs7,
      cache,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers
    }) {
      try {
        await _init({ fs: fs7, gitdir });
        await _addRemote({ fs: fs7, gitdir, remote, url, force: false });
        if (corsProxy) {
          const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
          await config3.set(`http.corsProxy`, corsProxy);
          await GitConfigManager.save({ fs: fs7, gitdir, config: config3 });
        }
        const { defaultBranch, fetchHead } = await _fetch({
          fs: fs7,
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          ref,
          remote,
          corsProxy,
          depth,
          since,
          exclude,
          relative,
          singleBranch,
          headers,
          tags: !noTags
        });
        if (fetchHead === null)
          return;
        ref = ref || defaultBranch;
        ref = ref.replace("refs/heads/", "");
        await _checkout({
          fs: fs7,
          cache,
          onProgress,
          dir,
          gitdir,
          ref,
          remote,
          noCheckout
        });
      } catch (err) {
        await fs7.rmdir(gitdir, { recursive: true, maxRetries: 10 }).catch(() => void 0);
        throw err;
      }
    }
    async function clone2({
      fs: fs7,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = join(dir, ".git"),
      url,
      corsProxy = void 0,
      ref = void 0,
      remote = "origin",
      depth = void 0,
      since = void 0,
      exclude = [],
      relative = false,
      singleBranch = false,
      noCheckout = false,
      noTags = false,
      headers = {},
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("http", http3);
        assertParameter("gitdir", gitdir);
        if (!noCheckout) {
          assertParameter("dir", dir);
        }
        assertParameter("url", url);
        return await _clone({
          fs: new FileSystem(fs7),
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          dir,
          gitdir,
          url,
          corsProxy,
          ref,
          remote,
          depth,
          since,
          exclude,
          relative,
          singleBranch,
          noCheckout,
          noTags,
          headers
        });
      } catch (err) {
        err.caller = "git.clone";
        throw err;
      }
    }
    async function commit({
      fs: _fs,
      onSign,
      dir,
      gitdir = join(dir, ".git"),
      message,
      author: _author,
      committer: _committer,
      signingKey,
      dryRun = false,
      noUpdateBranch = false,
      ref,
      parent,
      tree,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("message", message);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs7 = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs: fs7, gitdir, author: _author });
        if (!author)
          throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs: fs7,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer)
          throw new MissingNameError("committer");
        return await _commit({
          fs: fs7,
          cache,
          onSign,
          gitdir,
          message,
          author,
          committer,
          signingKey,
          dryRun,
          noUpdateBranch,
          ref,
          parent,
          tree
        });
      } catch (err) {
        err.caller = "git.commit";
        throw err;
      }
    }
    async function currentBranch({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      fullname = false,
      test = false
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        return await _currentBranch({
          fs: new FileSystem(fs7),
          gitdir,
          fullname,
          test
        });
      } catch (err) {
        err.caller = "git.currentBranch";
        throw err;
      }
    }
    async function _deleteBranch({ fs: fs7, gitdir, ref }) {
      const exist = await GitRefManager.exists({ fs: fs7, gitdir, ref });
      if (!exist) {
        throw new NotFoundError(ref);
      }
      const fullRef = await GitRefManager.expand({ fs: fs7, gitdir, ref });
      const currentRef = await _currentBranch({ fs: fs7, gitdir, fullname: true });
      if (fullRef === currentRef) {
        const value = await GitRefManager.resolve({ fs: fs7, gitdir, ref: fullRef });
        await GitRefManager.writeRef({ fs: fs7, gitdir, ref: "HEAD", value });
      }
      await GitRefManager.deleteRef({ fs: fs7, gitdir, ref: fullRef });
    }
    async function deleteBranch({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("ref", ref);
        return await _deleteBranch({
          fs: new FileSystem(fs7),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.deleteBranch";
        throw err;
      }
    }
    async function deleteRef({ fs: fs7, dir, gitdir = join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("ref", ref);
        await GitRefManager.deleteRef({ fs: new FileSystem(fs7), gitdir, ref });
      } catch (err) {
        err.caller = "git.deleteRef";
        throw err;
      }
    }
    async function _deleteRemote({ fs: fs7, gitdir, remote }) {
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      await config3.deleteSection("remote", remote);
      await GitConfigManager.save({ fs: fs7, gitdir, config: config3 });
    }
    async function deleteRemote({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      remote
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("remote", remote);
        return await _deleteRemote({
          fs: new FileSystem(fs7),
          gitdir,
          remote
        });
      } catch (err) {
        err.caller = "git.deleteRemote";
        throw err;
      }
    }
    async function _deleteTag({ fs: fs7, gitdir, ref }) {
      ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
      await GitRefManager.deleteRef({ fs: fs7, gitdir, ref });
    }
    async function deleteTag({ fs: fs7, dir, gitdir = join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("ref", ref);
        return await _deleteTag({
          fs: new FileSystem(fs7),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.deleteTag";
        throw err;
      }
    }
    async function expandOidLoose({ fs: fs7, gitdir, oid: short }) {
      const prefix = short.slice(0, 2);
      const objectsSuffixes = await fs7.readdir(`${gitdir}/objects/${prefix}`);
      return objectsSuffixes.map((suffix) => `${prefix}${suffix}`).filter((_oid) => _oid.startsWith(short));
    }
    async function expandOidPacked({
      fs: fs7,
      cache,
      gitdir,
      oid: short,
      getExternalRefDelta
    }) {
      const results = [];
      let list = await fs7.readdir(join(gitdir, "objects/pack"));
      list = list.filter((x2) => x2.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs: fs7,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error)
          throw new InternalError(p.error);
        for (const oid of p.offsets.keys()) {
          if (oid.startsWith(short))
            results.push(oid);
        }
      }
      return results;
    }
    async function _expandOid({ fs: fs7, cache, gitdir, oid: short }) {
      const getExternalRefDelta = (oid) => _readObject({ fs: fs7, cache, gitdir, oid });
      const results1 = await expandOidLoose({ fs: fs7, gitdir, oid: short });
      const results2 = await expandOidPacked({
        fs: fs7,
        cache,
        gitdir,
        oid: short,
        getExternalRefDelta
      });
      const results = results1.concat(results2);
      if (results.length === 1) {
        return results[0];
      }
      if (results.length > 1) {
        throw new AmbiguousError("oids", short, results);
      }
      throw new NotFoundError(`an object matching "${short}"`);
    }
    async function expandOid({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _expandOid({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.expandOid";
        throw err;
      }
    }
    async function expandRef({ fs: fs7, dir, gitdir = join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await GitRefManager.expand({
          fs: new FileSystem(fs7),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.expandRef";
        throw err;
      }
    }
    async function _findMergeBase({ fs: fs7, cache, gitdir, oids }) {
      const visits = {};
      const passes = oids.length;
      let heads = oids.map((oid, index2) => ({ index: index2, oid }));
      while (heads.length) {
        const result = /* @__PURE__ */ new Set();
        for (const { oid, index: index2 } of heads) {
          if (!visits[oid])
            visits[oid] = /* @__PURE__ */ new Set();
          visits[oid].add(index2);
          if (visits[oid].size === passes) {
            result.add(oid);
          }
        }
        if (result.size > 0) {
          return [...result];
        }
        const newheads = /* @__PURE__ */ new Map();
        for (const { oid, index: index2 } of heads) {
          try {
            const { object } = await _readObject({ fs: fs7, cache, gitdir, oid });
            const commit2 = GitCommit.from(object);
            const { parent } = commit2.parseHeaders();
            for (const oid2 of parent) {
              if (!visits[oid2] || !visits[oid2].has(index2)) {
                newheads.set(oid2 + ":" + index2, { oid: oid2, index: index2 });
              }
            }
          } catch (err) {
          }
        }
        heads = Array.from(newheads.values());
      }
      return [];
    }
    var LINEBREAKS = /^.*(\r?\n|$)/gm;
    function mergeFile({ branches, contents }) {
      const ourName = branches[1];
      const theirName = branches[2];
      const baseContent = contents[0];
      const ourContent = contents[1];
      const theirContent = contents[2];
      const ours = ourContent.match(LINEBREAKS);
      const base = baseContent.match(LINEBREAKS);
      const theirs = theirContent.match(LINEBREAKS);
      const result = diff3Merge(ours, base, theirs);
      const markerSize = 7;
      let mergedText = "";
      let cleanMerge = true;
      for (const item of result) {
        if (item.ok) {
          mergedText += item.ok.join("");
        }
        if (item.conflict) {
          cleanMerge = false;
          mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
          mergedText += item.conflict.a.join("");
          mergedText += `${"=".repeat(markerSize)}
`;
          mergedText += item.conflict.b.join("");
          mergedText += `${">".repeat(markerSize)} ${theirName}
`;
        }
      }
      return { cleanMerge, mergedText };
    }
    async function mergeTree({
      fs: fs7,
      cache,
      dir,
      gitdir = join(dir, ".git"),
      index: index2,
      ourOid,
      baseOid,
      theirOid,
      ourName = "ours",
      baseName = "base",
      theirName = "theirs",
      dryRun = false,
      abortOnConflict = true,
      mergeDriver
    }) {
      const ourTree = TREE({ ref: ourOid });
      const baseTree = TREE({ ref: baseOid });
      const theirTree = TREE({ ref: theirOid });
      const unmergedFiles = [];
      const results = await _walk({
        fs: fs7,
        cache,
        dir,
        gitdir,
        trees: [ourTree, baseTree, theirTree],
        map: async function(filepath, [ours, base, theirs]) {
          const path4 = basename(filepath);
          const ourChange = await modified(ours, base);
          const theirChange = await modified(theirs, base);
          switch (`${ourChange}-${theirChange}`) {
            case "false-false": {
              return {
                mode: await base.mode(),
                path: path4,
                oid: await base.oid(),
                type: await base.type()
              };
            }
            case "false-true": {
              return theirs ? {
                mode: await theirs.mode(),
                path: path4,
                oid: await theirs.oid(),
                type: await theirs.type()
              } : void 0;
            }
            case "true-false": {
              return ours ? {
                mode: await ours.mode(),
                path: path4,
                oid: await ours.oid(),
                type: await ours.type()
              } : void 0;
            }
            case "true-true": {
              if (ours && base && theirs && await ours.type() === "blob" && await base.type() === "blob" && await theirs.type() === "blob") {
                return mergeBlobs({
                  fs: fs7,
                  gitdir,
                  path: path4,
                  ours,
                  base,
                  theirs,
                  ourName,
                  baseName,
                  theirName,
                  mergeDriver
                }).then(async (r2) => {
                  if (!r2.cleanMerge) {
                    unmergedFiles.push(filepath);
                    if (!abortOnConflict) {
                      const baseOid2 = await base.oid();
                      const ourOid2 = await ours.oid();
                      const theirOid2 = await theirs.oid();
                      index2.delete({ filepath });
                      index2.insert({ filepath, oid: baseOid2, stage: 1 });
                      index2.insert({ filepath, oid: ourOid2, stage: 2 });
                      index2.insert({ filepath, oid: theirOid2, stage: 3 });
                    }
                  } else if (!abortOnConflict) {
                    index2.insert({ filepath, oid: r2.mergeResult.oid, stage: 0 });
                  }
                  return r2.mergeResult;
                });
              }
              throw new MergeNotSupportedError();
            }
          }
        },
        /**
         * @param {TreeEntry} [parent]
         * @param {Array<TreeEntry>} children
         */
        reduce: unmergedFiles.length !== 0 && (!dir || abortOnConflict) ? void 0 : async (parent, children) => {
          const entries = children.filter(Boolean);
          if (!parent)
            return;
          if (parent && parent.type === "tree" && entries.length === 0)
            return;
          if (entries.length > 0) {
            const tree = new GitTree(entries);
            const object = tree.toObject();
            const oid = await _writeObject({
              fs: fs7,
              gitdir,
              type: "tree",
              object,
              dryRun
            });
            parent.oid = oid;
          }
          return parent;
        }
      });
      if (unmergedFiles.length !== 0) {
        if (dir && !abortOnConflict) {
          await _walk({
            fs: fs7,
            cache,
            dir,
            gitdir,
            trees: [TREE({ ref: results.oid })],
            map: async function(filepath, [entry]) {
              const path4 = `${dir}/${filepath}`;
              if (await entry.type() === "blob") {
                const mode = await entry.mode();
                const content = new TextDecoder().decode(await entry.content());
                await fs7.write(path4, content, { mode });
              }
              return true;
            }
          });
        }
        return new MergeConflictError(unmergedFiles);
      }
      return results.oid;
    }
    async function mergeBlobs({
      fs: fs7,
      gitdir,
      path: path4,
      ours,
      base,
      theirs,
      ourName,
      theirName,
      baseName,
      dryRun,
      mergeDriver = mergeFile
    }) {
      const type = "blob";
      const mode = await base.mode() === await ours.mode() ? await theirs.mode() : await ours.mode();
      if (await ours.oid() === await theirs.oid()) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path4, oid: await ours.oid(), type }
        };
      }
      if (await ours.oid() === await base.oid()) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path4, oid: await theirs.oid(), type }
        };
      }
      if (await theirs.oid() === await base.oid()) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path4, oid: await ours.oid(), type }
        };
      }
      const ourContent = Buffer.from(await ours.content()).toString("utf8");
      const baseContent = Buffer.from(await base.content()).toString("utf8");
      const theirContent = Buffer.from(await theirs.content()).toString("utf8");
      const { mergedText, cleanMerge } = await mergeDriver({
        branches: [baseName, ourName, theirName],
        contents: [baseContent, ourContent, theirContent],
        path: path4
      });
      const oid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "blob",
        object: Buffer.from(mergedText, "utf8"),
        dryRun
      });
      return { cleanMerge, mergeResult: { mode, path: path4, oid, type } };
    }
    async function _merge({
      fs: fs7,
      cache,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      dryRun = false,
      noUpdateBranch = false,
      abortOnConflict = true,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver
    }) {
      if (ours === void 0) {
        ours = await _currentBranch({ fs: fs7, gitdir, fullname: true });
      }
      ours = await GitRefManager.expand({
        fs: fs7,
        gitdir,
        ref: ours
      });
      theirs = await GitRefManager.expand({
        fs: fs7,
        gitdir,
        ref: theirs
      });
      const ourOid = await GitRefManager.resolve({
        fs: fs7,
        gitdir,
        ref: ours
      });
      const theirOid = await GitRefManager.resolve({
        fs: fs7,
        gitdir,
        ref: theirs
      });
      const baseOids = await _findMergeBase({
        fs: fs7,
        cache,
        gitdir,
        oids: [ourOid, theirOid]
      });
      if (baseOids.length !== 1) {
        throw new MergeNotSupportedError();
      }
      const baseOid = baseOids[0];
      if (baseOid === theirOid) {
        return {
          oid: ourOid,
          alreadyMerged: true
        };
      }
      if (fastForward2 && baseOid === ourOid) {
        if (!dryRun && !noUpdateBranch) {
          await GitRefManager.writeRef({ fs: fs7, gitdir, ref: ours, value: theirOid });
        }
        return {
          oid: theirOid,
          fastForward: true
        };
      } else {
        if (fastForwardOnly) {
          throw new FastForwardError();
        }
        const tree = await GitIndexManager.acquire(
          { fs: fs7, gitdir, cache, allowUnmerged: false },
          async (index2) => {
            return mergeTree({
              fs: fs7,
              cache,
              dir,
              gitdir,
              index: index2,
              ourOid,
              theirOid,
              baseOid,
              ourName: abbreviateRef(ours),
              baseName: "base",
              theirName: abbreviateRef(theirs),
              dryRun,
              abortOnConflict,
              mergeDriver
            });
          }
        );
        if (tree instanceof MergeConflictError)
          throw tree;
        if (!message) {
          message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
            ours
          )}`;
        }
        const oid = await _commit({
          fs: fs7,
          cache,
          gitdir,
          message,
          ref: ours,
          tree,
          parent: [ourOid, theirOid],
          author,
          committer,
          signingKey,
          onSign,
          dryRun,
          noUpdateBranch
        });
        return {
          oid,
          tree,
          mergeCommit: true
        };
      }
    }
    async function _pull({
      fs: fs7,
      cache,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      prune,
      pruneTags,
      fastForward: fastForward2,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey
    }) {
      try {
        if (!ref) {
          const head = await _currentBranch({ fs: fs7, gitdir });
          if (!head) {
            throw new MissingParameterError("ref");
          }
          ref = head;
        }
        const { fetchHead, fetchHeadDescription } = await _fetch({
          fs: fs7,
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          corsProxy,
          ref,
          url,
          remote,
          remoteRef,
          singleBranch,
          headers,
          prune,
          pruneTags
        });
        await _merge({
          fs: fs7,
          cache,
          gitdir,
          ours: ref,
          theirs: fetchHead,
          fastForward: fastForward2,
          fastForwardOnly,
          message: `Merge ${fetchHeadDescription}`,
          author,
          committer,
          signingKey,
          dryRun: false,
          noUpdateBranch: false
        });
        await _checkout({
          fs: fs7,
          cache,
          onProgress,
          dir,
          gitdir,
          ref,
          remote,
          noCheckout: false
        });
      } catch (err) {
        err.caller = "git.pull";
        throw err;
      }
    }
    async function fastForward({
      fs: fs7,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      url,
      remote,
      remoteRef,
      corsProxy,
      singleBranch,
      headers = {},
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("http", http3);
        assertParameter("gitdir", gitdir);
        const thisWillNotBeUsed = {
          name: "",
          email: "",
          timestamp: Date.now(),
          timezoneOffset: 0
        };
        return await _pull({
          fs: new FileSystem(fs7),
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          dir,
          gitdir,
          ref,
          url,
          remote,
          remoteRef,
          fastForwardOnly: true,
          corsProxy,
          singleBranch,
          headers,
          author: thisWillNotBeUsed,
          committer: thisWillNotBeUsed
        });
      } catch (err) {
        err.caller = "git.fastForward";
        throw err;
      }
    }
    async function fetch3({
      fs: fs7,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth = null,
      since = null,
      exclude = [],
      relative = false,
      tags = false,
      singleBranch = false,
      headers = {},
      prune = false,
      pruneTags = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("http", http3);
        assertParameter("gitdir", gitdir);
        return await _fetch({
          fs: new FileSystem(fs7),
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          ref,
          remote,
          remoteRef,
          url,
          corsProxy,
          depth,
          since,
          exclude,
          relative,
          tags,
          singleBranch,
          headers,
          prune,
          pruneTags
        });
      } catch (err) {
        err.caller = "git.fetch";
        throw err;
      }
    }
    async function findMergeBase({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oids,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oids", oids);
        return await _findMergeBase({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oids
        });
      } catch (err) {
        err.caller = "git.findMergeBase";
        throw err;
      }
    }
    async function _findRoot({ fs: fs7, filepath }) {
      if (await fs7.exists(join(filepath, ".git"))) {
        return filepath;
      } else {
        const parent = dirname2(filepath);
        if (parent === filepath) {
          throw new NotFoundError(`git root for ${filepath}`);
        }
        return _findRoot({ fs: fs7, filepath: parent });
      }
    }
    async function findRoot({ fs: fs7, filepath }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("filepath", filepath);
        return await _findRoot({ fs: new FileSystem(fs7), filepath });
      } catch (err) {
        err.caller = "git.findRoot";
        throw err;
      }
    }
    async function getConfig2({ fs: fs7, dir, gitdir = join(dir, ".git"), path: path4 }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path4);
        return await _getConfig({
          fs: new FileSystem(fs7),
          gitdir,
          path: path4
        });
      } catch (err) {
        err.caller = "git.getConfig";
        throw err;
      }
    }
    async function _getConfigAll({ fs: fs7, gitdir, path: path4 }) {
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      return config3.getall(path4);
    }
    async function getConfigAll({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      path: path4
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path4);
        return await _getConfigAll({
          fs: new FileSystem(fs7),
          gitdir,
          path: path4
        });
      } catch (err) {
        err.caller = "git.getConfigAll";
        throw err;
      }
    }
    async function getRemoteInfo({
      http: http3,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false
    }) {
      try {
        assertParameter("http", http3);
        assertParameter("url", url);
        const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
        const remote = await GitRemoteHTTP2.discover({
          http: http3,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion: 1
        });
        const result = {
          capabilities: [...remote.capabilities]
        };
        for (const [ref, oid] of remote.refs) {
          const parts = ref.split("/");
          const last = parts.pop();
          let o = result;
          for (const part of parts) {
            o[part] = o[part] || {};
            o = o[part];
          }
          o[last] = oid;
        }
        for (const [symref, ref] of remote.symrefs) {
          const parts = symref.split("/");
          const last = parts.pop();
          let o = result;
          for (const part of parts) {
            o[part] = o[part] || {};
            o = o[part];
          }
          o[last] = ref;
        }
        return result;
      } catch (err) {
        err.caller = "git.getRemoteInfo";
        throw err;
      }
    }
    function formatInfoRefs(remote, prefix, symrefs, peelTags) {
      const refs = [];
      for (const [key, value] of remote.refs) {
        if (prefix && !key.startsWith(prefix))
          continue;
        if (key.endsWith("^{}")) {
          if (peelTags) {
            const _key = key.replace("^{}", "");
            const last = refs[refs.length - 1];
            const r2 = last.ref === _key ? last : refs.find((x2) => x2.ref === _key);
            if (r2 === void 0) {
              throw new Error("I did not expect this to happen");
            }
            r2.peeled = value;
          }
          continue;
        }
        const ref = { ref: key, oid: value };
        if (symrefs) {
          if (remote.symrefs.has(key)) {
            ref.target = remote.symrefs.get(key);
          }
        }
        refs.push(ref);
      }
      return refs;
    }
    async function getRemoteInfo2({
      http: http3,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false,
      protocolVersion = 2
    }) {
      try {
        assertParameter("http", http3);
        assertParameter("url", url);
        const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
        const remote = await GitRemoteHTTP2.discover({
          http: http3,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion
        });
        if (remote.protocolVersion === 2) {
          return {
            protocolVersion: remote.protocolVersion,
            capabilities: remote.capabilities2
          };
        }
        const capabilities = {};
        for (const cap of remote.capabilities) {
          const [key, value] = cap.split("=");
          if (value) {
            capabilities[key] = value;
          } else {
            capabilities[key] = true;
          }
        }
        return {
          protocolVersion: 1,
          capabilities,
          refs: formatInfoRefs(remote, void 0, true, true)
        };
      } catch (err) {
        err.caller = "git.getRemoteInfo2";
        throw err;
      }
    }
    async function hashObject({
      type,
      object,
      format = "content",
      oid = void 0
    }) {
      if (format !== "deflated") {
        if (format !== "wrapped") {
          object = GitObject.wrap({ type, object });
        }
        oid = await shasum(object);
      }
      return { oid, object };
    }
    async function hashBlob({ object }) {
      try {
        assertParameter("object", object);
        if (typeof object === "string") {
          object = Buffer.from(object, "utf8");
        } else {
          object = Buffer.from(object);
        }
        const type = "blob";
        const { oid, object: _object } = await hashObject({
          type: "blob",
          format: "content",
          object
        });
        return { oid, type, object: new Uint8Array(_object), format: "wrapped" };
      } catch (err) {
        err.caller = "git.hashBlob";
        throw err;
      }
    }
    async function _indexPack({
      fs: fs7,
      cache,
      onProgress,
      dir,
      gitdir,
      filepath
    }) {
      try {
        filepath = join(dir, filepath);
        const pack = await fs7.read(filepath);
        const getExternalRefDelta = (oid) => _readObject({ fs: fs7, cache, gitdir, oid });
        const idx = await GitPackIndex.fromPack({
          pack,
          getExternalRefDelta,
          onProgress
        });
        await fs7.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
        return {
          oids: [...idx.hashes]
        };
      } catch (err) {
        err.caller = "git.indexPack";
        throw err;
      }
    }
    async function indexPack({
      fs: fs7,
      onProgress,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("dir", dir);
        assertParameter("gitdir", dir);
        assertParameter("filepath", filepath);
        return await _indexPack({
          fs: new FileSystem(fs7),
          cache,
          onProgress,
          dir,
          gitdir,
          filepath
        });
      } catch (err) {
        err.caller = "git.indexPack";
        throw err;
      }
    }
    async function init3({
      fs: fs7,
      bare = false,
      dir,
      gitdir = bare ? dir : join(dir, ".git"),
      defaultBranch = "master"
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        if (!bare) {
          assertParameter("dir", dir);
        }
        return await _init({
          fs: new FileSystem(fs7),
          bare,
          dir,
          gitdir,
          defaultBranch
        });
      } catch (err) {
        err.caller = "git.init";
        throw err;
      }
    }
    async function _isDescendent({
      fs: fs7,
      cache,
      gitdir,
      oid,
      ancestor,
      depth
    }) {
      const shallows = await GitShallowManager.read({ fs: fs7, gitdir });
      if (!oid) {
        throw new MissingParameterError("oid");
      }
      if (!ancestor) {
        throw new MissingParameterError("ancestor");
      }
      if (oid === ancestor)
        return false;
      const queue = [oid];
      const visited = /* @__PURE__ */ new Set();
      let searchdepth = 0;
      while (queue.length) {
        if (searchdepth++ === depth) {
          throw new MaxDepthError(depth);
        }
        const oid2 = queue.shift();
        const { type, object } = await _readObject({
          fs: fs7,
          cache,
          gitdir,
          oid: oid2
        });
        if (type !== "commit") {
          throw new ObjectTypeError(oid2, type, "commit");
        }
        const commit2 = GitCommit.from(object).parse();
        for (const parent of commit2.parent) {
          if (parent === ancestor)
            return true;
        }
        if (!shallows.has(oid2)) {
          for (const parent of commit2.parent) {
            if (!visited.has(parent)) {
              queue.push(parent);
              visited.add(parent);
            }
          }
        }
      }
      return false;
    }
    async function isDescendent({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      ancestor,
      depth = -1,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        assertParameter("ancestor", ancestor);
        return await _isDescendent({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid,
          ancestor,
          depth
        });
      } catch (err) {
        err.caller = "git.isDescendent";
        throw err;
      }
    }
    async function isIgnored({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      filepath
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        return GitIgnoreManager.isIgnored({
          fs: new FileSystem(fs7),
          dir,
          gitdir,
          filepath
        });
      } catch (err) {
        err.caller = "git.isIgnored";
        throw err;
      }
    }
    async function listBranches({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      remote
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        return GitRefManager.listBranches({
          fs: new FileSystem(fs7),
          gitdir,
          remote
        });
      } catch (err) {
        err.caller = "git.listBranches";
        throw err;
      }
    }
    async function _listFiles({ fs: fs7, gitdir, ref, cache }) {
      if (ref) {
        const oid = await GitRefManager.resolve({ gitdir, fs: fs7, ref });
        const filenames = [];
        await accumulateFilesFromOid({
          fs: fs7,
          cache,
          gitdir,
          oid,
          filenames,
          prefix: ""
        });
        return filenames;
      } else {
        return GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          return index2.entries.map((x2) => x2.path);
        });
      }
    }
    async function accumulateFilesFromOid({
      fs: fs7,
      cache,
      gitdir,
      oid,
      filenames,
      prefix
    }) {
      const { tree } = await _readTree({ fs: fs7, cache, gitdir, oid });
      for (const entry of tree) {
        if (entry.type === "tree") {
          await accumulateFilesFromOid({
            fs: fs7,
            cache,
            gitdir,
            oid: entry.oid,
            filenames,
            prefix: join(prefix, entry.path)
          });
        } else {
          filenames.push(join(prefix, entry.path));
        }
      }
    }
    async function listFiles({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        return await _listFiles({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.listFiles";
        throw err;
      }
    }
    async function _listNotes({ fs: fs7, cache, gitdir, ref }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs: fs7, ref });
      } catch (err) {
        if (err instanceof NotFoundError) {
          return [];
        }
      }
      const result = await _readTree({
        fs: fs7,
        cache,
        gitdir,
        oid: parent
      });
      const notes = result.tree.map((entry) => ({
        target: entry.path,
        note: entry.oid
      }));
      return notes;
    }
    async function listNotes({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref = "refs/notes/commits",
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _listNotes({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.listNotes";
        throw err;
      }
    }
    async function _listRemotes({ fs: fs7, gitdir }) {
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      const remoteNames = await config3.getSubsections("remote");
      const remotes = Promise.all(
        remoteNames.map(async (remote) => {
          const url = await config3.get(`remote.${remote}.url`);
          return { remote, url };
        })
      );
      return remotes;
    }
    async function listRemotes({ fs: fs7, dir, gitdir = join(dir, ".git") }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        return await _listRemotes({
          fs: new FileSystem(fs7),
          gitdir
        });
      } catch (err) {
        err.caller = "git.listRemotes";
        throw err;
      }
    }
    async function parseListRefsResponse(stream) {
      const read = GitPktLine.streamReader(stream);
      const refs = [];
      let line;
      while (true) {
        line = await read();
        if (line === true)
          break;
        if (line === null)
          continue;
        line = line.toString("utf8").replace(/\n$/, "");
        const [oid, ref, ...attrs] = line.split(" ");
        const r2 = { ref, oid };
        for (const attr of attrs) {
          const [name, value] = attr.split(":");
          if (name === "symref-target") {
            r2.target = value;
          } else if (name === "peeled") {
            r2.peeled = value;
          }
        }
        refs.push(r2);
      }
      return refs;
    }
    async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
      const packstream = [];
      packstream.push(GitPktLine.encode("command=ls-refs\n"));
      packstream.push(GitPktLine.encode(`agent=${pkg.agent}
`));
      if (peelTags || symrefs || prefix) {
        packstream.push(GitPktLine.delim());
      }
      if (peelTags)
        packstream.push(GitPktLine.encode("peel"));
      if (symrefs)
        packstream.push(GitPktLine.encode("symrefs"));
      if (prefix)
        packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
      packstream.push(GitPktLine.flush());
      return packstream;
    }
    async function listServerRefs({
      http: http3,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false,
      protocolVersion = 2,
      prefix,
      symrefs,
      peelTags
    }) {
      try {
        assertParameter("http", http3);
        assertParameter("url", url);
        const remote = await GitRemoteHTTP.discover({
          http: http3,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion
        });
        if (remote.protocolVersion === 1) {
          return formatInfoRefs(remote, prefix, symrefs, peelTags);
        }
        const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
        const res = await GitRemoteHTTP.connect({
          http: http3,
          auth: remote.auth,
          headers,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          body
        });
        return parseListRefsResponse(res.body);
      } catch (err) {
        err.caller = "git.listServerRefs";
        throw err;
      }
    }
    async function listTags({ fs: fs7, dir, gitdir = join(dir, ".git") }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        return GitRefManager.listTags({ fs: new FileSystem(fs7), gitdir });
      } catch (err) {
        err.caller = "git.listTags";
        throw err;
      }
    }
    async function resolveCommit({ fs: fs7, cache, gitdir, oid }) {
      const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveCommit({ fs: fs7, cache, gitdir, oid });
      }
      if (type !== "commit") {
        throw new ObjectTypeError(oid, type, "commit");
      }
      return { commit: GitCommit.from(object), oid };
    }
    async function _readCommit({ fs: fs7, cache, gitdir, oid }) {
      const { commit: commit2, oid: commitOid } = await resolveCommit({
        fs: fs7,
        cache,
        gitdir,
        oid
      });
      const result = {
        oid: commitOid,
        commit: commit2.parse(),
        payload: commit2.withoutSignature()
      };
      return result;
    }
    function compareAge(a, b) {
      return a.committer.timestamp - b.committer.timestamp;
    }
    var EMPTY_OID = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
    async function resolveFileIdInTree({ fs: fs7, cache, gitdir, oid, fileId }) {
      if (fileId === EMPTY_OID)
        return;
      const _oid = oid;
      let filepath;
      const result = await resolveTree({ fs: fs7, cache, gitdir, oid });
      const tree = result.tree;
      if (fileId === result.oid) {
        filepath = result.path;
      } else {
        filepath = await _resolveFileId({
          fs: fs7,
          cache,
          gitdir,
          tree,
          fileId,
          oid: _oid
        });
        if (Array.isArray(filepath)) {
          if (filepath.length === 0)
            filepath = void 0;
          else if (filepath.length === 1)
            filepath = filepath[0];
        }
      }
      return filepath;
    }
    async function _resolveFileId({
      fs: fs7,
      cache,
      gitdir,
      tree,
      fileId,
      oid,
      filepaths = [],
      parentPath = ""
    }) {
      const walks = tree.entries().map(function(entry) {
        let result;
        if (entry.oid === fileId) {
          result = join(parentPath, entry.path);
          filepaths.push(result);
        } else if (entry.type === "tree") {
          result = _readObject({
            fs: fs7,
            cache,
            gitdir,
            oid: entry.oid
          }).then(function({ object }) {
            return _resolveFileId({
              fs: fs7,
              cache,
              gitdir,
              tree: GitTree.from(object),
              fileId,
              oid,
              filepaths,
              parentPath: join(parentPath, entry.path)
            });
          });
        }
        return result;
      });
      await Promise.all(walks);
      return filepaths;
    }
    async function _log({
      fs: fs7,
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow
    }) {
      const sinceTimestamp = typeof since === "undefined" ? void 0 : Math.floor(since.valueOf() / 1e3);
      const commits = [];
      const shallowCommits = await GitShallowManager.read({ fs: fs7, gitdir });
      const oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref });
      const tips = [await _readCommit({ fs: fs7, cache, gitdir, oid })];
      let lastFileOid;
      let lastCommit;
      let isOk;
      function endCommit(commit2) {
        if (isOk && filepath)
          commits.push(commit2);
      }
      while (tips.length > 0) {
        const commit2 = tips.pop();
        if (sinceTimestamp !== void 0 && commit2.commit.committer.timestamp <= sinceTimestamp) {
          break;
        }
        if (filepath) {
          let vFileOid;
          try {
            vFileOid = await resolveFilepath({
              fs: fs7,
              cache,
              gitdir,
              oid: commit2.commit.tree,
              filepath
            });
            if (lastCommit && lastFileOid !== vFileOid) {
              commits.push(lastCommit);
            }
            lastFileOid = vFileOid;
            lastCommit = commit2;
            isOk = true;
          } catch (e2) {
            if (e2 instanceof NotFoundError) {
              let found = follow && lastFileOid;
              if (found) {
                found = await resolveFileIdInTree({
                  fs: fs7,
                  cache,
                  gitdir,
                  oid: commit2.commit.tree,
                  fileId: lastFileOid
                });
                if (found) {
                  if (Array.isArray(found)) {
                    if (lastCommit) {
                      const lastFound = await resolveFileIdInTree({
                        fs: fs7,
                        cache,
                        gitdir,
                        oid: lastCommit.commit.tree,
                        fileId: lastFileOid
                      });
                      if (Array.isArray(lastFound)) {
                        found = found.filter((p) => lastFound.indexOf(p) === -1);
                        if (found.length === 1) {
                          found = found[0];
                          filepath = found;
                          if (lastCommit)
                            commits.push(lastCommit);
                        } else {
                          found = false;
                          if (lastCommit)
                            commits.push(lastCommit);
                          break;
                        }
                      }
                    }
                  } else {
                    filepath = found;
                    if (lastCommit)
                      commits.push(lastCommit);
                  }
                }
              }
              if (!found) {
                if (isOk && lastFileOid) {
                  commits.push(lastCommit);
                  if (!force)
                    break;
                }
                if (!force && !follow)
                  throw e2;
              }
              lastCommit = commit2;
              isOk = false;
            } else
              throw e2;
          }
        } else {
          commits.push(commit2);
        }
        if (depth !== void 0 && commits.length === depth) {
          endCommit(commit2);
          break;
        }
        if (!shallowCommits.has(commit2.oid)) {
          for (const oid2 of commit2.commit.parent) {
            const commit3 = await _readCommit({ fs: fs7, cache, gitdir, oid: oid2 });
            if (!tips.map((commit4) => commit4.oid).includes(commit3.oid)) {
              tips.push(commit3);
            }
          }
        }
        if (tips.length === 0) {
          endCommit(commit2);
        }
        tips.sort((a, b) => compareAge(a.commit, b.commit));
      }
      return commits;
    }
    async function log2({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      ref = "HEAD",
      depth,
      since,
      // Date
      force,
      follow,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _log({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          filepath,
          ref,
          depth,
          since,
          force,
          follow
        });
      } catch (err) {
        err.caller = "git.log";
        throw err;
      }
    }
    async function merge({
      fs: _fs,
      onSign,
      dir,
      gitdir = join(dir, ".git"),
      ours,
      theirs,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      dryRun = false,
      noUpdateBranch = false,
      abortOnConflict = true,
      message,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {},
      mergeDriver
    }) {
      try {
        assertParameter("fs", _fs);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs7 = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs: fs7, gitdir, author: _author });
        if (!author && (!fastForwardOnly || !fastForward2)) {
          throw new MissingNameError("author");
        }
        const committer = await normalizeCommitterObject({
          fs: fs7,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer && (!fastForwardOnly || !fastForward2)) {
          throw new MissingNameError("committer");
        }
        return await _merge({
          fs: fs7,
          cache,
          dir,
          gitdir,
          ours,
          theirs,
          fastForward: fastForward2,
          fastForwardOnly,
          dryRun,
          noUpdateBranch,
          abortOnConflict,
          message,
          author,
          committer,
          signingKey,
          onSign,
          mergeDriver
        });
      } catch (err) {
        err.caller = "git.merge";
        throw err;
      }
    }
    var types3 = {
      commit: 16,
      tree: 32,
      blob: 48,
      tag: 64,
      ofs_delta: 96,
      ref_delta: 112
    };
    async function _pack({
      fs: fs7,
      cache,
      dir,
      gitdir = join(dir, ".git"),
      oids
    }) {
      const hash = new Hash();
      const outputStream = [];
      function write(chunk, enc) {
        const buff = Buffer.from(chunk, enc);
        outputStream.push(buff);
        hash.update(buff);
      }
      async function writeObject2({ stype, object }) {
        const type = types3[stype];
        let length = object.length;
        let multibyte = length > 15 ? 128 : 0;
        const lastFour = length & 15;
        length = length >>> 4;
        let byte = (multibyte | type | lastFour).toString(16);
        write(byte, "hex");
        while (multibyte) {
          multibyte = length > 127 ? 128 : 0;
          byte = multibyte | length & 127;
          write(padHex(2, byte), "hex");
          length = length >>> 7;
        }
        write(Buffer.from(await deflate(object)));
      }
      write("PACK");
      write("00000002", "hex");
      write(padHex(8, oids.length), "hex");
      for (const oid of oids) {
        const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
        await writeObject2({ write, object, stype: type });
      }
      const digest = hash.digest();
      outputStream.push(digest);
      return outputStream;
    }
    async function _packObjects({ fs: fs7, cache, gitdir, oids, write }) {
      const buffers = await _pack({ fs: fs7, cache, gitdir, oids });
      const packfile = Buffer.from(await collect(buffers));
      const packfileSha = packfile.slice(-20).toString("hex");
      const filename = `pack-${packfileSha}.pack`;
      if (write) {
        await fs7.write(join(gitdir, `objects/pack/${filename}`), packfile);
        return { filename };
      }
      return {
        filename,
        packfile: new Uint8Array(packfile)
      };
    }
    async function packObjects({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oids,
      write = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oids", oids);
        return await _packObjects({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oids,
          write
        });
      } catch (err) {
        err.caller = "git.packObjects";
        throw err;
      }
    }
    async function pull({
      fs: _fs,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      url,
      remote,
      remoteRef,
      prune = false,
      pruneTags = false,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      corsProxy,
      singleBranch,
      headers = {},
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        const fs7 = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs: fs7, gitdir, author: _author });
        if (!author)
          throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs: fs7,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer)
          throw new MissingNameError("committer");
        return await _pull({
          fs: fs7,
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          dir,
          gitdir,
          ref,
          url,
          remote,
          remoteRef,
          fastForward: fastForward2,
          fastForwardOnly,
          corsProxy,
          singleBranch,
          headers,
          author,
          committer,
          signingKey,
          prune,
          pruneTags
        });
      } catch (err) {
        err.caller = "git.pull";
        throw err;
      }
    }
    async function listCommitsAndTags({
      fs: fs7,
      cache,
      dir,
      gitdir = join(dir, ".git"),
      start,
      finish
    }) {
      const shallows = await GitShallowManager.read({ fs: fs7, gitdir });
      const startingSet = /* @__PURE__ */ new Set();
      const finishingSet = /* @__PURE__ */ new Set();
      for (const ref of start) {
        startingSet.add(await GitRefManager.resolve({ fs: fs7, gitdir, ref }));
      }
      for (const ref of finish) {
        try {
          const oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref });
          finishingSet.add(oid);
        } catch (err) {
        }
      }
      const visited = /* @__PURE__ */ new Set();
      async function walk2(oid) {
        visited.add(oid);
        const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
        if (type === "tag") {
          const tag2 = GitAnnotatedTag.from(object);
          const commit2 = tag2.headers().object;
          return walk2(commit2);
        }
        if (type !== "commit") {
          throw new ObjectTypeError(oid, type, "commit");
        }
        if (!shallows.has(oid)) {
          const commit2 = GitCommit.from(object);
          const parents = commit2.headers().parent;
          for (oid of parents) {
            if (!finishingSet.has(oid) && !visited.has(oid)) {
              await walk2(oid);
            }
          }
        }
      }
      for (const oid of startingSet) {
        await walk2(oid);
      }
      return visited;
    }
    async function listObjects({
      fs: fs7,
      cache,
      dir,
      gitdir = join(dir, ".git"),
      oids
    }) {
      const visited = /* @__PURE__ */ new Set();
      async function walk2(oid) {
        if (visited.has(oid))
          return;
        visited.add(oid);
        const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
        if (type === "tag") {
          const tag2 = GitAnnotatedTag.from(object);
          const obj = tag2.headers().object;
          await walk2(obj);
        } else if (type === "commit") {
          const commit2 = GitCommit.from(object);
          const tree = commit2.headers().tree;
          await walk2(tree);
        } else if (type === "tree") {
          const tree = GitTree.from(object);
          for (const entry of tree) {
            if (entry.type === "blob") {
              visited.add(entry.oid);
            }
            if (entry.type === "tree") {
              await walk2(entry.oid);
            }
          }
        }
      }
      for (const oid of oids) {
        await walk2(oid);
      }
      return visited;
    }
    async function parseReceivePackResponse(packfile) {
      const result = {};
      let response = "";
      const read = GitPktLine.streamReader(packfile);
      let line = await read();
      while (line !== true) {
        if (line !== null)
          response += line.toString("utf8") + "\n";
        line = await read();
      }
      const lines = response.toString("utf8").split("\n");
      line = lines.shift();
      if (!line.startsWith("unpack ")) {
        throw new ParseError('unpack ok" or "unpack [error message]', line);
      }
      result.ok = line === "unpack ok";
      if (!result.ok) {
        result.error = line.slice("unpack ".length);
      }
      result.refs = {};
      for (const line2 of lines) {
        if (line2.trim() === "")
          continue;
        const status2 = line2.slice(0, 2);
        const refAndMessage = line2.slice(3);
        let space = refAndMessage.indexOf(" ");
        if (space === -1)
          space = refAndMessage.length;
        const ref = refAndMessage.slice(0, space);
        const error = refAndMessage.slice(space + 1);
        result.refs[ref] = {
          ok: status2 === "ok",
          error
        };
      }
      return result;
    }
    async function writeReceivePackRequest({
      capabilities = [],
      triplets = []
    }) {
      const packstream = [];
      let capsFirstLine = `\0 ${capabilities.join(" ")}`;
      for (const trip of triplets) {
        packstream.push(
          GitPktLine.encode(
            `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
          )
        );
        capsFirstLine = "";
      }
      packstream.push(GitPktLine.flush());
      return packstream;
    }
    async function _push({
      fs: fs7,
      cache,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref: _ref,
      remoteRef: _remoteRef,
      remote,
      url: _url,
      force = false,
      delete: _delete2 = false,
      corsProxy,
      headers = {}
    }) {
      const ref = _ref || await _currentBranch({ fs: fs7, gitdir });
      if (typeof ref === "undefined") {
        throw new MissingParameterError("ref");
      }
      const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
      remote = remote || await config3.get(`branch.${ref}.pushRemote`) || await config3.get("remote.pushDefault") || await config3.get(`branch.${ref}.remote`) || "origin";
      const url = _url || await config3.get(`remote.${remote}.pushurl`) || await config3.get(`remote.${remote}.url`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remote OR url");
      }
      const remoteRef = _remoteRef || await config3.get(`branch.${ref}.merge`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remoteRef");
      }
      if (corsProxy === void 0) {
        corsProxy = await config3.get("http.corsProxy");
      }
      const fullRef = await GitRefManager.expand({ fs: fs7, gitdir, ref });
      const oid = _delete2 ? "0000000000000000000000000000000000000000" : await GitRefManager.resolve({ fs: fs7, gitdir, ref: fullRef });
      const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
      const httpRemote = await GitRemoteHTTP2.discover({
        http: http3,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service: "git-receive-pack",
        url,
        headers,
        protocolVersion: 1
      });
      const auth = httpRemote.auth;
      let fullRemoteRef;
      if (!remoteRef) {
        fullRemoteRef = fullRef;
      } else {
        try {
          fullRemoteRef = await GitRefManager.expandAgainstMap({
            ref: remoteRef,
            map: httpRemote.refs
          });
        } catch (err) {
          if (err instanceof NotFoundError) {
            fullRemoteRef = remoteRef.startsWith("refs/") ? remoteRef : `refs/heads/${remoteRef}`;
          } else {
            throw err;
          }
        }
      }
      const oldoid = httpRemote.refs.get(fullRemoteRef) || "0000000000000000000000000000000000000000";
      const thinPack = !httpRemote.capabilities.has("no-thin");
      let objects = /* @__PURE__ */ new Set();
      if (!_delete2) {
        const finish = [...httpRemote.refs.values()];
        let skipObjects = /* @__PURE__ */ new Set();
        if (oldoid !== "0000000000000000000000000000000000000000") {
          const mergebase = await _findMergeBase({
            fs: fs7,
            cache,
            gitdir,
            oids: [oid, oldoid]
          });
          for (const oid2 of mergebase)
            finish.push(oid2);
          if (thinPack) {
            skipObjects = await listObjects({ fs: fs7, cache, gitdir, oids: mergebase });
          }
        }
        if (!finish.includes(oid)) {
          const commits = await listCommitsAndTags({
            fs: fs7,
            cache,
            gitdir,
            start: [oid],
            finish
          });
          objects = await listObjects({ fs: fs7, cache, gitdir, oids: commits });
        }
        if (thinPack) {
          try {
            const ref2 = await GitRefManager.resolve({
              fs: fs7,
              gitdir,
              ref: `refs/remotes/${remote}/HEAD`,
              depth: 2
            });
            const { oid: oid2 } = await GitRefManager.resolveAgainstMap({
              ref: ref2.replace(`refs/remotes/${remote}/`, ""),
              fullref: ref2,
              map: httpRemote.refs
            });
            const oids = [oid2];
            for (const oid3 of await listObjects({ fs: fs7, cache, gitdir, oids })) {
              skipObjects.add(oid3);
            }
          } catch (e2) {
          }
          for (const oid2 of skipObjects) {
            objects.delete(oid2);
          }
        }
        if (oid === oldoid)
          force = true;
        if (!force) {
          if (fullRef.startsWith("refs/tags") && oldoid !== "0000000000000000000000000000000000000000") {
            throw new PushRejectedError("tag-exists");
          }
          if (oid !== "0000000000000000000000000000000000000000" && oldoid !== "0000000000000000000000000000000000000000" && !await _isDescendent({
            fs: fs7,
            cache,
            gitdir,
            oid,
            ancestor: oldoid,
            depth: -1
          })) {
            throw new PushRejectedError("not-fast-forward");
          }
        }
      }
      const capabilities = filterCapabilities(
        [...httpRemote.capabilities],
        ["report-status", "side-band-64k", `agent=${pkg.agent}`]
      );
      const packstream1 = await writeReceivePackRequest({
        capabilities,
        triplets: [{ oldoid, oid, fullRef: fullRemoteRef }]
      });
      const packstream2 = _delete2 ? [] : await _pack({
        fs: fs7,
        cache,
        gitdir,
        oids: [...objects]
      });
      const res = await GitRemoteHTTP2.connect({
        http: http3,
        onProgress,
        corsProxy,
        service: "git-receive-pack",
        url,
        auth,
        headers,
        body: [...packstream1, ...packstream2]
      });
      const { packfile, progress } = await GitSideBand.demux(res.body);
      if (onMessage) {
        const lines = splitLines(progress);
        forAwait(lines, async (line) => {
          await onMessage(line);
        });
      }
      const result = await parseReceivePackResponse(packfile);
      if (res.headers) {
        result.headers = res.headers;
      }
      if (remote && result.ok && result.refs[fullRemoteRef].ok) {
        const ref2 = `refs/remotes/${remote}/${fullRemoteRef.replace(
          "refs/heads",
          ""
        )}`;
        if (_delete2) {
          await GitRefManager.deleteRef({ fs: fs7, gitdir, ref: ref2 });
        } else {
          await GitRefManager.writeRef({ fs: fs7, gitdir, ref: ref2, value: oid });
        }
      }
      if (result.ok && Object.values(result.refs).every((result2) => result2.ok)) {
        return result;
      } else {
        const prettyDetails = Object.entries(result.refs).filter(([k, v]) => !v.ok).map(([k, v]) => `
  - ${k}: ${v.error}`).join("");
        throw new GitPushError(prettyDetails, result);
      }
    }
    async function push({
      fs: fs7,
      http: http3,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      remoteRef,
      remote = "origin",
      url,
      force = false,
      delete: _delete2 = false,
      corsProxy,
      headers = {},
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("http", http3);
        assertParameter("gitdir", gitdir);
        return await _push({
          fs: new FileSystem(fs7),
          cache,
          http: http3,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          ref,
          remoteRef,
          remote,
          url,
          force,
          delete: _delete2,
          corsProxy,
          headers
        });
      } catch (err) {
        err.caller = "git.push";
        throw err;
      }
    }
    async function resolveBlob({ fs: fs7, cache, gitdir, oid }) {
      const { type, object } = await _readObject({ fs: fs7, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveBlob({ fs: fs7, cache, gitdir, oid });
      }
      if (type !== "blob") {
        throw new ObjectTypeError(oid, type, "blob");
      }
      return { oid, blob: new Uint8Array(object) };
    }
    async function _readBlob({
      fs: fs7,
      cache,
      gitdir,
      oid,
      filepath = void 0
    }) {
      if (filepath !== void 0) {
        oid = await resolveFilepath({ fs: fs7, cache, gitdir, oid, filepath });
      }
      const blob = await resolveBlob({
        fs: fs7,
        cache,
        gitdir,
        oid
      });
      return blob;
    }
    async function readBlob({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readBlob({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (err) {
        err.caller = "git.readBlob";
        throw err;
      }
    }
    async function readCommit({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readCommit({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.readCommit";
        throw err;
      }
    }
    async function _readNote({
      fs: fs7,
      cache,
      gitdir,
      ref = "refs/notes/commits",
      oid
    }) {
      const parent = await GitRefManager.resolve({ gitdir, fs: fs7, ref });
      const { blob } = await _readBlob({
        fs: fs7,
        cache,
        gitdir,
        oid: parent,
        filepath: oid
      });
      return blob;
    }
    async function readNote({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("oid", oid);
        return await _readNote({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          ref,
          oid
        });
      } catch (err) {
        err.caller = "git.readNote";
        throw err;
      }
    }
    async function readObject({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      format = "parsed",
      filepath = void 0,
      encoding = void 0,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        const fs7 = new FileSystem(_fs);
        if (filepath !== void 0) {
          oid = await resolveFilepath({
            fs: fs7,
            cache,
            gitdir,
            oid,
            filepath
          });
        }
        const _format = format === "parsed" ? "content" : format;
        const result = await _readObject({
          fs: fs7,
          cache,
          gitdir,
          oid,
          format: _format
        });
        result.oid = oid;
        if (format === "parsed") {
          result.format = "parsed";
          switch (result.type) {
            case "commit":
              result.object = GitCommit.from(result.object).parse();
              break;
            case "tree":
              result.object = GitTree.from(result.object).entries();
              break;
            case "blob":
              if (encoding) {
                result.object = result.object.toString(encoding);
              } else {
                result.object = new Uint8Array(result.object);
                result.format = "content";
              }
              break;
            case "tag":
              result.object = GitAnnotatedTag.from(result.object).parse();
              break;
            default:
              throw new ObjectTypeError(
                result.oid,
                result.type,
                "blob|commit|tag|tree"
              );
          }
        } else if (result.format === "deflated" || result.format === "wrapped") {
          result.type = result.format;
        }
        return result;
      } catch (err) {
        err.caller = "git.readObject";
        throw err;
      }
    }
    async function _readTag({ fs: fs7, cache, gitdir, oid }) {
      const { type, object } = await _readObject({
        fs: fs7,
        cache,
        gitdir,
        oid,
        format: "content"
      });
      if (type !== "tag") {
        throw new ObjectTypeError(oid, type, "tag");
      }
      const tag2 = GitAnnotatedTag.from(object);
      const result = {
        oid,
        tag: tag2.parse(),
        payload: tag2.payload()
      };
      return result;
    }
    async function readTag({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readTag({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.readTag";
        throw err;
      }
    }
    async function readTree({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      oid,
      filepath = void 0,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readTree({
          fs: new FileSystem(fs7),
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (err) {
        err.caller = "git.readTree";
        throw err;
      }
    }
    async function remove({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        await GitIndexManager.acquire(
          { fs: new FileSystem(_fs), gitdir, cache },
          async function(index2) {
            index2.delete({ filepath });
          }
        );
      } catch (err) {
        err.caller = "git.remove";
        throw err;
      }
    }
    async function _removeNote({
      fs: fs7,
      cache,
      onSign,
      gitdir,
      ref = "refs/notes/commits",
      oid,
      author,
      committer,
      signingKey
    }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs: fs7, ref });
      } catch (err) {
        if (!(err instanceof NotFoundError)) {
          throw err;
        }
      }
      const result = await _readTree({
        fs: fs7,
        gitdir,
        oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
      });
      let tree = result.tree;
      tree = tree.filter((entry) => entry.path !== oid);
      const treeOid = await _writeTree({
        fs: fs7,
        gitdir,
        tree
      });
      const commitOid = await _commit({
        fs: fs7,
        cache,
        onSign,
        gitdir,
        ref,
        tree: treeOid,
        parent: parent && [parent],
        message: `Note removed by 'isomorphic-git removeNote'
`,
        author,
        committer,
        signingKey
      });
      return commitOid;
    }
    async function removeNote({
      fs: _fs,
      onSign,
      dir,
      gitdir = join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        const fs7 = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs: fs7, gitdir, author: _author });
        if (!author)
          throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs: fs7,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer)
          throw new MissingNameError("committer");
        return await _removeNote({
          fs: fs7,
          cache,
          onSign,
          gitdir,
          ref,
          oid,
          author,
          committer,
          signingKey
        });
      } catch (err) {
        err.caller = "git.removeNote";
        throw err;
      }
    }
    async function _renameBranch({
      fs: fs7,
      gitdir,
      oldref,
      ref,
      checkout: checkout2 = false
    }) {
      if (ref !== cleanGitRef.clean(ref)) {
        throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
      }
      if (oldref !== cleanGitRef.clean(oldref)) {
        throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref));
      }
      const fulloldref = `refs/heads/${oldref}`;
      const fullnewref = `refs/heads/${ref}`;
      const newexist = await GitRefManager.exists({ fs: fs7, gitdir, ref: fullnewref });
      if (newexist) {
        throw new AlreadyExistsError("branch", ref, false);
      }
      const value = await GitRefManager.resolve({
        fs: fs7,
        gitdir,
        ref: fulloldref,
        depth: 1
      });
      await GitRefManager.writeRef({ fs: fs7, gitdir, ref: fullnewref, value });
      await GitRefManager.deleteRef({ fs: fs7, gitdir, ref: fulloldref });
      if (checkout2) {
        await GitRefManager.writeSymbolicRef({
          fs: fs7,
          gitdir,
          ref: "HEAD",
          value: fullnewref
        });
      }
    }
    async function renameBranch({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      oldref,
      checkout: checkout2 = false
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("oldref", oldref);
        return await _renameBranch({
          fs: new FileSystem(fs7),
          gitdir,
          ref,
          oldref,
          checkout: checkout2
        });
      } catch (err) {
        err.caller = "git.renameBranch";
        throw err;
      }
    }
    async function hashObject$1({ gitdir, type, object }) {
      return shasum(GitObject.wrap({ type, object }));
    }
    async function resetIndex({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      ref,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs7 = new FileSystem(_fs);
        let oid;
        let workdirOid;
        try {
          oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref: ref || "HEAD" });
        } catch (e2) {
          if (ref) {
            throw e2;
          }
        }
        if (oid) {
          try {
            oid = await resolveFilepath({
              fs: fs7,
              cache,
              gitdir,
              oid,
              filepath
            });
          } catch (e2) {
            oid = null;
          }
        }
        let stats = {
          ctime: /* @__PURE__ */ new Date(0),
          mtime: /* @__PURE__ */ new Date(0),
          dev: 0,
          ino: 0,
          mode: 0,
          uid: 0,
          gid: 0,
          size: 0
        };
        const object = dir && await fs7.read(join(dir, filepath));
        if (object) {
          workdirOid = await hashObject$1({
            gitdir,
            type: "blob",
            object
          });
          if (oid === workdirOid) {
            stats = await fs7.lstat(join(dir, filepath));
          }
        }
        await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          index2.delete({ filepath });
          if (oid) {
            index2.insert({ filepath, stats, oid });
          }
        });
      } catch (err) {
        err.caller = "git.reset";
        throw err;
      }
    }
    async function resolveRef({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      depth
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const oid = await GitRefManager.resolve({
          fs: new FileSystem(fs7),
          gitdir,
          ref,
          depth
        });
        return oid;
      } catch (err) {
        err.caller = "git.resolveRef";
        throw err;
      }
    }
    async function setConfig({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      path: path4,
      value,
      append = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path4);
        const fs7 = new FileSystem(_fs);
        const config3 = await GitConfigManager.get({ fs: fs7, gitdir });
        if (append) {
          await config3.append(path4, value);
        } else {
          await config3.set(path4, value);
        }
        await GitConfigManager.save({ fs: fs7, gitdir, config: config3 });
      } catch (err) {
        err.caller = "git.setConfig";
        throw err;
      }
    }
    async function status({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs7 = new FileSystem(_fs);
        const ignored = await GitIgnoreManager.isIgnored({
          fs: fs7,
          gitdir,
          dir,
          filepath
        });
        if (ignored) {
          return "ignored";
        }
        const headTree = await getHeadTree({ fs: fs7, cache, gitdir });
        const treeOid = await getOidAtPath({
          fs: fs7,
          cache,
          gitdir,
          tree: headTree,
          path: filepath
        });
        const indexEntry = await GitIndexManager.acquire(
          { fs: fs7, gitdir, cache },
          async function(index2) {
            for (const entry of index2) {
              if (entry.path === filepath)
                return entry;
            }
            return null;
          }
        );
        const stats = await fs7.lstat(join(dir, filepath));
        const H = treeOid !== null;
        const I = indexEntry !== null;
        const W = stats !== null;
        const getWorkdirOid = async () => {
          if (I && !compareStats(indexEntry, stats)) {
            return indexEntry.oid;
          } else {
            const object = await fs7.read(join(dir, filepath));
            const workdirOid = await hashObject$1({
              gitdir,
              type: "blob",
              object
            });
            if (I && indexEntry.oid === workdirOid) {
              if (stats.size !== -1) {
                GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
                  index2.insert({ filepath, stats, oid: workdirOid });
                });
              }
            }
            return workdirOid;
          }
        };
        if (!H && !W && !I)
          return "absent";
        if (!H && !W && I)
          return "*absent";
        if (!H && W && !I)
          return "*added";
        if (!H && W && I) {
          const workdirOid = await getWorkdirOid();
          return workdirOid === indexEntry.oid ? "added" : "*added";
        }
        if (H && !W && !I)
          return "deleted";
        if (H && !W && I) {
          return treeOid === indexEntry.oid ? "*deleted" : "*deleted";
        }
        if (H && W && !I) {
          const workdirOid = await getWorkdirOid();
          return workdirOid === treeOid ? "*undeleted" : "*undeletemodified";
        }
        if (H && W && I) {
          const workdirOid = await getWorkdirOid();
          if (workdirOid === treeOid) {
            return workdirOid === indexEntry.oid ? "unmodified" : "*unmodified";
          } else {
            return workdirOid === indexEntry.oid ? "modified" : "*modified";
          }
        }
      } catch (err) {
        err.caller = "git.status";
        throw err;
      }
    }
    async function getOidAtPath({ fs: fs7, cache, gitdir, tree, path: path4 }) {
      if (typeof path4 === "string")
        path4 = path4.split("/");
      const dirname3 = path4.shift();
      for (const entry of tree) {
        if (entry.path === dirname3) {
          if (path4.length === 0) {
            return entry.oid;
          }
          const { type, object } = await _readObject({
            fs: fs7,
            cache,
            gitdir,
            oid: entry.oid
          });
          if (type === "tree") {
            const tree2 = GitTree.from(object);
            return getOidAtPath({ fs: fs7, cache, gitdir, tree: tree2, path: path4 });
          }
          if (type === "blob") {
            throw new ObjectTypeError(entry.oid, type, "blob", path4.join("/"));
          }
        }
      }
      return null;
    }
    async function getHeadTree({ fs: fs7, cache, gitdir }) {
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs: fs7, gitdir, ref: "HEAD" });
      } catch (e2) {
        if (e2 instanceof NotFoundError) {
          return [];
        }
      }
      const { tree } = await _readTree({ fs: fs7, cache, gitdir, oid });
      return tree;
    }
    async function statusMatrix({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      ref = "HEAD",
      filepaths = ["."],
      filter,
      cache = {},
      ignored: shouldIgnore = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const fs7 = new FileSystem(_fs);
        return await _walk({
          fs: fs7,
          cache,
          dir,
          gitdir,
          trees: [TREE({ ref }), WORKDIR(), STAGE()],
          map: async function(filepath, [head, workdir, stage]) {
            if (!head && !stage && workdir) {
              if (!shouldIgnore) {
                const isIgnored2 = await GitIgnoreManager.isIgnored({
                  fs: fs7,
                  dir,
                  filepath
                });
                if (isIgnored2) {
                  return null;
                }
              }
            }
            if (!filepaths.some((base) => worthWalking(filepath, base))) {
              return null;
            }
            if (filter) {
              if (!filter(filepath))
                return;
            }
            const [headType, workdirType, stageType] = await Promise.all([
              head && head.type(),
              workdir && workdir.type(),
              stage && stage.type()
            ]);
            const isBlob2 = [headType, workdirType, stageType].includes("blob");
            if ((headType === "tree" || headType === "special") && !isBlob2)
              return;
            if (headType === "commit")
              return null;
            if ((workdirType === "tree" || workdirType === "special") && !isBlob2)
              return;
            if (stageType === "commit")
              return null;
            if ((stageType === "tree" || stageType === "special") && !isBlob2)
              return;
            const headOid = headType === "blob" ? await head.oid() : void 0;
            const stageOid = stageType === "blob" ? await stage.oid() : void 0;
            let workdirOid;
            if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
              workdirOid = "42";
            } else if (workdirType === "blob") {
              workdirOid = await workdir.oid();
            }
            const entry = [void 0, headOid, workdirOid, stageOid];
            const result = entry.map((value) => entry.indexOf(value));
            result.shift();
            return [filepath, ...result];
          }
        });
      } catch (err) {
        err.caller = "git.statusMatrix";
        throw err;
      }
    }
    async function tag({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      object,
      force = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const fs7 = new FileSystem(_fs);
        if (ref === void 0) {
          throw new MissingParameterError("ref");
        }
        ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
        const value = await GitRefManager.resolve({
          fs: fs7,
          gitdir,
          ref: object || "HEAD"
        });
        if (!force && await GitRefManager.exists({ fs: fs7, gitdir, ref })) {
          throw new AlreadyExistsError("tag", ref);
        }
        await GitRefManager.writeRef({ fs: fs7, gitdir, ref, value });
      } catch (err) {
        err.caller = "git.tag";
        throw err;
      }
    }
    async function updateIndex({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      cache = {},
      filepath,
      oid,
      mode,
      add: add3,
      remove: remove2,
      force
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs7 = new FileSystem(_fs);
        if (remove2) {
          return await GitIndexManager.acquire(
            { fs: fs7, gitdir, cache },
            async function(index2) {
              let fileStats2;
              if (!force) {
                fileStats2 = await fs7.lstat(join(dir, filepath));
                if (fileStats2) {
                  if (fileStats2.isDirectory()) {
                    throw new InvalidFilepathError("directory");
                  }
                  return;
                }
              }
              if (index2.has({ filepath })) {
                index2.delete({
                  filepath
                });
              }
            }
          );
        }
        let fileStats;
        if (!oid) {
          fileStats = await fs7.lstat(join(dir, filepath));
          if (!fileStats) {
            throw new NotFoundError(
              `file at "${filepath}" on disk and "remove" not set`
            );
          }
          if (fileStats.isDirectory()) {
            throw new InvalidFilepathError("directory");
          }
        }
        return await GitIndexManager.acquire({ fs: fs7, gitdir, cache }, async function(index2) {
          if (!add3 && !index2.has({ filepath })) {
            throw new NotFoundError(
              `file at "${filepath}" in index and "add" not set`
            );
          }
          let stats = {
            ctime: /* @__PURE__ */ new Date(0),
            mtime: /* @__PURE__ */ new Date(0),
            dev: 0,
            ino: 0,
            mode,
            uid: 0,
            gid: 0,
            size: 0
          };
          if (!oid) {
            stats = fileStats;
            const object = stats.isSymbolicLink() ? await fs7.readlink(join(dir, filepath)) : await fs7.read(join(dir, filepath));
            oid = await _writeObject({
              fs: fs7,
              gitdir,
              type: "blob",
              format: "content",
              object
            });
          }
          index2.insert({
            filepath,
            oid,
            stats
          });
          return oid;
        });
      } catch (err) {
        err.caller = "git.updateIndex";
        throw err;
      }
    }
    function version2() {
      try {
        return pkg.version;
      } catch (err) {
        err.caller = "git.version";
        throw err;
      }
    }
    async function walk({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      trees,
      map,
      reduce,
      iterate,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("trees", trees);
        return await _walk({
          fs: new FileSystem(fs7),
          cache,
          dir,
          gitdir,
          trees,
          map,
          reduce,
          iterate
        });
      } catch (err) {
        err.caller = "git.walk";
        throw err;
      }
    }
    async function writeBlob({ fs: fs7, dir, gitdir = join(dir, ".git"), blob }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("blob", blob);
        return await _writeObject({
          fs: new FileSystem(fs7),
          gitdir,
          type: "blob",
          object: blob,
          format: "content"
        });
      } catch (err) {
        err.caller = "git.writeBlob";
        throw err;
      }
    }
    async function _writeCommit({ fs: fs7, gitdir, commit: commit2 }) {
      const object = GitCommit.from(commit2).toObject();
      const oid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "commit",
        object,
        format: "content"
      });
      return oid;
    }
    async function writeCommit({
      fs: fs7,
      dir,
      gitdir = join(dir, ".git"),
      commit: commit2
    }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("commit", commit2);
        return await _writeCommit({
          fs: new FileSystem(fs7),
          gitdir,
          commit: commit2
        });
      } catch (err) {
        err.caller = "git.writeCommit";
        throw err;
      }
    }
    async function writeObject({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      type,
      object,
      format = "parsed",
      oid,
      encoding = void 0
    }) {
      try {
        const fs7 = new FileSystem(_fs);
        if (format === "parsed") {
          switch (type) {
            case "commit":
              object = GitCommit.from(object).toObject();
              break;
            case "tree":
              object = GitTree.from(object).toObject();
              break;
            case "blob":
              object = Buffer.from(object, encoding);
              break;
            case "tag":
              object = GitAnnotatedTag.from(object).toObject();
              break;
            default:
              throw new ObjectTypeError(oid || "", type, "blob|commit|tag|tree");
          }
          format = "content";
        }
        oid = await _writeObject({
          fs: fs7,
          gitdir,
          type,
          object,
          oid,
          format
        });
        return oid;
      } catch (err) {
        err.caller = "git.writeObject";
        throw err;
      }
    }
    async function writeRef({
      fs: _fs,
      dir,
      gitdir = join(dir, ".git"),
      ref,
      value,
      force = false,
      symbolic = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("value", value);
        const fs7 = new FileSystem(_fs);
        if (ref !== cleanGitRef.clean(ref)) {
          throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
        }
        if (!force && await GitRefManager.exists({ fs: fs7, gitdir, ref })) {
          throw new AlreadyExistsError("ref", ref);
        }
        if (symbolic) {
          await GitRefManager.writeSymbolicRef({
            fs: fs7,
            gitdir,
            ref,
            value
          });
        } else {
          value = await GitRefManager.resolve({
            fs: fs7,
            gitdir,
            ref: value
          });
          await GitRefManager.writeRef({
            fs: fs7,
            gitdir,
            ref,
            value
          });
        }
      } catch (err) {
        err.caller = "git.writeRef";
        throw err;
      }
    }
    async function _writeTag({ fs: fs7, gitdir, tag: tag2 }) {
      const object = GitAnnotatedTag.from(tag2).toObject();
      const oid = await _writeObject({
        fs: fs7,
        gitdir,
        type: "tag",
        object,
        format: "content"
      });
      return oid;
    }
    async function writeTag({ fs: fs7, dir, gitdir = join(dir, ".git"), tag: tag2 }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("tag", tag2);
        return await _writeTag({
          fs: new FileSystem(fs7),
          gitdir,
          tag: tag2
        });
      } catch (err) {
        err.caller = "git.writeTag";
        throw err;
      }
    }
    async function writeTree({ fs: fs7, dir, gitdir = join(dir, ".git"), tree }) {
      try {
        assertParameter("fs", fs7);
        assertParameter("gitdir", gitdir);
        assertParameter("tree", tree);
        return await _writeTree({
          fs: new FileSystem(fs7),
          gitdir,
          tree
        });
      } catch (err) {
        err.caller = "git.writeTree";
        throw err;
      }
    }
    var index = {
      Errors,
      STAGE,
      TREE,
      WORKDIR,
      add: add2,
      abortMerge,
      addNote,
      addRemote,
      annotatedTag,
      branch,
      checkout,
      clone: clone2,
      commit,
      getConfig: getConfig2,
      getConfigAll,
      setConfig,
      currentBranch,
      deleteBranch,
      deleteRef,
      deleteRemote,
      deleteTag,
      expandOid,
      expandRef,
      fastForward,
      fetch: fetch3,
      findMergeBase,
      findRoot,
      getRemoteInfo,
      getRemoteInfo2,
      hashBlob,
      indexPack,
      init: init3,
      isDescendent,
      isIgnored,
      listBranches,
      listFiles,
      listNotes,
      listRemotes,
      listServerRefs,
      listTags,
      log: log2,
      merge,
      packObjects,
      pull,
      push,
      readBlob,
      readCommit,
      readNote,
      readObject,
      readTag,
      readTree,
      remove,
      removeNote,
      renameBranch,
      resetIndex,
      updateIndex,
      resolveRef,
      status,
      statusMatrix,
      tag,
      version: version2,
      walk,
      writeBlob,
      writeCommit,
      writeObject,
      writeRef,
      writeTag,
      writeTree
    };
    exports.Errors = Errors;
    exports.STAGE = STAGE;
    exports.TREE = TREE;
    exports.WORKDIR = WORKDIR;
    exports.abortMerge = abortMerge;
    exports.add = add2;
    exports.addNote = addNote;
    exports.addRemote = addRemote;
    exports.annotatedTag = annotatedTag;
    exports.branch = branch;
    exports.checkout = checkout;
    exports.clone = clone2;
    exports.commit = commit;
    exports.currentBranch = currentBranch;
    exports.default = index;
    exports.deleteBranch = deleteBranch;
    exports.deleteRef = deleteRef;
    exports.deleteRemote = deleteRemote;
    exports.deleteTag = deleteTag;
    exports.expandOid = expandOid;
    exports.expandRef = expandRef;
    exports.fastForward = fastForward;
    exports.fetch = fetch3;
    exports.findMergeBase = findMergeBase;
    exports.findRoot = findRoot;
    exports.getConfig = getConfig2;
    exports.getConfigAll = getConfigAll;
    exports.getRemoteInfo = getRemoteInfo;
    exports.getRemoteInfo2 = getRemoteInfo2;
    exports.hashBlob = hashBlob;
    exports.indexPack = indexPack;
    exports.init = init3;
    exports.isDescendent = isDescendent;
    exports.isIgnored = isIgnored;
    exports.listBranches = listBranches;
    exports.listFiles = listFiles;
    exports.listNotes = listNotes;
    exports.listRemotes = listRemotes;
    exports.listServerRefs = listServerRefs;
    exports.listTags = listTags;
    exports.log = log2;
    exports.merge = merge;
    exports.packObjects = packObjects;
    exports.pull = pull;
    exports.push = push;
    exports.readBlob = readBlob;
    exports.readCommit = readCommit;
    exports.readNote = readNote;
    exports.readObject = readObject;
    exports.readTag = readTag;
    exports.readTree = readTree;
    exports.remove = remove;
    exports.removeNote = removeNote;
    exports.renameBranch = renameBranch;
    exports.resetIndex = resetIndex;
    exports.resolveRef = resolveRef;
    exports.setConfig = setConfig;
    exports.status = status;
    exports.statusMatrix = statusMatrix;
    exports.tag = tag;
    exports.updateIndex = updateIndex;
    exports.version = version2;
    exports.walk = walk;
    exports.writeBlob = writeBlob;
    exports.writeCommit = writeCommit;
    exports.writeObject = writeObject;
    exports.writeRef = writeRef;
    exports.writeTag = writeTag;
    exports.writeTree = writeTree;
  }
});

// ../../node_modules/posthog-js/dist/module.js
var require_module2 = __commonJS({
  "../../node_modules/posthog-js/dist/module.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function e2(e3, t3) {
      var r3 = Object.keys(e3);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e3);
        t3 && (n2 = n2.filter(function(t4) {
          return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
        })), r3.push.apply(r3, n2);
      }
      return r3;
    }
    function t2(t3) {
      for (var r3 = 1; r3 < arguments.length; r3++) {
        var n2 = null != arguments[r3] ? arguments[r3] : {};
        r3 % 2 ? e2(Object(n2), true).forEach(function(e3) {
          s2(t3, e3, n2[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(n2)) : e2(Object(n2)).forEach(function(e3) {
          Object.defineProperty(t3, e3, Object.getOwnPropertyDescriptor(n2, e3));
        });
      }
      return t3;
    }
    function r2(e3) {
      return r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      }, r2(e3);
    }
    function n(e3, t3) {
      if (!(e3 instanceof t3))
        throw new TypeError("Cannot call a class as a function");
    }
    function i2(e3, t3) {
      for (var r3 = 0; r3 < t3.length; r3++) {
        var n2 = t3[r3];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
      }
    }
    function o(e3, t3, r3) {
      return t3 && i2(e3.prototype, t3), r3 && i2(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
    }
    function s2(e3, t3, r3) {
      return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
    }
    function a(e3, t3) {
      if ("function" != typeof t3 && null !== t3)
        throw new TypeError("Super expression must either be null or a function");
      e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && u(e3, t3);
    }
    function c(e3) {
      return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
        return e4.__proto__ || Object.getPrototypeOf(e4);
      }, c(e3);
    }
    function u(e3, t3) {
      return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
        return e4.__proto__ = t4, e4;
      }, u(e3, t3);
    }
    function l(e3, t3) {
      if (null == e3)
        return {};
      var r3, n2, i3 = function(e4, t4) {
        if (null == e4)
          return {};
        var r4, n3, i4 = {}, o3 = Object.keys(e4);
        for (n3 = 0; n3 < o3.length; n3++)
          r4 = o3[n3], t4.indexOf(r4) >= 0 || (i4[r4] = e4[r4]);
        return i4;
      }(e3, t3);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e3);
        for (n2 = 0; n2 < o2.length; n2++)
          r3 = o2[n2], t3.indexOf(r3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, r3) && (i3[r3] = e3[r3]);
      }
      return i3;
    }
    function d(e3, t3) {
      if (t3 && ("object" == typeof t3 || "function" == typeof t3))
        return t3;
      if (void 0 !== t3)
        throw new TypeError("Derived constructors may only return object or undefined");
      return function(e4) {
        if (void 0 === e4)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e4;
      }(e3);
    }
    function p(e3) {
      var t3 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e4) {
          return false;
        }
      }();
      return function() {
        var r3, n2 = c(e3);
        if (t3) {
          var i3 = c(this).constructor;
          r3 = Reflect.construct(n2, arguments, i3);
        } else
          r3 = n2.apply(this, arguments);
        return d(this, r3);
      };
    }
    function f3(e3, t3) {
      return function(e4) {
        if (Array.isArray(e4))
          return e4;
      }(e3) || function(e4, t4) {
        var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
        if (null == r3)
          return;
        var n2, i3, o2 = [], s3 = true, a2 = false;
        try {
          for (r3 = r3.call(e4); !(s3 = (n2 = r3.next()).done) && (o2.push(n2.value), !t4 || o2.length !== t4); s3 = true)
            ;
        } catch (e5) {
          a2 = true, i3 = e5;
        } finally {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (a2)
              throw i3;
          }
        }
        return o2;
      }(e3, t3) || _(e3, t3) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function h2(e3) {
      return function(e4) {
        if (Array.isArray(e4))
          return g(e4);
      }(e3) || function(e4) {
        if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"])
          return Array.from(e4);
      }(e3) || _(e3) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function _(e3, t3) {
      if (e3) {
        if ("string" == typeof e3)
          return g(e3, t3);
        var r3 = Object.prototype.toString.call(e3).slice(8, -1);
        return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? g(e3, t3) : void 0;
      }
    }
    function g(e3, t3) {
      (null == t3 || t3 > e3.length) && (t3 = e3.length);
      for (var r3 = 0, n2 = new Array(t3); r3 < t3; r3++)
        n2[r3] = e3[r3];
      return n2;
    }
    function v(e3, t3) {
      var r3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
      if (!r3) {
        if (Array.isArray(e3) || (r3 = _(e3)) || t3 && e3 && "number" == typeof e3.length) {
          r3 && (e3 = r3);
          var n2 = 0, i3 = function() {
          };
          return { s: i3, n: function() {
            return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
          }, e: function(e4) {
            throw e4;
          }, f: i3 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o2, s3 = true, a2 = false;
      return { s: function() {
        r3 = r3.call(e3);
      }, n: function() {
        var e4 = r3.next();
        return s3 = e4.done, e4;
      }, e: function(e4) {
        a2 = true, o2 = e4;
      }, f: function() {
        try {
          s3 || null == r3.return || r3.return();
        } finally {
          if (a2)
            throw o2;
        }
      } };
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var y = String.fromCharCode;
    var m2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
    var w = {};
    function k(e3, t3) {
      if (!w[e3]) {
        w[e3] = {};
        for (var r3 = 0; r3 < e3.length; r3++)
          w[e3][e3.charAt(r3)] = r3;
      }
      return w[e3][t3];
    }
    var F2 = { compressToBase64: function(e3) {
      if (null == e3)
        return "";
      var t3 = F2._compress(e3, 6, function(e4) {
        return m2.charAt(e4);
      });
      switch (t3.length % 4) {
        default:
        case 0:
          return t3;
        case 1:
          return t3 + "===";
        case 2:
          return t3 + "==";
        case 3:
          return t3 + "=";
      }
    }, decompressFromBase64: function(e3) {
      return null == e3 ? "" : "" == e3 ? null : F2._decompress(e3.length, 32, function(t3) {
        return k(m2, e3.charAt(t3));
      });
    }, compressToUTF16: function(e3) {
      return null == e3 ? "" : F2._compress(e3, 15, function(e4) {
        return y(e4 + 32);
      }) + " ";
    }, decompressFromUTF16: function(e3) {
      return null == e3 ? "" : "" == e3 ? null : F2._decompress(e3.length, 16384, function(t3) {
        return e3.charCodeAt(t3) - 32;
      });
    }, compressToUint8Array: function(e3) {
      for (var t3 = F2.compress(e3), r3 = new Uint8Array(2 * t3.length), n2 = 0, i3 = t3.length; n2 < i3; n2++) {
        var o2 = t3.charCodeAt(n2);
        r3[2 * n2] = o2 >>> 8, r3[2 * n2 + 1] = o2 % 256;
      }
      return r3;
    }, decompressFromUint8Array: function(e3) {
      if (null == e3)
        return F2.decompress(e3);
      for (var t3 = new Array(e3.length / 2), r3 = 0, n2 = t3.length; r3 < n2; r3++)
        t3[r3] = 256 * e3[2 * r3] + e3[2 * r3 + 1];
      var i3 = [];
      return t3.forEach(function(e4) {
        i3.push(y(e4));
      }), F2.decompress(i3.join(""));
    }, compressToEncodedURIComponent: function(e3) {
      return null == e3 ? "" : F2._compress(e3, 6, function(e4) {
        return b.charAt(e4);
      });
    }, decompressFromEncodedURIComponent: function(e3) {
      return null == e3 ? "" : "" == e3 ? null : (e3 = e3.replace(/ /g, "+"), F2._decompress(e3.length, 32, function(t3) {
        return k(b, e3.charAt(t3));
      }));
    }, compress: function(e3) {
      return F2._compress(e3, 16, function(e4) {
        return y(e4);
      });
    }, _compress: function(e3, t3, r3) {
      if (null == e3)
        return "";
      var n2, i3, o2, s3 = "", a2 = "", c2 = "", u2 = 2, l2 = 3, d2 = 2, p2 = 0, f4 = 0, h3 = {}, _2 = {}, g2 = [];
      for (o2 = 0; o2 < e3.length; o2 += 1)
        if (s3 = e3.charAt(o2), Object.prototype.hasOwnProperty.call(h3, s3) || (h3[s3] = l2++, _2[s3] = true), a2 = c2 + s3, Object.prototype.hasOwnProperty.call(h3, a2))
          c2 = a2;
        else {
          if (Object.prototype.hasOwnProperty.call(_2, c2)) {
            if (c2.charCodeAt(0) < 256) {
              for (n2 = 0; n2 < d2; n2++)
                p2 <<= 1, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++;
              for (i3 = c2.charCodeAt(0), n2 = 0; n2 < 8; n2++)
                p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
            } else {
              for (i3 = 1, n2 = 0; n2 < d2; n2++)
                p2 = p2 << 1 | i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 = 0;
              for (i3 = c2.charCodeAt(0), n2 = 0; n2 < 16; n2++)
                p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
            }
            0 == --u2 && (u2 = Math.pow(2, d2), d2++), delete _2[c2];
          } else
            for (i3 = h3[c2], n2 = 0; n2 < d2; n2++)
              p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
          0 == --u2 && (u2 = Math.pow(2, d2), d2++), h3[a2] = l2++, c2 = String(s3);
        }
      if ("" !== c2) {
        if (Object.prototype.hasOwnProperty.call(_2, c2)) {
          if (c2.charCodeAt(0) < 256) {
            for (n2 = 0; n2 < d2; n2++)
              p2 <<= 1, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++;
            for (i3 = c2.charCodeAt(0), n2 = 0; n2 < 8; n2++)
              p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
          } else {
            for (i3 = 1, n2 = 0; n2 < d2; n2++)
              p2 = p2 << 1 | i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 = 0;
            for (i3 = c2.charCodeAt(0), n2 = 0; n2 < 16; n2++)
              p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
          }
          0 == --u2 && (u2 = Math.pow(2, d2), d2++), delete _2[c2];
        } else
          for (i3 = h3[c2], n2 = 0; n2 < d2; n2++)
            p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
        0 == --u2 && (u2 = Math.pow(2, d2), d2++);
      }
      for (i3 = 2, n2 = 0; n2 < d2; n2++)
        p2 = p2 << 1 | 1 & i3, f4 == t3 - 1 ? (f4 = 0, g2.push(r3(p2)), p2 = 0) : f4++, i3 >>= 1;
      for (; ; ) {
        if (p2 <<= 1, f4 == t3 - 1) {
          g2.push(r3(p2));
          break;
        }
        f4++;
      }
      return g2.join("");
    }, decompress: function(e3) {
      return null == e3 ? "" : "" == e3 ? null : F2._decompress(e3.length, 32768, function(t3) {
        return e3.charCodeAt(t3);
      });
    }, _decompress: function(e3, t3, r3) {
      var n2, i3, o2, s3, a2, c2, u2, l2 = [], d2 = [], p2 = { val: r3(0), position: t3, index: 1 }, f4 = 4, h3 = 4, _2 = 3, g2 = "";
      for (n2 = 0; n2 < 3; n2 += 1)
        l2[n2] = n2;
      for (o2 = 0, a2 = Math.pow(2, 2), c2 = 1; c2 != a2; )
        s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
      switch (o2) {
        case 0:
          for (o2 = 0, a2 = Math.pow(2, 8), c2 = 1; c2 != a2; )
            s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
          u2 = y(o2);
          break;
        case 1:
          for (o2 = 0, a2 = Math.pow(2, 16), c2 = 1; c2 != a2; )
            s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
          u2 = y(o2);
          break;
        case 2:
          return "";
      }
      for (l2[3] = u2, i3 = u2, d2.push(u2); ; ) {
        if (p2.index > e3)
          return "";
        for (o2 = 0, a2 = Math.pow(2, _2), c2 = 1; c2 != a2; )
          s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
        switch (u2 = o2) {
          case 0:
            for (o2 = 0, a2 = Math.pow(2, 8), c2 = 1; c2 != a2; )
              s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
            l2[h3++] = y(o2), u2 = h3 - 1, f4--;
            break;
          case 1:
            for (o2 = 0, a2 = Math.pow(2, 16), c2 = 1; c2 != a2; )
              s3 = p2.val & p2.position, p2.position >>= 1, 0 == p2.position && (p2.position = t3, p2.val = r3(p2.index++)), o2 |= (s3 > 0 ? 1 : 0) * c2, c2 <<= 1;
            l2[h3++] = y(o2), u2 = h3 - 1, f4--;
            break;
          case 2:
            return d2.join("");
        }
        if (0 == f4 && (f4 = Math.pow(2, _2), _2++), l2[u2])
          g2 = l2[u2];
        else {
          if (u2 !== h3)
            return null;
          g2 = i3 + i3.charAt(0);
        }
        d2.push(g2), l2[h3++] = i3 + g2.charAt(0), i3 = g2, 0 == --f4 && (f4 = Math.pow(2, _2), _2++);
      }
    } };
    var S2 = { DEBUG: false, LIB_VERSION: "1.57.2" };
    var P = Array.prototype;
    var I = Object.prototype;
    var E = I.toString;
    var O = I.hasOwnProperty;
    var x2 = "undefined" != typeof window ? window : {};
    var A2 = x2.navigator || { userAgent: "" };
    var C = x2.document || {};
    var T = A2.userAgent;
    var M = ["localhost", "127.0.0.1"];
    var $ = P.forEach;
    var R = P.indexOf;
    var j = Array.isArray;
    var q = {};
    var D = { log: function() {
      if (S2.DEBUG && !Q(window.console) && window.console) {
        for (var e3 = ("__rrweb_original__" in window.console.log) ? window.console.log.__rrweb_original__ : window.console.log, t3 = arguments.length, r3 = new Array(t3), n2 = 0; n2 < t3; n2++)
          r3[n2] = arguments[n2];
        try {
          e3.apply(window.console, r3);
        } catch (t4) {
          B(r3, function(t5) {
            e3(t5);
          });
        }
      }
    }, error: function() {
      if (S2.DEBUG && !Q(window.console) && window.console) {
        for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
          t3[r3] = arguments[r3];
        var n2 = ["PostHog error:"].concat(t3), i3 = "__rrweb_original__" in window.console.error ? window.console.error.__rrweb_original__ : window.console.error;
        try {
          i3.apply(window.console, n2);
        } catch (e4) {
          B(n2, function(e5) {
            i3(e5);
          });
        }
      }
    }, critical: function() {
      if (!Q(window.console) && window.console) {
        for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
          t3[r3] = arguments[r3];
        var n2 = ["PostHog error:"].concat(t3), i3 = "__rrweb_original__" in window.console.error ? window.console.error.__rrweb_original__ : window.console.error;
        try {
          i3.apply(window.console, n2);
        } catch (e4) {
          B(n2, function(e5) {
            i3(e5);
          });
        }
      }
    } };
    var N = function(e3) {
      return e3.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    };
    function L(e3, t3, r3) {
      if (null != e3) {
        if ($ && Array.isArray(e3) && e3.forEach === $)
          e3.forEach(t3, r3);
        else if ("length" in e3 && e3.length === +e3.length) {
          for (var n2 = 0, i3 = e3.length; n2 < i3; n2++)
            if (n2 in e3 && t3.call(r3, e3[n2], n2) === q)
              return;
        } else
          for (var o2 in e3)
            if (O.call(e3, o2) && t3.call(r3, e3[o2], o2) === q)
              return;
      }
    }
    function B(e3, t3, r3) {
      if (Array.isArray(e3)) {
        if ($ && e3.forEach === $)
          e3.forEach(t3, r3);
        else if ("length" in e3 && e3.length === +e3.length) {
          for (var n2 = 0, i3 = e3.length; n2 < i3; n2++)
            if (n2 in e3 && t3.call(r3, e3[n2], n2) === q)
              return;
        }
      }
    }
    var H = function(e3) {
      for (var t3 = arguments.length, r3 = new Array(t3 > 1 ? t3 - 1 : 0), n2 = 1; n2 < t3; n2++)
        r3[n2 - 1] = arguments[n2];
      return B(r3, function(t4) {
        for (var r4 in t4)
          void 0 !== t4[r4] && (e3[r4] = t4[r4]);
      }), e3;
    };
    var U = j || function(e3) {
      return "[object Array]" === E.call(e3);
    };
    var V = function(e3) {
      try {
        return /^\s*\bfunction\b/.test(e3);
      } catch (e4) {
        return false;
      }
    };
    function W(e3, t3) {
      return -1 !== e3.indexOf(t3);
    }
    var G = function(e3) {
      return e3 === Object(e3) && !U(e3);
    };
    var Q = function(e3) {
      return void 0 === e3;
    };
    var z2 = function(e3) {
      return "[object String]" == E.call(e3);
    };
    var J = function(e3) {
      return "[object Number]" == E.call(e3);
    };
    var Z2 = function e3(t3) {
      return L(t3, function(r3, n2) {
        !function(e4) {
          return "[object Date]" == E.call(e4);
        }(r3) ? G(r3) && (t3[n2] = e3(r3)) : t3[n2] = X(r3);
      }), t3;
    };
    var X = function(e3) {
      function t3(e4) {
        return e4 < 10 ? "0" + e4 : e4;
      }
      return e3.getUTCFullYear() + "-" + t3(e3.getUTCMonth() + 1) + "-" + t3(e3.getUTCDate()) + "T" + t3(e3.getUTCHours()) + ":" + t3(e3.getUTCMinutes()) + ":" + t3(e3.getUTCSeconds());
    };
    var Y = function(e3) {
      return function() {
        try {
          for (var t3 = arguments.length, r3 = new Array(t3), n2 = 0; n2 < t3; n2++)
            r3[n2] = arguments[n2];
          return e3.apply(this, r3);
        } catch (e4) {
          D.critical("Implementation error. Please turn on debug and contact support@posthog.com."), D.critical(e4);
        }
      };
    };
    var K = function(e3) {
      var t3 = {};
      return L(e3, function(e4, r3) {
        z2(e4) && e4.length > 0 && (t3[r3] = e4);
      }), t3;
    };
    var ee = ["$performance_raw"];
    function te(e3, t3) {
      return r3 = e3, n2 = function(e4, r4) {
        return r4 && ee.indexOf(r4) > -1 ? e4 : "string" == typeof e4 && null !== t3 ? e4.slice(0, t3) : e4;
      }, i3 = /* @__PURE__ */ new Set(), function e4(t4, r4) {
        return t4 !== Object(t4) ? n2 ? n2(t4, r4) : t4 : i3.has(t4) ? void 0 : (i3.add(t4), U(t4) ? (o2 = [], B(t4, function(t5) {
          o2.push(e4(t5));
        })) : (o2 = {}, L(t4, function(t5, r5) {
          i3.has(t5) || (o2[r5] = e4(t5, r5));
        })), o2);
        var o2;
      }(r3);
      var r3, n2, i3;
    }
    function re(e3) {
      var t3, r3, n2, i3, o2, s3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a2 = 0, c2 = 0, u2 = "", l2 = [];
      if (!e3)
        return e3;
      e3 = ie(e3);
      do {
        t3 = (o2 = e3.charCodeAt(a2++) << 16 | e3.charCodeAt(a2++) << 8 | e3.charCodeAt(a2++)) >> 18 & 63, r3 = o2 >> 12 & 63, n2 = o2 >> 6 & 63, i3 = 63 & o2, l2[c2++] = s3.charAt(t3) + s3.charAt(r3) + s3.charAt(n2) + s3.charAt(i3);
      } while (a2 < e3.length);
      switch (u2 = l2.join(""), e3.length % 3) {
        case 1:
          u2 = u2.slice(0, -2) + "==";
          break;
        case 2:
          u2 = u2.slice(0, -1) + "=";
      }
      return u2;
    }
    var ne;
    var ie = function(e3) {
      var t3, r3, n2, i3, o2 = "";
      for (t3 = r3 = 0, n2 = (e3 = (e3 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, i3 = 0; i3 < n2; i3++) {
        var s3 = e3.charCodeAt(i3), a2 = null;
        s3 < 128 ? r3++ : a2 = s3 > 127 && s3 < 2048 ? String.fromCharCode(s3 >> 6 | 192, 63 & s3 | 128) : String.fromCharCode(s3 >> 12 | 224, s3 >> 6 & 63 | 128, 63 & s3 | 128), null !== a2 && (r3 > t3 && (o2 += e3.substring(t3, r3)), o2 += a2, t3 = r3 = i3 + 1);
      }
      return r3 > t3 && (o2 += e3.substring(t3, e3.length)), o2;
    };
    var oe = (ne = function() {
      for (var e3 = (/* @__PURE__ */ new Date()).valueOf(), t3 = 0; e3 == (/* @__PURE__ */ new Date()).valueOf(); )
        t3++;
      return e3.toString(16) + t3.toString(16);
    }, function() {
      var e3 = "undefined" != typeof window ? (window.screen.height * window.screen.width).toString(16) : "0";
      return ne() + "-" + Math.random().toString(16).replace(".", "") + "-" + function() {
        var e4, t3, r3 = T, n2 = 0, i3 = [];
        function o2(e5, t4) {
          var r4, n3 = 0;
          for (r4 = 0; r4 < t4.length; r4++)
            n3 |= i3[r4] << 8 * r4;
          return e5 ^ n3;
        }
        for (e4 = 0; e4 < r3.length; e4++)
          t3 = r3.charCodeAt(e4), i3.unshift(255 & t3), i3.length >= 4 && (n2 = o2(n2, i3), i3 = []);
        return i3.length > 0 && (n2 = o2(n2, i3)), n2.toString(16);
      }() + "-" + e3 + "-" + ne();
    });
    var se = function(e3) {
      return !!/(google web preview|baiduspider|yandexbot|bingbot|googlebot|yahoo! slurp|ahrefsbot|facebookexternalhit|facebookcatalog|applebot|semrushbot|duckduckbot|twitterbot|rogerbot|linkedinbot|mj12bot|sitebulb|bot.htm|bot.php|hubspot|crawler)/i.test(e3);
    };
    var ae = function(e3, t3) {
      var r3 = t3.replace(/[[]/, "\\[").replace(/[\]]/, "\\]"), n2 = new RegExp("[\\?&]" + r3 + "=([^&#]*)").exec(e3);
      if (null === n2 || n2 && "string" != typeof n2[1] && n2[1].length)
        return "";
      var i3 = n2[1];
      try {
        i3 = decodeURIComponent(i3);
      } catch (e4) {
        D.error("Skipping decoding for malformed query param: " + i3);
      }
      return i3.replace(/\+/g, " ");
    };
    var ce = function(e3, t3) {
      var r3 = e3.match(new RegExp(t3 + "=([^&]*)"));
      return r3 ? r3[1] : null;
    };
    var ue = function() {
      function e3(t3) {
        return t3 && (t3.preventDefault = e3.preventDefault, t3.stopPropagation = e3.stopPropagation), t3;
      }
      return e3.preventDefault = function() {
        this.returnValue = false;
      }, e3.stopPropagation = function() {
        this.cancelBubble = true;
      }, function(t3, r3, n2, i3, o2) {
        if (t3)
          if (t3.addEventListener && !i3)
            t3.addEventListener(r3, n2, !!o2);
          else {
            var s3 = "on" + r3, a2 = t3[s3];
            t3[s3] = function(t4, r4, n3) {
              return function(i4) {
                if (i4 = i4 || e3(window.event)) {
                  var o3, s4 = true;
                  V(n3) && (o3 = n3(i4));
                  var a3 = r4.call(t4, i4);
                  return false !== o3 && false !== a3 || (s4 = false), s4;
                }
              };
            }(t3, n2, a2);
          }
        else
          D.error("No valid element provided to register_event");
      };
    }();
    function le(e3, t3) {
      var r3 = function() {
        var r4 = C.createElement("script");
        r4.type = "text/javascript", r4.src = e3, r4.onload = function(e4) {
          return t3(void 0, e4);
        }, r4.onerror = function(e4) {
          return t3(e4);
        };
        var n2, i3 = C.querySelectorAll("body > script");
        i3.length > 0 ? null === (n2 = i3[0].parentNode) || void 0 === n2 || n2.insertBefore(r4, i3[0]) : C.body.appendChild(r4);
      };
      C.body ? r3() : C.addEventListener("DOMContentLoaded", r3);
    }
    var de = { campaignParams: function(e3) {
      var t3 = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "fbclid", "msclkid"].concat(e3 || []), r3 = {};
      return L(t3, function(e4) {
        var t4 = ae(C.URL, e4);
        t4.length && (r3[e4] = t4);
      }), r3;
    }, searchEngine: function() {
      var e3 = C.referrer;
      return e3 ? 0 === e3.search("https?://(.*)google.([^/?]*)") ? "google" : 0 === e3.search("https?://(.*)bing.com") ? "bing" : 0 === e3.search("https?://(.*)yahoo.com") ? "yahoo" : 0 === e3.search("https?://(.*)duckduckgo.com") ? "duckduckgo" : null : null;
    }, searchInfo: function() {
      var e3 = de.searchEngine(), t3 = "yahoo" != e3 ? "q" : "p", r3 = {};
      if (null !== e3) {
        r3.$search_engine = e3;
        var n2 = ae(C.referrer, t3);
        n2.length && (r3.ph_keyword = n2);
      }
      return r3;
    }, browser: function(e3, t3, r3) {
      return t3 = t3 || "", r3 || W(e3, " OPR/") ? W(e3, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(e3) ? "BlackBerry" : W(e3, "IEMobile") || W(e3, "WPDesktop") ? "Internet Explorer Mobile" : W(e3, "SamsungBrowser/") ? "Samsung Internet" : W(e3, "Edge") || W(e3, "Edg/") ? "Microsoft Edge" : W(e3, "FBIOS") ? "Facebook Mobile" : W(e3, "Chrome") ? "Chrome" : W(e3, "CriOS") ? "Chrome iOS" : W(e3, "UCWEB") || W(e3, "UCBrowser") ? "UC Browser" : W(e3, "FxiOS") ? "Firefox iOS" : W(t3, "Apple") ? W(e3, "Mobile") ? "Mobile Safari" : "Safari" : W(e3, "Android") ? "Android Mobile" : W(e3, "Konqueror") ? "Konqueror" : W(e3, "Firefox") ? "Firefox" : W(e3, "MSIE") || W(e3, "Trident/") ? "Internet Explorer" : W(e3, "Gecko") ? "Mozilla" : "";
    }, browserVersion: function(e3, t3, r3) {
      var n2 = { "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/, "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/, Chrome: /Chrome\/(\d+(\.\d+)?)/, "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/, "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/, Safari: /Version\/(\d+(\.\d+)?)/, "Mobile Safari": /Version\/(\d+(\.\d+)?)/, Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/, Firefox: /Firefox\/(\d+(\.\d+)?)/, "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/, Konqueror: /Konqueror:(\d+(\.\d+)?)/, BlackBerry: /BlackBerry (\d+(\.\d+)?)/, "Android Mobile": /android\s(\d+(\.\d+)?)/, "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/, "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/, Mozilla: /rv:(\d+(\.\d+)?)/ }[de.browser(e3, t3, r3)];
      if (void 0 === n2)
        return null;
      var i3 = e3.match(n2);
      return i3 ? parseFloat(i3[i3.length - 2]) : null;
    }, browserLanguage: function() {
      return A2.language || A2.userLanguage;
    }, os: function(e3) {
      if (/Windows/i.test(e3)) {
        if (/Phone/.test(e3) || /WPDesktop/.test(e3))
          return { os_name: "Windows Phone", os_version: "" };
        var t3 = /Windows NT ([0-9.]+)/i.exec(e3);
        return t3 && t3[1] ? { os_name: "Windows", os_version: t3[1] } : { os_name: "Windows", os_version: "" };
      }
      if (/(iPhone|iPad|iPod)/.test(e3)) {
        var r3 = /OS (\d+)_(\d+)_?(\d+)?/i.exec(e3);
        return r3 && r3[1] ? { os_name: "iOS", os_version: [r3[1], r3[2], r3[3] || "0"].join(".") } : { os_name: "iOS", os_version: "" };
      }
      if (/Android/.test(e3)) {
        var n2 = /Android (\d+)\.(\d+)\.?(\d+)?/i.exec(e3);
        return n2 && n2[1] ? { os_name: "Android", os_version: [n2[1], n2[2], n2[3] || "0"].join(".") } : { os_name: "Android", os_version: "" };
      }
      if (/(BlackBerry|PlayBook|BB10)/i.test(e3))
        return { os_name: "BlackBerry", os_version: "" };
      if (/Mac/i.test(e3)) {
        var i3 = /Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i.exec(e3);
        return i3 && i3[1] ? { os_name: "Mac OS X", os_version: [i3[1], i3[2], i3[3] || "0"].join(".") } : { os_name: "Mac OS X", os_version: "" };
      }
      return /Linux/.test(e3) ? { os_name: "Linux", os_version: "" } : /CrOS/.test(e3) ? { os_name: "Chrome OS", os_version: "" } : { os_name: "", os_version: "" };
    }, device: function(e3) {
      return /Windows Phone/i.test(e3) || /WPDesktop/.test(e3) ? "Windows Phone" : /iPad/.test(e3) ? "iPad" : /iPod/.test(e3) ? "iPod Touch" : /iPhone/.test(e3) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(e3) ? "BlackBerry" : /Android/.test(e3) && !/Mobile/.test(e3) ? "Android Tablet" : /Android/.test(e3) ? "Android" : "";
    }, deviceType: function(e3) {
      var t3 = this.device(e3);
      return "iPad" === t3 || "Android Tablet" === t3 ? "Tablet" : t3 ? "Mobile" : "Desktop";
    }, referrer: function() {
      return C.referrer || "$direct";
    }, referringDomain: function() {
      if (!C.referrer)
        return "$direct";
      var e3 = C.createElement("a");
      return e3.href = C.referrer, e3.host;
    }, properties: function() {
      var e3 = de.os(T), t3 = e3.os_name, r3 = e3.os_version;
      return H(K({ $os: t3, $os_version: r3, $browser: de.browser(T, A2.vendor, x2.opera), $device: de.device(T), $device_type: de.deviceType(T) }), { $current_url: null == x2 ? void 0 : x2.location.href, $host: null == x2 ? void 0 : x2.location.host, $pathname: null == x2 ? void 0 : x2.location.pathname, $browser_version: de.browserVersion(T, A2.vendor, x2.opera), $browser_language: de.browserLanguage(), $screen_height: null == x2 ? void 0 : x2.screen.height, $screen_width: null == x2 ? void 0 : x2.screen.width, $viewport_height: null == x2 ? void 0 : x2.innerHeight, $viewport_width: null == x2 ? void 0 : x2.innerWidth, $lib: "web", $lib_version: S2.LIB_VERSION, $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10), $time: (Date.now = Date.now || function() {
        return +/* @__PURE__ */ new Date();
      }, Date.now() / 1e3) });
    }, people_properties: function() {
      var e3 = de.os(T), t3 = e3.os_name, r3 = e3.os_version;
      return H(K({ $os: t3, $os_version: r3, $browser: de.browser(T, A2.vendor, x2.opera) }), { $browser_version: de.browserVersion(T, A2.vendor, x2.opera) });
    } };
    function pe(e3) {
      switch (r2(e3.className)) {
        case "string":
          return e3.className;
        case "object":
          return ("baseVal" in e3.className ? e3.className.baseVal : null) || e3.getAttribute("class") || "";
        default:
          return "";
      }
    }
    function fe(e3) {
      var t3 = "";
      return me(e3) && !be(e3) && e3.childNodes && e3.childNodes.length && L(e3.childNodes, function(e4) {
        ge(e4) && e4.textContent && (t3 += N(e4.textContent).split(/(\s+)/).filter(we).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255));
      }), N(t3);
    }
    function he(e3) {
      return !!e3 && 1 === e3.nodeType;
    }
    function _e(e3, t3) {
      return !!e3 && !!e3.tagName && e3.tagName.toLowerCase() === t3.toLowerCase();
    }
    function ge(e3) {
      return !!e3 && 3 === e3.nodeType;
    }
    function ve(e3) {
      return !!e3 && 11 === e3.nodeType;
    }
    var ye = ["a", "button", "form", "input", "select", "textarea", "label"];
    function me(e3) {
      for (var t3 = e3; t3.parentNode && !_e(t3, "body"); t3 = t3.parentNode) {
        var r3 = pe(t3).split(" ");
        if (W(r3, "ph-sensitive") || W(r3, "ph-no-capture"))
          return false;
      }
      if (W(pe(e3).split(" "), "ph-include"))
        return true;
      var n2 = e3.type || "";
      if ("string" == typeof n2)
        switch (n2.toLowerCase()) {
          case "hidden":
          case "password":
            return false;
        }
      var i3 = e3.name || e3.id || "";
      if ("string" == typeof i3) {
        if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(i3.replace(/[^a-zA-Z0-9]/g, "")))
          return false;
      }
      return true;
    }
    function be(e3) {
      return !!(_e(e3, "input") && !["button", "checkbox", "submit", "reset"].includes(e3.type) || _e(e3, "select") || _e(e3, "textarea") || "true" === e3.getAttribute("contenteditable"));
    }
    function we(e3) {
      if (null === e3 || Q(e3))
        return false;
      if ("string" == typeof e3) {
        e3 = N(e3);
        if (/^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/.test((e3 || "").replace(/[- ]/g, "")))
          return false;
        if (/(^\d{3}-?\d{2}-?\d{4}$)/.test(e3))
          return false;
      }
      return true;
    }
    function ke(e3) {
      var t3 = fe(e3);
      return we(t3 = "".concat(t3, " ").concat(Fe(e3)).trim()) ? t3 : "";
    }
    function Fe(e3) {
      var t3 = "";
      return e3 && e3.childNodes && e3.childNodes.length && L(e3.childNodes, function(e4) {
        var r3;
        if (e4 && "span" === (null === (r3 = e4.tagName) || void 0 === r3 ? void 0 : r3.toLowerCase()))
          try {
            var n2 = fe(e4);
            t3 = "".concat(t3, " ").concat(n2).trim(), e4.childNodes && e4.childNodes.length && (t3 = "".concat(t3, " ").concat(Fe(e4)).trim());
          } catch (e5) {
            console.error(e5);
          }
      }), t3;
    }
    var Se = function() {
      function e3(t3) {
        n(this, e3), this.clicks = [], this.enabled = t3;
      }
      return o(e3, [{ key: "isRageClick", value: function(e4, t3, r3) {
        if (!this.enabled)
          return false;
        var n2 = this.clicks[this.clicks.length - 1];
        if (n2 && Math.abs(e4 - n2.x) + Math.abs(t3 - n2.y) < 30 && r3 - n2.timestamp < 1e3) {
          if (this.clicks.push({ x: e4, y: t3, timestamp: r3 }), 3 === this.clicks.length)
            return true;
        } else
          this.clicks = [{ x: e4, y: t3, timestamp: r3 }];
        return false;
      } }]), e3;
    }();
    var Pe = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
    var Ie = { is_supported: function() {
      return true;
    }, error: function(e3) {
      D.error("cookieStore error: " + e3);
    }, get: function(e3) {
      try {
        for (var t3 = e3 + "=", r3 = document.cookie.split(";"), n2 = 0; n2 < r3.length; n2++) {
          for (var i3 = r3[n2]; " " == i3.charAt(0); )
            i3 = i3.substring(1, i3.length);
          if (0 === i3.indexOf(t3))
            return decodeURIComponent(i3.substring(t3.length, i3.length));
        }
      } catch (e4) {
      }
      return null;
    }, parse: function(e3) {
      var t3;
      try {
        t3 = JSON.parse(Ie.get(e3)) || {};
      } catch (e4) {
      }
      return t3;
    }, set: function(e3, t3, r3, n2, i3) {
      try {
        var o2 = "", s3 = "", a2 = "";
        if (n2) {
          var c2 = document.location.hostname.match(Pe), u2 = c2 ? c2[0] : "";
          o2 = u2 ? "; domain=." + u2 : "";
        }
        if (r3) {
          var l2 = /* @__PURE__ */ new Date();
          l2.setTime(l2.getTime() + 24 * r3 * 60 * 60 * 1e3), s3 = "; expires=" + l2.toUTCString();
        }
        i3 && (a2 = "; secure");
        var d2 = e3 + "=" + encodeURIComponent(JSON.stringify(t3)) + s3 + "; SameSite=Lax; path=/" + o2 + a2;
        return document.cookie = d2, d2;
      } catch (e4) {
        return;
      }
    }, remove: function(e3, t3) {
      try {
        Ie.set(e3, "", -1, t3);
      } catch (e4) {
        return;
      }
    } };
    var Ee = null;
    var Oe = { is_supported: function() {
      if (null !== Ee)
        return Ee;
      var e3 = true;
      if ("undefined" != typeof window)
        try {
          var t3 = "__mplssupport__";
          Oe.set(t3, "xyz"), '"xyz"' !== Oe.get(t3) && (e3 = false), Oe.remove(t3);
        } catch (t4) {
          e3 = false;
        }
      else
        e3 = false;
      return e3 || D.error("localStorage unsupported; falling back to cookie store"), Ee = e3, e3;
    }, error: function(e3) {
      D.error("localStorage error: " + e3);
    }, get: function(e3) {
      try {
        return window.localStorage.getItem(e3);
      } catch (e4) {
        Oe.error(e4);
      }
      return null;
    }, parse: function(e3) {
      try {
        return JSON.parse(Oe.get(e3)) || {};
      } catch (e4) {
      }
      return null;
    }, set: function(e3, t3) {
      try {
        window.localStorage.setItem(e3, JSON.stringify(t3));
      } catch (e4) {
        Oe.error(e4);
      }
    }, remove: function(e3) {
      try {
        window.localStorage.removeItem(e3);
      } catch (e4) {
        Oe.error(e4);
      }
    } };
    var xe = t2(t2({}, Oe), {}, { parse: function(e3) {
      try {
        var t3 = {};
        try {
          (t3 = Ie.parse(e3) || {}).distinct_id && Ie.set(e3, { distinct_id: t3.distinct_id });
        } catch (e4) {
        }
        var r3 = H(t3, JSON.parse(Oe.get(e3) || "{}"));
        return Oe.set(e3, r3), r3;
      } catch (e4) {
      }
      return null;
    }, set: function(e3, t3, r3, n2, i3) {
      try {
        Oe.set(e3, t3), t3.distinct_id && Ie.set(e3, { distinct_id: t3.distinct_id }, r3, n2, i3);
      } catch (e4) {
        Oe.error(e4);
      }
    }, remove: function(e3, t3) {
      try {
        window.localStorage.removeItem(e3), Ie.remove(e3, t3);
      } catch (e4) {
        Oe.error(e4);
      }
    } });
    var Ae = {};
    var Ce = { is_supported: function() {
      return true;
    }, error: function(e3) {
      D.error("memoryStorage error: " + e3);
    }, get: function(e3) {
      return Ae[e3] || null;
    }, parse: function(e3) {
      return Ae[e3] || null;
    }, set: function(e3, t3) {
      Ae[e3] = t3;
    }, remove: function(e3) {
      delete Ae[e3];
    } };
    var Te = null;
    var Me = { is_supported: function() {
      if (null !== Te)
        return Te;
      if (Te = true, "undefined" != typeof window)
        try {
          var e3 = "__support__";
          Me.set(e3, "xyz"), '"xyz"' !== Me.get(e3) && (Te = false), Me.remove(e3);
        } catch (e4) {
          Te = false;
        }
      else
        Te = false;
      return Te;
    }, error: function(e3) {
      S2.DEBUG && D.error("sessionStorage error: ", e3);
    }, get: function(e3) {
      try {
        return window.sessionStorage.getItem(e3);
      } catch (e4) {
        Me.error(e4);
      }
      return null;
    }, parse: function(e3) {
      try {
        return JSON.parse(Me.get(e3)) || null;
      } catch (e4) {
      }
      return null;
    }, set: function(e3, t3) {
      try {
        window.sessionStorage.setItem(e3, JSON.stringify(t3));
      } catch (e4) {
        Me.error(e4);
      }
    }, remove: function(e3) {
      try {
        window.sessionStorage.removeItem(e3);
      } catch (e4) {
        Me.error(e4);
      }
    } };
    var $e = "$people_distinct_id";
    var Re = "__alias";
    var je = "__timers";
    var qe = "$autocapture_disabled_server_side";
    var De = "$session_recording_enabled_server_side";
    var Ne = "$console_log_recording_enabled_server_side";
    var Le = "$session_recording_recorder_version_server_side";
    var Be = "$sesid";
    var He = "$enabled_feature_flags";
    var Ue = "$early_access_features";
    var Ve = "$stored_person_properties";
    var We = "$stored_group_properties";
    var Ge = "$user_state";
    var Qe = [$e, Re, "__cmpns", je, De, Be, He, Ge, Ue, We, Ve];
    var ze = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
    var Je = function() {
      function e3(t3) {
        n(this, e3);
        var r3 = "";
        t3.token && (r3 = t3.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), this.props = {}, this.campaign_params_saved = false, this.custom_campaign_params = t3.custom_campaign_params || [], t3.persistence_name ? this.name = "ph_" + t3.persistence_name : this.name = "ph_" + r3 + "_posthog", -1 === ze.indexOf(t3.persistence.toLowerCase()) && (D.critical("Unknown persistence type " + t3.persistence + "; falling back to cookie"), t3.persistence = "cookie");
        var i3 = t3.persistence.toLowerCase();
        "localstorage" === i3 && Oe.is_supported() ? this.storage = Oe : "localstorage+cookie" === i3 && xe.is_supported() ? this.storage = xe : "sessionstorage" === i3 && Me.is_supported() ? this.storage = Me : this.storage = "memory" === i3 ? Ce : Ie, this.user_state = "anonymous", this.load(), this.update_config(t3), this.save();
      }
      return o(e3, [{ key: "properties", value: function() {
        var e4 = {};
        return L(this.props, function(t3, n2) {
          if (n2 === He && "object" === r2(t3))
            for (var i3 = Object.keys(t3), o2 = 0; o2 < i3.length; o2++)
              e4["$feature/".concat(i3[o2])] = t3[i3[o2]];
          else
            a2 = n2, c2 = false, (null === (s3 = Qe) ? c2 : R && s3.indexOf === R ? -1 != s3.indexOf(a2) : (L(s3, function(e5) {
              if (c2 || (c2 = e5 === a2))
                return q;
            }), c2)) || (e4[n2] = t3);
          var s3, a2, c2;
        }), e4;
      } }, { key: "load", value: function() {
        if (!this.disabled) {
          var e4 = this.storage.parse(this.name);
          e4 && (this.props = H({}, e4));
        }
      } }, { key: "save", value: function() {
        this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure);
      } }, { key: "remove", value: function() {
        this.storage.remove(this.name, false), this.storage.remove(this.name, true);
      } }, { key: "clear", value: function() {
        this.remove(), this.props = {};
      } }, { key: "register_once", value: function(e4, t3, r3) {
        var n2 = this;
        if (G(e4)) {
          void 0 === t3 && (t3 = "None"), this.expire_days = void 0 === r3 ? this.default_expiry : r3;
          var i3 = false;
          if (L(e4, function(e5, r4) {
            n2.props.hasOwnProperty(r4) && n2.props[r4] !== t3 || (n2.props[r4] = e5, i3 = true);
          }), i3)
            return this.save(), true;
        }
        return false;
      } }, { key: "register", value: function(e4, t3) {
        var r3 = this;
        if (G(e4)) {
          this.expire_days = void 0 === t3 ? this.default_expiry : t3;
          var n2 = false;
          if (L(e4, function(t4, i3) {
            e4.hasOwnProperty(i3) && r3.props[i3] !== t4 && (r3.props[i3] = t4, n2 = true);
          }), n2)
            return this.save(), true;
        }
        return false;
      } }, { key: "unregister", value: function(e4) {
        e4 in this.props && (delete this.props[e4], this.save());
      } }, { key: "update_campaign_params", value: function() {
        this.campaign_params_saved || (this.register(de.campaignParams(this.custom_campaign_params)), this.campaign_params_saved = true);
      } }, { key: "update_search_keyword", value: function() {
        this.register(de.searchInfo());
      } }, { key: "update_referrer_info", value: function() {
        this.register({ $referrer: this.props.$referrer || de.referrer(), $referring_domain: this.props.$referring_domain || de.referringDomain() });
      } }, { key: "get_referrer_info", value: function() {
        return K({ $referrer: this.props.$referrer, $referring_domain: this.props.$referring_domain });
      } }, { key: "safe_merge", value: function(e4) {
        return L(this.props, function(t3, r3) {
          r3 in e4 || (e4[r3] = t3);
        }), e4;
      } }, { key: "update_config", value: function(e4) {
        this.default_expiry = this.expire_days = e4.cookie_expiration, this.set_disabled(e4.disable_persistence), this.set_cross_subdomain(e4.cross_subdomain_cookie), this.set_secure(e4.secure_cookie);
      } }, { key: "set_disabled", value: function(e4) {
        this.disabled = e4, this.disabled ? this.remove() : this.save();
      } }, { key: "set_cross_subdomain", value: function(e4) {
        e4 !== this.cross_subdomain && (this.cross_subdomain = e4, this.remove(), this.save());
      } }, { key: "get_cross_subdomain", value: function() {
        return !!this.cross_subdomain;
      } }, { key: "set_secure", value: function(e4) {
        e4 !== this.secure && (this.secure = e4, this.remove(), this.save());
      } }, { key: "set_event_timer", value: function(e4, t3) {
        var r3 = this.props[je] || {};
        r3[e4] = t3, this.props[je] = r3, this.save();
      } }, { key: "remove_event_timer", value: function(e4) {
        var t3 = (this.props[je] || {})[e4];
        return Q(t3) || (delete this.props[je][e4], this.save()), t3;
      } }, { key: "get_user_state", value: function() {
        return this.props[Ge] || "anonymous";
      } }, { key: "set_user_state", value: function(e4) {
        this.props[Ge] = e4, this.save();
      } }]), e3;
    }();
    var Ze = { _initializedTokens: [], _isAutocaptureEnabled: false, _setIsAutocaptureEnabled: function(e3) {
      var t3 = !!e3.get_property(qe), r3 = !!e3.get_config("autocapture");
      this._isAutocaptureEnabled = r3 && !t3;
    }, _previousElementSibling: function(e3) {
      if (e3.previousElementSibling)
        return e3.previousElementSibling;
      var t3 = e3;
      do {
        t3 = t3.previousSibling;
      } while (t3 && !he(t3));
      return t3;
    }, _getAugmentPropertiesFromElement: function(e3) {
      if (!me(e3))
        return {};
      var t3 = {};
      return L(e3.attributes, function(e4) {
        if (e4.name.startsWith("data-ph-capture-attribute")) {
          var r3 = e4.name.replace("data-ph-capture-attribute-", ""), n2 = e4.value;
          r3 && n2 && we(n2) && (t3[r3] = n2);
        }
      }), t3;
    }, _getPropertiesFromElement: function(e3, t3, r3) {
      var n2 = e3.tagName.toLowerCase(), i3 = { tag_name: n2 };
      ye.indexOf(n2) > -1 && !r3 && ("a" === n2.toLowerCase() || "button" === n2.toLowerCase() ? i3.$el_text = ke(e3) : i3.$el_text = fe(e3));
      var o2 = pe(e3);
      o2.length > 0 && (i3.classes = o2.split(" ").filter(function(e4) {
        return "" !== e4;
      })), L(e3.attributes, function(r4) {
        var n3;
        be(e3) && -1 === ["name", "id", "class"].indexOf(r4.name) || !t3 && we(r4.value) && ("string" != typeof (n3 = r4.name) || "_ngcontent" !== n3.substring(0, 10) && "_nghost" !== n3.substring(0, 7)) && (i3["attr__" + r4.name] = r4.value);
      });
      for (var s3 = 1, a2 = 1, c2 = e3; c2 = this._previousElementSibling(c2); )
        s3++, c2.tagName === e3.tagName && a2++;
      return i3.nth_child = s3, i3.nth_of_type = a2, i3;
    }, _getDefaultProperties: function(e3) {
      return { $event_type: e3, $ce_version: 1 };
    }, _extractCustomPropertyValue: function(e3) {
      var t3 = [];
      return L(document.querySelectorAll(e3.css_selector), function(e4) {
        var r3;
        ["input", "select"].indexOf(e4.tagName.toLowerCase()) > -1 ? r3 = e4.value : e4.textContent && (r3 = e4.textContent), we(r3) && t3.push(r3);
      }), t3.join(", ");
    }, _getCustomProperties: function(e3) {
      var t3 = this, r3 = {};
      return L(this._customProperties, function(n2) {
        L(n2.event_selectors, function(i3) {
          L(document.querySelectorAll(i3), function(i4) {
            W(e3, i4) && me(i4) && (r3[n2.name] = t3._extractCustomPropertyValue(n2));
          });
        });
      }), r3;
    }, _getEventTarget: function(e3) {
      return void 0 === e3.target ? e3.srcElement || null : null !== (t3 = e3.target) && void 0 !== t3 && t3.shadowRoot ? e3.composedPath()[0] || null : e3.target || null;
      var t3;
    }, _captureEvent: function(e3, t3) {
      var r3, n2 = this, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "$autocapture", o2 = this._getEventTarget(e3);
      (ge(o2) && (o2 = o2.parentNode || null), "$autocapture" === i3 && "click" === e3.type && e3 instanceof MouseEvent) && (null !== (r3 = this.rageclicks) && void 0 !== r3 && r3.isRageClick(e3.clientX, e3.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._captureEvent(e3, t3, "$rageclick"));
      if (o2 && function(e4, t4) {
        var r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
        if (!e4 || _e(e4, "html") || !he(e4))
          return false;
        if (null != r4 && r4.url_allowlist) {
          var n3 = window.location.href, i4 = r4.url_allowlist;
          if (i4 && !i4.some(function(e5) {
            return n3.match(e5);
          }))
            return false;
        }
        if (null != r4 && r4.dom_event_allowlist) {
          var o3 = r4.dom_event_allowlist;
          if (o3 && !o3.some(function(e5) {
            return t4.type === e5;
          }))
            return false;
        }
        if (null != r4 && r4.element_allowlist) {
          var s4 = r4.element_allowlist;
          if (s4 && !s4.some(function(t5) {
            return e4.tagName.toLowerCase() === t5;
          }))
            return false;
        }
        if (null != r4 && r4.css_selector_allowlist) {
          var a3 = r4.css_selector_allowlist;
          if (a3 && !a3.some(function(t5) {
            return e4.matches(t5);
          }))
            return false;
        }
        for (var c3 = false, u3 = [e4], l3 = true, d3 = e4; d3.parentNode && !_e(d3, "body"); )
          if (ve(d3.parentNode))
            u3.push(d3.parentNode.host), d3 = d3.parentNode.host;
          else {
            if (!(l3 = d3.parentNode || false))
              break;
            if (ye.indexOf(l3.tagName.toLowerCase()) > -1)
              c3 = true;
            else {
              var p3 = window.getComputedStyle(l3);
              p3 && "pointer" === p3.getPropertyValue("cursor") && (c3 = true);
            }
            u3.push(l3), d3 = l3;
          }
        var f4 = window.getComputedStyle(e4);
        if (f4 && "pointer" === f4.getPropertyValue("cursor") && "click" === t4.type)
          return true;
        var h3 = e4.tagName.toLowerCase();
        switch (h3) {
          case "html":
            return false;
          case "form":
            return "submit" === t4.type;
          case "input":
          case "select":
          case "textarea":
            return "change" === t4.type || "click" === t4.type;
          default:
            return c3 ? "click" === t4.type : "click" === t4.type && (ye.indexOf(h3) > -1 || "true" === e4.getAttribute("contenteditable"));
        }
      }(o2, e3, this.config)) {
        for (var s3 = [o2], a2 = o2; a2.parentNode && !_e(a2, "body"); )
          ve(a2.parentNode) ? (s3.push(a2.parentNode.host), a2 = a2.parentNode.host) : (s3.push(a2.parentNode), a2 = a2.parentNode);
        var c2, u2 = [], l2 = {}, d2 = false;
        if (L(s3, function(e4) {
          var r4 = me(e4);
          "a" === e4.tagName.toLowerCase() && (c2 = e4.getAttribute("href"), c2 = r4 && we(c2) && c2), W(pe(e4).split(" "), "ph-no-capture") && (d2 = true), u2.push(n2._getPropertiesFromElement(e4, t3.get_config("mask_all_element_attributes"), t3.get_config("mask_all_text")));
          var i4 = n2._getAugmentPropertiesFromElement(e4);
          H(l2, i4);
        }), t3.get_config("mask_all_text") || ("a" === o2.tagName.toLowerCase() || "button" === o2.tagName.toLowerCase() ? u2[0].$el_text = ke(o2) : u2[0].$el_text = fe(o2)), c2 && (u2[0].attr__href = c2), d2)
          return false;
        var p2 = H(this._getDefaultProperties(e3.type), { $elements: u2 }, this._getCustomProperties(s3), l2);
        return t3.capture(i3, p2), true;
      }
    }, _navigate: function(e3) {
      window.location.href = e3;
    }, _addDomEventHandlers: function(e3) {
      var t3 = this, r3 = function(r4) {
        r4 = r4 || window.event, t3._captureEvent(r4, e3);
      };
      ue(document, "submit", r3, false, true), ue(document, "change", r3, false, true), ue(document, "click", r3, false, true);
    }, _customProperties: [], rageclicks: null, config: void 0, init: function(e3) {
      var t3;
      "boolean" != typeof e3.__autocapture && (this.config = e3.__autocapture), null !== (t3 = this.config) && void 0 !== t3 && t3.url_allowlist && (this.config.url_allowlist = this.config.url_allowlist.map(function(e4) {
        return new RegExp(e4);
      })), this.rageclicks = new Se(e3.get_config("rageclick"));
    }, afterDecideResponse: function(e3, t3) {
      this._setIsAutocaptureEnabled(t3);
      var r3 = t3.get_config("token");
      this._initializedTokens.indexOf(r3) > -1 ? D.log('autocapture already initialized for token "' + r3 + '"') : (t3.persistence && t3.persistence.register(s2({}, qe, !!e3.autocapture_opt_out)), this._initializedTokens.push(r3), e3 && e3.config && e3.config.enable_collect_everything && this._isAutocaptureEnabled ? (e3.custom_properties && (this._customProperties = e3.custom_properties), this._addDomEventHandlers(t3)) : t3.__autocapture = false);
    }, enabledForProject: function(e3, t3, r3) {
      if (!e3)
        return true;
      t3 = Q(t3) ? 10 : t3, r3 = Q(r3) ? 10 : r3;
      for (var n2 = 0, i3 = 0; i3 < e3.length; i3++)
        n2 += e3.charCodeAt(i3);
      return n2 % t3 < r3;
    }, isBrowserSupported: function() {
      return V(document.querySelectorAll);
    } };
    !function(e3) {
      for (var t3 in e3)
        "function" == typeof e3[t3] && (e3[t3] = e3[t3].bind(e3));
    }(Ze), function(e3) {
      for (var t3 in e3)
        "function" == typeof e3[t3] && (e3[t3] = Y(e3[t3]));
    }(Ze);
    var Xe = "__ph_opt_in_out_";
    function Ye(e3, t3) {
      st(true, e3, t3);
    }
    function Ke(e3, t3) {
      st(false, e3, t3);
    }
    function et(e3, t3) {
      return "1" === ot(e3, t3);
    }
    function tt(e3, t3) {
      return !!function(e4) {
        if (e4 && e4.respectDnt) {
          var t4 = e4 && e4.window || x2, r3 = t4.navigator || {}, n2 = false;
          return L([r3.doNotTrack, r3.msDoNotTrack, t4.doNotTrack], function(e5) {
            W([true, 1, "1", "yes"], e5) && (n2 = true);
          }), n2;
        }
        return false;
      }(t3) || "0" === ot(e3, t3);
    }
    function rt(e3, t3) {
      nt(t3 = t3 || {}).remove(it(e3, t3), !!t3.crossSubdomainCookie);
    }
    function nt(e3) {
      return "localStorage" === (e3 = e3 || {}).persistenceType ? Oe : "localStorage+cookie" === e3.persistenceType ? xe : Ie;
    }
    function it(e3, t3) {
      return ((t3 = t3 || {}).persistencePrefix || Xe) + e3;
    }
    function ot(e3, t3) {
      return nt(t3).get(it(e3, t3));
    }
    function st(e3, t3, r3) {
      z2(t3) && t3.length ? (nt(r3 = r3 || {}).set(it(t3, r3), e3 ? 1 : 0, J(r3.cookieExpiration) ? r3.cookieExpiration : null, r3.crossSubdomainCookie, r3.secureCookie), r3.capture && e3 && r3.capture(r3.captureEventName || "$opt_in", r3.captureProperties || {}, { send_instantly: true })) : console.error("gdpr." + (e3 ? "optIn" : "optOut") + " called with an invalid token");
    }
    function at(e3, t3) {
      var r3 = false;
      try {
        var n2 = e3.get_config("token"), i3 = e3.get_config("respect_dnt"), o2 = e3.get_config("opt_out_capturing_persistence_type"), s3 = e3.get_config("opt_out_capturing_cookie_prefix") || void 0, a2 = e3.get_config("window");
        n2 && (r3 = tt(n2, { respectDnt: i3, persistenceType: o2, persistencePrefix: s3, window: a2 }));
      } catch (e4) {
        t3 || console.error("Unexpected error when checking capturing opt-out status: " + e4);
      }
      return r3;
    }
    function ct(e3, t3, r3) {
      return function() {
        for (var n2 = at(e3, r3), i3 = arguments.length, o2 = new Array(i3), s3 = 0; s3 < i3; s3++)
          o2[s3] = arguments[s3];
        if (!n2)
          return t3.apply(this, o2);
        var a2 = o2[o2.length - 1];
        "function" == typeof a2 && a2(0);
      };
    }
    var ut = "$set";
    var lt = function() {
      function e3(t3) {
        var r3 = this;
        n(this, e3), this._posthog = t3, this.set = ct(t3, function(e4, t4, n2) {
          var i3 = r3.set_action(e4, t4);
          return r3._posthog.setPersonPropertiesForFlags(i3.$set || {}), G(e4) && (n2 = t4), r3._get_config("save_referrer") && r3._posthog.sessionPersistence.update_referrer_info(), i3[ut] = H({}, de.people_properties(), r3._posthog.sessionPersistence.get_referrer_info(), i3[ut]), r3._send_request(i3, n2);
        }), this.set_once = ct(t3, function(e4, t4, n2) {
          var i3 = r3.set_once_action(e4, t4);
          return G(e4) && (n2 = t4), r3._send_request(i3, n2);
        });
      }
      return o(e3, [{ key: "toString", value: function() {
        return this._posthog.toString() + ".people";
      } }, { key: "_send_request", value: function(e4, t3) {
        e4.$token = this._get_config("token"), e4.$distinct_id = this._posthog.get_distinct_id();
        var r3 = this._posthog.get_property("$device_id"), n2 = this._posthog.get_property("$user_id"), i3 = this._posthog.get_property("$had_persisted_distinct_id");
        r3 && (e4.$device_id = r3), n2 && (e4.$user_id = n2), i3 && (e4.$had_persisted_distinct_id = i3);
        var o2 = Z2(e4), s3 = te(o2, this._get_config("properties_string_max_length")), a2 = re(JSON.stringify(o2));
        return this._posthog._send_request(this._get_config("api_host") + "/engage/", { data: a2 }, {}, this._posthog._prepare_callback(t3, s3)), s3;
      } }, { key: "_get_config", value: function(e4) {
        return this._posthog.get_config(e4);
      } }, { key: "_is_reserved_property", value: function(e4) {
        return "$distinct_id" === e4 || "$token" === e4 || "$device_id" === e4 || "$user_id" === e4 || "$had_persisted_distinct_id" === e4;
      } }, { key: "set_action", value: function(e4, t3) {
        return this.apiActionParser(ut, e4, t3);
      } }, { key: "set_once_action", value: function(e4, t3) {
        return this.apiActionParser("$set_once", e4, t3);
      } }, { key: "apiActionParser", value: function(e4, t3, r3) {
        var n2 = this, i3 = {}, o2 = {};
        return G(t3) ? L(t3, function(e5, t4) {
          n2._is_reserved_property(t4) || (o2[t4] = e5);
        }) : o2[t3] = r3, i3[e4] = o2, i3;
      } }]), e3;
    }();
    var dt = "$active_feature_flags";
    var pt = "$override_feature_flags";
    var ft = "$feature_flag_payloads";
    var ht = function(e3) {
      var t3, r3 = {}, n2 = v(function(e4) {
        for (var t4 = Object.keys(e4), r4 = t4.length, n3 = new Array(r4); r4--; )
          n3[r4] = [t4[r4], e4[t4[r4]]];
        return n3;
      }(e3 || {}));
      try {
        for (n2.s(); !(t3 = n2.n()).done; ) {
          var i3 = f3(t3.value, 2), o2 = i3[0], s3 = i3[1];
          s3 && (r3[o2] = s3);
        }
      } catch (e4) {
        n2.e(e4);
      } finally {
        n2.f();
      }
      return r3;
    };
    var _t = function() {
      function e3(t3) {
        n(this, e3), this.instance = t3, this._override_warning = false, this.flagCallReported = {}, this.featureFlagEventHandlers = [], this.reloadFeatureFlagsQueued = false, this.reloadFeatureFlagsInAction = false;
      }
      return o(e3, [{ key: "getFlags", value: function() {
        return Object.keys(this.getFlagVariants());
      } }, { key: "getFlagVariants", value: function() {
        var e4 = this.instance.get_property(He), t3 = this.instance.get_property(pt);
        if (!t3)
          return e4 || {};
        for (var r3 = H({}, e4), n2 = Object.keys(t3), i3 = 0; i3 < n2.length; i3++)
          false === t3[n2[i3]] ? delete r3[n2[i3]] : r3[n2[i3]] = t3[n2[i3]];
        return this._override_warning || (console.warn("[PostHog] Overriding feature flags!", { enabledFlags: e4, overriddenFlags: t3, finalFlags: r3 }), this._override_warning = true), r3;
      } }, { key: "getFlagPayloads", value: function() {
        return this.instance.get_property(ft) || {};
      } }, { key: "reloadFeatureFlags", value: function() {
        this.reloadFeatureFlagsQueued || (this.reloadFeatureFlagsQueued = true, this._startReloadTimer());
      } }, { key: "setAnonymousDistinctId", value: function(e4) {
        this.$anon_distinct_id = e4;
      } }, { key: "setReloadingPaused", value: function(e4) {
        this.reloadFeatureFlagsInAction = e4;
      } }, { key: "resetRequestQueue", value: function() {
        this.reloadFeatureFlagsQueued = false;
      } }, { key: "_startReloadTimer", value: function() {
        var e4 = this;
        this.reloadFeatureFlagsQueued && !this.reloadFeatureFlagsInAction && setTimeout(function() {
          !e4.reloadFeatureFlagsInAction && e4.reloadFeatureFlagsQueued && (e4.reloadFeatureFlagsQueued = false, e4._reloadFeatureFlagsRequest());
        }, 5);
      } }, { key: "_reloadFeatureFlagsRequest", value: function() {
        var e4 = this;
        this.setReloadingPaused(true);
        var t3 = this.instance.get_config("token"), r3 = this.instance.get_property(Ve), n2 = this.instance.get_property(We), i3 = re(JSON.stringify({ token: t3, distinct_id: this.instance.get_distinct_id(), groups: this.instance.getGroups(), $anon_distinct_id: this.$anon_distinct_id, person_properties: r3, group_properties: n2 }));
        this.instance._send_request(this.instance.get_config("api_host") + "/decide/?v=3", { data: i3 }, { method: "POST" }, this.instance._prepare_callback(function(t4) {
          e4.$anon_distinct_id = void 0, e4.receivedFeatureFlags(t4), e4.setReloadingPaused(false), e4._startReloadTimer();
        }));
      } }, { key: "getFeatureFlag", value: function(e4) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!this.getFlags())
          return console.warn('getFeatureFlag for key "' + e4 + `" failed. Feature flags didn't load in time.`), false;
        var r3 = this.getFlagVariants()[e4];
        return !t3.send_event && "send_event" in t3 || this.flagCallReported[e4] || (this.flagCallReported[e4] = true, this.instance.capture("$feature_flag_called", { $feature_flag: e4, $feature_flag_response: r3 })), r3;
      } }, { key: "getFeatureFlagPayload", value: function(e4) {
        return this.getFlagPayloads()[e4];
      } }, { key: "isFeatureEnabled", value: function(e4) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.getFlags() ? !!this.getFeatureFlag(e4, t3) : (console.warn('isFeatureEnabled for key "' + e4 + `" failed. Feature flags didn't load in time.`), false);
      } }, { key: "addFeatureFlagsHandler", value: function(e4) {
        this.featureFlagEventHandlers.push(e4);
      } }, { key: "removeFeatureFlagsHandler", value: function(e4) {
        this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter(function(t3) {
          return t3 !== e4;
        });
      } }, { key: "receivedFeatureFlags", value: function(e4) {
        this.instance.decideEndpointWasHit = true;
        var r3 = this.getFlagVariants(), n2 = this.getFlagPayloads();
        !function(e5, r4) {
          var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o2 = e5.featureFlags, a2 = e5.featureFlagPayloads;
          if (o2)
            if (Array.isArray(o2)) {
              var c2, u2 = {};
              if (o2)
                for (var l2 = 0; l2 < o2.length; l2++)
                  u2[o2[l2]] = true;
              r4 && r4.register((s2(c2 = {}, dt, o2), s2(c2, He, u2), c2));
            } else {
              var d2, p2 = o2, f4 = a2;
              e5.errorsWhileComputingFlags && (p2 = t2(t2({}, n3), p2), f4 = t2(t2({}, i3), f4)), r4 && r4.register((s2(d2 = {}, dt, Object.keys(ht(p2))), s2(d2, He, p2 || {}), s2(d2, ft, f4 || {}), d2));
            }
        }(e4, this.instance.persistence, r3, n2), this._fireFeatureFlagsCallbacks();
      } }, { key: "override", value: function(e4) {
        if (this._override_warning = false, false === e4)
          this.instance.persistence.unregister(pt);
        else if (Array.isArray(e4)) {
          for (var t3 = {}, r3 = 0; r3 < e4.length; r3++)
            t3[e4[r3]] = true;
          this.instance.persistence.register(s2({}, pt, t3));
        } else
          this.instance.persistence.register(s2({}, pt, e4));
      } }, { key: "onFeatureFlags", value: function(e4) {
        var t3 = this;
        if (this.addFeatureFlagsHandler(e4), this.instance.decideEndpointWasHit) {
          var r3 = this._prepareFeatureFlagsForCallbacks(), n2 = r3.flags, i3 = r3.flagVariants;
          e4(n2, i3);
        }
        return function() {
          return t3.removeFeatureFlagsHandler(e4);
        };
      } }, { key: "updateEarlyAccessFeatureEnrollment", value: function(e4, r3) {
        var n2, i3 = s2({}, "$feature_enrollment/".concat(e4), r3);
        this.instance.capture("$feature_enrollment_update", { $feature_flag: e4, $feature_enrollment: r3, $set: i3 }), this.setPersonPropertiesForFlags(i3, false);
        var o2 = t2(t2({}, this.getFlagVariants()), {}, s2({}, e4, r3));
        this.instance.persistence.register((s2(n2 = {}, dt, Object.keys(ht(o2))), s2(n2, He, o2), n2)), this._fireFeatureFlagsCallbacks();
      } }, { key: "getEarlyAccessFeatures", value: function(e4) {
        var t3 = this, r3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = this.instance.get_property(Ue);
        if (n2 && !r3)
          return e4(n2);
        this.instance._send_request("".concat(this.instance.get_config("api_host"), "/api/early_access_features/?token=").concat(this.instance.get_config("token")), {}, { method: "GET" }, function(r4) {
          var n3 = r4.earlyAccessFeatures;
          return t3.instance.persistence.register(s2({}, Ue, n3)), e4(n3);
        });
      } }, { key: "_prepareFeatureFlagsForCallbacks", value: function() {
        var e4 = this.getFlags(), t3 = this.getFlagVariants();
        return { flags: e4.filter(function(e5) {
          return t3[e5];
        }), flagVariants: Object.keys(t3).filter(function(e5) {
          return t3[e5];
        }).reduce(function(e5, r3) {
          return e5[r3] = t3[r3], e5;
        }, {}) };
      } }, { key: "_fireFeatureFlagsCallbacks", value: function() {
        var e4 = this._prepareFeatureFlagsForCallbacks(), t3 = e4.flags, r3 = e4.flagVariants;
        this.featureFlagEventHandlers.forEach(function(e5) {
          return e5(t3, r3);
        });
      } }, { key: "setPersonPropertiesForFlags", value: function(e4) {
        var r3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this.instance.get_property(Ve) || {};
        this.instance.register(s2({}, Ve, t2(t2({}, n2), e4))), r3 && this.instance.reloadFeatureFlags();
      } }, { key: "resetPersonPropertiesForFlags", value: function() {
        this.instance.unregister(Ve);
      } }, { key: "setGroupPropertiesForFlags", value: function(e4) {
        var r3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this.instance.get_property(We) || {};
        0 !== Object.keys(n2).length && Object.keys(n2).forEach(function(r4) {
          n2[r4] = t2(t2({}, n2[r4]), e4[r4]), delete e4[r4];
        }), this.instance.register(s2({}, We, t2(t2({}, n2), e4))), r3 && this.instance.reloadFeatureFlags();
      } }, { key: "resetGroupPropertiesForFlags", value: function(e4) {
        if (e4) {
          var r3 = this.instance.get_property(We) || {};
          this.instance.register(s2({}, We, t2(t2({}, r3), {}, s2({}, e4, {}))));
        } else
          this.instance.unregister(We);
      } }]), e3;
    }();
    var gt = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNOCAwSDE2TDAgMTZWOEw4IDBaIiBmaWxsPSIjMkQyRDJEIi8+CjxwYXRoIGQ9Ik0xNiA4VjE2SDhMMTYgOFoiIGZpbGw9IiMyRDJEMkQiLz4KPC9zdmc+Cg==";
    var vt = 2;
    var yt = 4;
    var mt = 6;
    var bt = "rrweb/console@1";
    var wt;
    var kt = "/e/";
    !function(e3) {
      e3[e3.Mutation = 0] = "Mutation", e3[e3.MouseMove = 1] = "MouseMove", e3[e3.MouseInteraction = 2] = "MouseInteraction", e3[e3.Scroll = 3] = "Scroll", e3[e3.ViewportResize = 4] = "ViewportResize", e3[e3.Input = 5] = "Input", e3[e3.TouchMove = 6] = "TouchMove", e3[e3.MediaInteraction = 7] = "MediaInteraction", e3[e3.StyleSheetRule = 8] = "StyleSheetRule", e3[e3.CanvasMutation = 9] = "CanvasMutation", e3[e3.Font = 10] = "Font", e3[e3.Log = 11] = "Log", e3[e3.Drag = 12] = "Drag", e3[e3.StyleDeclaration = 13] = "StyleDeclaration";
    }(wt || (wt = {}));
    var Ft = [wt.MouseMove, wt.MouseInteraction, wt.Scroll, wt.ViewportResize, wt.Input, wt.TouchMove, wt.MediaInteraction, wt.Drag];
    var St = function() {
      function e3(t3) {
        n(this, e3), s2(this, "lastActivityTimestamp", Date.now()), s2(this, "isIdle", false), this.instance = t3, this.captureStarted = false, this.snapshots = [], this.emit = false, this.endpoint = kt, this.stopRrweb = void 0, this.windowId = null, this.sessionId = null, this.receivedDecide = false;
      }
      return o(e3, [{ key: "startRecordingIfEnabled", value: function() {
        this.isRecordingEnabled() ? this.startCaptureAndTrySendingQueuedSnapshots() : this.stopRecording();
      } }, { key: "started", value: function() {
        return this.captureStarted;
      } }, { key: "stopRecording", value: function() {
        this.captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this.captureStarted = false);
      } }, { key: "isRecordingEnabled", value: function() {
        var e4 = !!this.instance.get_property(De), t3 = !this.instance.get_config("disable_session_recording");
        return e4 && t3;
      } }, { key: "isConsoleLogCaptureEnabled", value: function() {
        var e4 = !!this.instance.get_property(Ne), t3 = this.instance.get_config("enable_recording_console_log");
        return null != t3 ? t3 : e4;
      } }, { key: "getRecordingVersion", value: function() {
        var e4, t3 = this.instance.get_property(Le);
        return (null === (e4 = this.instance.get_config("session_recording")) || void 0 === e4 ? void 0 : e4.recorderVersion) || t3 || "v1";
      } }, { key: "afterDecideResponse", value: function(e4) {
        var t3, r3, n2, i3, o2, a2;
        (this.receivedDecide = true, this.instance.persistence) && this.instance.persistence.register((s2(o2 = {}, De, !!e4.sessionRecording), s2(o2, Ne, null === (n2 = e4.sessionRecording) || void 0 === n2 ? void 0 : n2.consoleLogRecordingEnabled), s2(o2, Le, null === (i3 = e4.sessionRecording) || void 0 === i3 ? void 0 : i3.recorderVersion), o2));
        null !== (t3 = e4.sessionRecording) && void 0 !== t3 && t3.endpoint && (this.endpoint = null === (a2 = e4.sessionRecording) || void 0 === a2 ? void 0 : a2.endpoint);
        null !== (r3 = e4.sessionRecording) && void 0 !== r3 && r3.recorderVersion && (this.recorderVersion = e4.sessionRecording.recorderVersion), this.startRecordingIfEnabled();
      } }, { key: "startCaptureAndTrySendingQueuedSnapshots", value: function() {
        var e4 = this;
        this.receivedDecide && (this.emit = true, this.snapshots.forEach(function(t3) {
          return e4._captureSnapshot(t3);
        })), this._startCapture();
      } }, { key: "_startCapture", value: function() {
        var e4 = this;
        if (void 0 !== Object.assign && !this.captureStarted && !this.instance.get_config("disable_session_recording")) {
          this.captureStarted = true;
          var t3 = "v2" === this.getRecordingVersion() ? "recorder-v2.js" : "recorder.js";
          this.instance.__loaded_recorder_version !== this.getRecordingVersion() ? le(this.instance.get_config("api_host") + "/static/".concat(t3, "?v=").concat(S2.LIB_VERSION), function(r3) {
            if (r3)
              return D.error("Could not load ".concat(t3), r3);
            e4._onScriptLoaded();
          }) : this._onScriptLoaded();
        }
      } }, { key: "_isInteractiveEvent", value: function(e4) {
        var t3;
        return 3 === e4.type && -1 !== Ft.indexOf(null === (t3 = e4.data) || void 0 === t3 ? void 0 : t3.source);
      } }, { key: "_updateWindowAndSessionIds", value: function(e4) {
        var t3 = this._isInteractiveEvent(e4);
        if (t3 || this.isIdle || e4.timestamp - this.lastActivityTimestamp > 3e5 && (this.isIdle = true), t3 && (this.lastActivityTimestamp = e4.timestamp, this.isIdle && (this.isIdle = false, this._tryTakeFullSnapshot())), !this.isIdle) {
          var r3 = this.instance.sessionManager.checkAndGetSessionAndWindowId(!t3, e4.timestamp), n2 = r3.windowId, i3 = r3.sessionId;
          -1 !== [vt, yt].indexOf(e4.type) || this.windowId === n2 && this.sessionId === i3 || this._tryTakeFullSnapshot(), this.windowId = n2, this.sessionId = i3;
        }
      } }, { key: "_tryTakeFullSnapshot", value: function() {
        if (!this.captureStarted)
          return false;
        try {
          var e4;
          return null === (e4 = this.rrwebRecord) || void 0 === e4 || e4.takeFullSnapshot(), true;
        } catch (e5) {
          return D.error("Error taking full snapshot.", e5), false;
        }
      } }, { key: "_onScriptLoaded", value: function() {
        var e4 = this, r3 = { blockClass: "ph-no-capture", blockSelector: void 0, ignoreClass: "ph-ignore-input", maskTextClass: "ph-mask", maskTextSelector: void 0, maskAllInputs: true, maskInputOptions: {}, maskInputFn: void 0, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true };
        this.rrwebRecord = window.rrweb ? window.rrweb.record : window.rrwebRecord;
        for (var n2 = this.instance.get_config("session_recording"), i3 = 0, o2 = Object.entries(n2 || {}); i3 < o2.length; i3++) {
          var s3 = f3(o2[i3], 2), a2 = s3[0], c2 = s3[1];
          a2 in r3 && (r3[a2] = c2);
        }
        this.rrwebRecord ? (this.stopRrweb = this.rrwebRecord(t2({ emit: function(t3) {
          e4.onRRwebEmit(t3);
        }, plugins: window.rrwebConsoleRecord && this.isConsoleLogCaptureEnabled() ? [window.rrwebConsoleRecord.getRecordConsolePlugin()] : [] }, r3)), this.instance._addCaptureHook(function(t3) {
          try {
            var r4;
            if ("$pageview" === t3)
              null === (r4 = e4.rrwebRecord) || void 0 === r4 || r4.addCustomEvent("$pageview", { href: window.location.href });
          } catch (e5) {
            D.error("Could not add $pageview to rrweb session", e5);
          }
        }), this.lastActivityTimestamp = Date.now(), this.isIdle = false) : D.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
      } }, { key: "onRRwebEmit", value: function(e4) {
        if (e4 = function(e5) {
          if (e5 && "object" === r2(e5) && e5.type === mt && "object" === r2(e5.data) && e5.data.plugin === bt) {
            e5.data.payload.payload.length > 10 && (e5.data.payload.payload = e5.data.payload.payload.slice(0, 10), e5.data.payload.payload.push("...[truncated]"));
            for (var t4 = [], n2 = 0; n2 < e5.data.payload.payload.length; n2++)
              e5.data.payload.payload[n2] && e5.data.payload.payload[n2].length > 2e3 ? t4.push(e5.data.payload.payload[n2].slice(0, 2e3) + "...[truncated]") : t4.push(e5.data.payload.payload[n2]);
            return e5.data.payload.payload = t4, e5;
          }
          return e5;
        }(function(e5) {
          if (e5 && "object" === r2(e5)) {
            var t4 = JSON.stringify(e5);
            if (t4.length > 5e6) {
              var n2, i3 = v(t4.matchAll(/data:([\w\/\-\.]+);(\w+),([^)"]*)/gim));
              try {
                for (i3.s(); !(n2 = i3.n()).done; ) {
                  var o2 = n2.value;
                  t4 = "image/" === o2[1].toLocaleLowerCase().slice(0, 6) ? t4.replace(o2[0], gt) : t4.replace(o2[0], "");
                }
              } catch (e6) {
                i3.e(e6);
              } finally {
                i3.f();
              }
            }
            return JSON.parse(t4);
          }
          return e5;
        }(e4)), this._updateWindowAndSessionIds(e4), !this.isIdle) {
          var t3 = { $snapshot_data: e4, $session_id: this.sessionId, $window_id: this.windowId };
          this.instance._captureMetrics.incr("rrweb-record"), this.instance._captureMetrics.incr("rrweb-record-".concat(e4.type)), this.emit ? this._captureSnapshot(t3) : this.snapshots.push(t3);
        }
      } }, { key: "_captureSnapshot", value: function(e4) {
        this.instance.capture("$snapshot", e4, { transport: "XHR", method: "POST", endpoint: this.endpoint, _noTruncate: true, _batchKey: "sessionRecording", _metrics: { rrweb_full_snapshot: e4.$snapshot_data.type === vt } });
      } }]), e3;
    }();
    var Pt = { entryType: 0, timeOrigin: 1, name: 2, startTime: 3, redirectStart: 4, redirectEnd: 5, workerStart: 6, fetchStart: 7, domainLookupStart: 8, domainLookupEnd: 9, connectStart: 10, secureConnectionStart: 11, connectEnd: 12, requestStart: 13, responseStart: 14, responseEnd: 15, decodedBodySize: 16, encodedBodySize: 17, initiatorType: 18, nextHopProtocol: 19, renderBlockingStatus: 20, responseStatus: 21, transferSize: 22, element: 23, renderTime: 24, loadTime: 25, size: 26, id: 27, url: 28, domComplete: 29, domContentLoadedEvent: 30, domInteractive: 31, loadEventEnd: 32, loadEventStart: 33, redirectCount: 34, navigationType: 35, unloadEventEnd: 36, unloadEventStart: 37, duration: 39, timestamp: 40 };
    var It = ["first-input", "navigation", "paint", "resource"];
    var Et = ["/s/", "/e/"];
    var Ot = function() {
      function e3(t3) {
        n(this, e3), s2(this, "_forceAllowLocalhost", false), this.instance = t3;
      }
      return o(e3, [{ key: "startObservingIfEnabled", value: function() {
        this.isEnabled() ? this.startObserving() : this.stopObserving();
      } }, { key: "startObserving", value: function() {
        var e4 = this;
        if (!this.observer)
          if (!M.includes(location.hostname) || this._forceAllowLocalhost)
            try {
              this.observer = new PerformanceObserver(function(t4) {
                t4.getEntries().forEach(function(t5) {
                  e4._capturePerformanceEvent(t5);
                });
              });
              var t3 = PerformanceObserver.supportedEntryTypes.filter(function(e5) {
                return It.includes(e5);
              });
              t3.forEach(function(t4) {
                var r3;
                null === (r3 = e4.observer) || void 0 === r3 || r3.observe({ type: t4, buffered: true });
              });
            } catch (e5) {
              console.error("PostHog failed to start performance observer", e5), this.stopObserving();
            }
          else
            D.log("PostHog Peformance observer not started because we are on localhost.");
      } }, { key: "stopObserving", value: function() {
        this.observer && (this.observer.disconnect(), this.observer = void 0);
      } }, { key: "isObserving", value: function() {
        return !!this.observer;
      } }, { key: "isEnabled", value: function() {
        var e4, t3;
        return null !== (e4 = null !== (t3 = this.instance.get_config("capture_performance")) && void 0 !== t3 ? t3 : this.remoteEnabled) && void 0 !== e4 && e4;
      } }, { key: "afterDecideResponse", value: function(e4) {
        this.remoteEnabled = e4.capturePerformance || false, this.isEnabled() && this.startObserving();
      } }, { key: "_capturePerformanceEvent", value: function(e4) {
        if (e4.name.startsWith(this.instance.get_config("api_host"))) {
          var t3 = e4.name.replace(this.instance.get_config("api_host"), "");
          if (Et.find(function(e5) {
            return t3.startsWith(e5);
          }))
            return;
        }
        var r3 = { url: e4.name }, n2 = this.instance.get_config("session_recording");
        if (n2.maskNetworkRequestFn && (r3 = n2.maskNetworkRequestFn(r3)), r3) {
          var i3 = e4.toJSON();
          i3.name = r3.url;
          var o2 = {}, a2 = Math.floor(Date.now() - performance.now());
          for (var c2 in o2[Pt.timeOrigin] = a2, o2[Pt.timestamp] = Math.floor(a2 + e4.startTime), Pt)
            void 0 !== i3[c2] && (o2[Pt[c2]] = i3[c2]);
          if (this.capturePerformanceEvent(o2), xt(e4)) {
            var u2, l2 = v(e4.serverTiming || []);
            try {
              for (l2.s(); !(u2 = l2.n()).done; ) {
                var d2, p2 = u2.value;
                this.capturePerformanceEvent((s2(d2 = {}, Pt.timeOrigin, a2), s2(d2, Pt.timestamp, Math.floor(a2 + e4.startTime)), s2(d2, Pt.name, p2.name), s2(d2, Pt.duration, p2.duration), s2(d2, Pt.entryType, "serverTiming"), d2));
              }
            } catch (e5) {
              l2.e(e5);
            } finally {
              l2.f();
            }
          }
        }
      } }, { key: "capturePerformanceEvent", value: function(e4) {
        var t3, r3 = e4[Pt.timestamp];
        null === (t3 = this.instance.sessionRecording) || void 0 === t3 || t3.onRRwebEmit({ type: 6, data: { plugin: "posthog/network@1", payload: e4 }, timestamp: r3 });
      } }]), e3;
    }();
    var xt = function(e3) {
      return "navigation" === e3.entryType || "resource" === e3.entryType;
    };
    var At = function() {
      function e3(t3) {
        n(this, e3), this.instance = t3, this.instance.decideEndpointWasHit = this.instance._hasBootstrappedFeatureFlags();
      }
      return o(e3, [{ key: "call", value: function() {
        var e4 = this, t3 = re(JSON.stringify({ token: this.instance.get_config("token"), distinct_id: this.instance.get_distinct_id(), groups: this.instance.getGroups(), person_properties: this.instance.get_property(Ve), group_properties: this.instance.get_property(We) }));
        this.instance._send_request("".concat(this.instance.get_config("api_host"), "/decide/?v=3"), { data: t3, verbose: true }, { method: "POST" }, function(t4) {
          return e4.parseDecideResponse(t4);
        });
      } }, { key: "parseDecideResponse", value: function(e4) {
        var t3, r3, n2 = this;
        if (0 !== (null == e4 ? void 0 : e4.status)) {
          if (this.instance.decideEndpointWasHit = true, !document || !document.body)
            return console.log("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(function() {
              n2.parseDecideResponse(e4);
            }, 500);
          if (this.instance.toolbar.afterDecideResponse(e4), null === (t3 = this.instance.sessionRecording) || void 0 === t3 || t3.afterDecideResponse(e4), Ze.afterDecideResponse(e4, this.instance), null === (r3 = this.instance.webPerformance) || void 0 === r3 || r3.afterDecideResponse(e4), this.instance.featureFlags.receivedFeatureFlags(e4), this.instance.compression = {}, e4.supportedCompression && !this.instance.get_config("disable_compression")) {
            var i3, o2 = {}, s3 = v(e4.supportedCompression);
            try {
              for (s3.s(); !(i3 = s3.n()).done; ) {
                o2[i3.value] = true;
              }
            } catch (e5) {
              s3.e(e5);
            } finally {
              s3.f();
            }
            this.instance.compression = o2;
          }
          if (e4.siteApps)
            if (this.instance.get_config("opt_in_site_apps")) {
              var a2, c2 = this.instance.get_config("api_host"), u2 = v(e4.siteApps);
              try {
                var l2 = function() {
                  var e5 = a2.value, t4 = e5.id, r4 = e5.url, i4 = [c2, "/" === c2[c2.length - 1] && "/" === r4[0] ? r4.substring(1) : r4].join("");
                  window["__$$ph_site_app_".concat(t4)] = n2.instance, le(i4, function(e6) {
                    e6 && console.error("Error while initializing PostHog app with config id ".concat(t4), e6);
                  });
                };
                for (u2.s(); !(a2 = u2.n()).done; )
                  l2();
              } catch (e5) {
                u2.e(e5);
              } finally {
                u2.f();
              }
            } else
              e4.siteApps.length > 0 && console.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
        } else
          console.error("Failed to fetch feature flags from PostHog.");
      } }]), e3;
    }();
    var Ct = ["https://app.posthog.com", "https://eu.posthog.com"];
    var Tt = ["source"];
    var Mt = function() {
      function e3(t3) {
        n(this, e3), this.instance = t3;
      }
      return o(e3, [{ key: "afterDecideResponse", value: function(e4) {
        var r3 = e4.toolbarParams || e4.editorParams || (e4.toolbarVersion ? { toolbarVersion: e4.toolbarVersion } : {});
        e4.isAuthenticated && r3.toolbarVersion && 0 === r3.toolbarVersion.indexOf("toolbar") && this.loadToolbar(t2({}, r3));
      } }, { key: "maybeLoadToolbar", value: function() {
        var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.location, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.history;
        try {
          if (!t3) {
            try {
              window.localStorage.setItem("test", "test"), window.localStorage.removeItem("test");
            } catch (e5) {
              return false;
            }
            t3 = window.localStorage;
          }
          var n2, i3 = ce(e4.hash, "__posthog") || ce(e4.hash, "state"), o2 = i3 ? JSON.parse(decodeURIComponent(i3)) : null;
          return o2 && "ph_authorize" === o2.action ? ((n2 = o2).source = "url", n2 && Object.keys(n2).length > 0 && (o2.desiredHash ? e4.hash = o2.desiredHash : r3 ? r3.replaceState("", document.title, e4.pathname + e4.search) : e4.hash = "")) : ((n2 = JSON.parse(t3.getItem("_postHogToolbarParams") || "{}")).source = "localstorage", delete n2.userIntent), !(!n2.token || this.instance.get_config("token") !== n2.token) && (this.loadToolbar(n2), true);
        } catch (e5) {
          return false;
        }
      } }, { key: "loadToolbar", value: function(e4) {
        var r3 = this;
        if (window._postHogToolbarLoaded)
          return false;
        window._postHogToolbarLoaded = true;
        var n2 = this.instance.get_config("api_host"), i3 = 3e4 * Math.floor(Date.now() / 3e4), o2 = "".concat(n2).concat(n2.endsWith("/") ? "" : "/", "static/toolbar.js?_ts=").concat(i3), s3 = !Ct.includes(this.instance.get_config("api_host")) && this.instance.get_config("advanced_disable_toolbar_metrics"), a2 = t2(t2({ token: this.instance.get_config("token") }, e4), {}, { apiURL: n2 }, s3 ? { instrument: false } : {});
        a2.source;
        var c2 = l(a2, Tt);
        return window.localStorage.setItem("_postHogToolbarParams", JSON.stringify(c2)), le(o2, function(e5) {
          e5 ? D.error("Failed to load toolbar", e5) : (window.ph_load_toolbar || window.ph_load_editor)(a2, r3.instance);
        }), ue(window, "turbolinks:load", function() {
          window._postHogToolbarLoaded = false, r3.loadToolbar(a2);
        }), true;
      } }, { key: "_loadEditor", value: function(e4) {
        return this.loadToolbar(e4);
      } }, { key: "maybeLoadEditor", value: function() {
        var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.location, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.history;
        return this.maybeLoadToolbar(e4, t3, r3);
      } }]), e3;
    }();
    var $t = function() {
      function e3() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3e3;
        n(this, e3), this.isPolling = true, this._event_queue = [], this._empty_queue_count = 0, this._poller = void 0, this._pollInterval = t3;
      }
      return o(e3, [{ key: "setPollInterval", value: function(e4) {
        this._pollInterval = e4, this.isPolling && this.poll();
      } }, { key: "poll", value: function() {
      } }, { key: "unload", value: function() {
      } }, { key: "getTime", value: function() {
        return (/* @__PURE__ */ new Date()).getTime();
      } }]), e3;
    }();
    var Rt = function(e3) {
      a(i3, $t);
      var r3 = p(i3);
      function i3(e4, t3) {
        var o2, s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3e3;
        return n(this, i3), (o2 = r3.call(this, s3)).handlePollRequest = t3, o2.captureMetrics = e4, o2;
      }
      return o(i3, [{ key: "enqueue", value: function(e4, t3, r4) {
        this.captureMetrics.incr("batch-enqueue"), this._event_queue.push({ url: e4, data: t3, options: r4 }), this.isPolling || (this.isPolling = true, this.poll());
      } }, { key: "poll", value: function() {
        var e4 = this;
        clearTimeout(this._poller), this._poller = setTimeout(function() {
          if (e4._event_queue.length > 0) {
            var t3 = e4.formatQueue(), r4 = function(r5) {
              var n3 = t3[r5], i4 = n3.url, o2 = n3.data, s3 = n3.options;
              L(o2, function(t4, r6) {
                o2[r6].offset = Math.abs(o2[r6].timestamp - e4.getTime()), delete o2[r6].timestamp;
              }), e4.handlePollRequest(i4, o2, s3), e4.captureMetrics.incr("batch-requests"), e4.captureMetrics.incr("batch-requests-".concat(i4.slice(i4.length - 2))), e4.captureMetrics.incr("batch-handle", o2.length), e4.captureMetrics.incr("batch-handle-".concat(i4.slice(i4.length - 2)), o2.length);
            };
            for (var n2 in t3)
              r4(n2);
            e4._event_queue.length = 0, e4._empty_queue_count = 0;
          } else
            e4._empty_queue_count++;
          e4._empty_queue_count > 4 && (e4.isPolling = false, e4._empty_queue_count = 0), e4.isPolling && e4.poll();
        }, this._pollInterval);
      } }, { key: "updateUnloadMetrics", value: function() {
        var e4 = this.formatQueue();
        for (var t3 in e4) {
          var r4 = e4[t3], n2 = r4.url, i4 = r4.data;
          this.captureMetrics.incr("batch-unload-requests"), this.captureMetrics.incr("batch-unload-requests-".concat(n2.slice(n2.length - 2))), this.captureMetrics.incr("batch-unload", i4.length), this.captureMetrics.incr("batch-unload-".concat(n2.slice(n2.length - 2)), i4.length);
        }
      } }, { key: "unload", value: function() {
        var e4 = this;
        clearTimeout(this._poller);
        var r4 = this._event_queue.length > 0 ? this.formatQueue() : {};
        this._event_queue.length = 0;
        var n2 = Object.values(r4);
        [].concat(h2(n2.filter(function(e5) {
          return 0 === e5.url.indexOf("/e");
        })), h2(n2.filter(function(e5) {
          return 0 !== e5.url.indexOf("/e");
        }))).map(function(r5) {
          var n3 = r5.url, i4 = r5.data, o2 = r5.options;
          e4.handlePollRequest(n3, i4, t2(t2({}, o2), {}, { transport: "sendBeacon" }));
        });
      } }, { key: "formatQueue", value: function() {
        var e4 = {};
        return L(this._event_queue, function(t3) {
          var r4 = t3.url, n2 = t3.data, i4 = t3.options, o2 = (i4 ? i4._batchKey : null) || r4;
          void 0 === e4[o2] && (e4[o2] = { data: [], url: r4, options: i4 }), i4 && e4[o2].options && e4[o2].options._metrics && !e4[o2].options._metrics.rrweb_full_snapshot && (e4[o2].options._metrics.rrweb_full_snapshot = i4._metrics.rrweb_full_snapshot), e4[o2].data.push(n2);
        }), e4;
      } }]), i3;
    }();
    var jt = function() {
      function e3(t3) {
        n(this, e3), this.enabled = t3, this.metrics = {};
      }
      return o(e3, [{ key: "incr", value: function(e4) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        this.enabled && (e4 = "phjs-".concat(e4), this.metrics[e4] = (this.metrics[e4] || 0) + t3);
      } }, { key: "decr", value: function(e4) {
        this.enabled && (e4 = "phjs-".concat(e4), this.metrics[e4] = (this.metrics[e4] || 0) - 1);
      } }]), e3;
    }();
    var qt = Uint8Array;
    var Dt = Uint16Array;
    var Nt = Uint32Array;
    var Lt = new qt([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
    var Bt = new qt([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
    var Ht = new qt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var Ut = function(e3, t3) {
      for (var r3 = new Dt(31), n2 = 0; n2 < 31; ++n2)
        r3[n2] = t3 += 1 << e3[n2 - 1];
      var i3 = new Nt(r3[30]);
      for (n2 = 1; n2 < 30; ++n2)
        for (var o2 = r3[n2]; o2 < r3[n2 + 1]; ++o2)
          i3[o2] = o2 - r3[n2] << 5 | n2;
      return [r3, i3];
    };
    var Vt = Ut(Lt, 2);
    var Wt = Vt[0];
    var Gt = Vt[1];
    Wt[28] = 258, Gt[258] = 28;
    for (Qt = Ut(Bt, 0)[1], zt = new Dt(32768), Jt = 0; Jt < 32768; ++Jt) {
      Zt = (43690 & Jt) >>> 1 | (21845 & Jt) << 1;
      Zt = (61680 & (Zt = (52428 & Zt) >>> 2 | (13107 & Zt) << 2)) >>> 4 | (3855 & Zt) << 4, zt[Jt] = ((65280 & Zt) >>> 8 | (255 & Zt) << 8) >>> 1;
    }
    var Zt;
    var Qt;
    var zt;
    var Jt;
    var Xt = function(e3, t3, r3) {
      for (var n2 = e3.length, i3 = 0, o2 = new Dt(t3); i3 < n2; ++i3)
        ++o2[e3[i3] - 1];
      var s3, a2 = new Dt(t3);
      for (i3 = 0; i3 < t3; ++i3)
        a2[i3] = a2[i3 - 1] + o2[i3 - 1] << 1;
      if (r3) {
        s3 = new Dt(1 << t3);
        var c2 = 15 - t3;
        for (i3 = 0; i3 < n2; ++i3)
          if (e3[i3])
            for (var u2 = i3 << 4 | e3[i3], l2 = t3 - e3[i3], d2 = a2[e3[i3] - 1]++ << l2, p2 = d2 | (1 << l2) - 1; d2 <= p2; ++d2)
              s3[zt[d2] >>> c2] = u2;
      } else
        for (s3 = new Dt(n2), i3 = 0; i3 < n2; ++i3)
          s3[i3] = zt[a2[e3[i3] - 1]++] >>> 15 - e3[i3];
      return s3;
    };
    var Yt = new qt(288);
    for (Jt = 0; Jt < 144; ++Jt)
      Yt[Jt] = 8;
    for (Jt = 144; Jt < 256; ++Jt)
      Yt[Jt] = 9;
    for (Jt = 256; Jt < 280; ++Jt)
      Yt[Jt] = 7;
    for (Jt = 280; Jt < 288; ++Jt)
      Yt[Jt] = 8;
    var Kt = new qt(32);
    for (Jt = 0; Jt < 32; ++Jt)
      Kt[Jt] = 5;
    var er;
    var tr = Xt(Yt, 9, 0);
    var rr = Xt(Kt, 5, 0);
    var nr = function(e3) {
      return (e3 / 8 >> 0) + (7 & e3 && 1);
    };
    var ir = function(e3, t3, r3) {
      (null == t3 || t3 < 0) && (t3 = 0), (null == r3 || r3 > e3.length) && (r3 = e3.length);
      var n2 = new (e3 instanceof Dt ? Dt : e3 instanceof Nt ? Nt : qt)(r3 - t3);
      return n2.set(e3.subarray(t3, r3)), n2;
    };
    var or = function(e3, t3, r3) {
      r3 <<= 7 & t3;
      var n2 = t3 / 8 >> 0;
      e3[n2] |= r3, e3[n2 + 1] |= r3 >>> 8;
    };
    var sr = function(e3, t3, r3) {
      r3 <<= 7 & t3;
      var n2 = t3 / 8 >> 0;
      e3[n2] |= r3, e3[n2 + 1] |= r3 >>> 8, e3[n2 + 2] |= r3 >>> 16;
    };
    var ar = function(e3, t3) {
      for (var r3 = [], n2 = 0; n2 < e3.length; ++n2)
        e3[n2] && r3.push({ s: n2, f: e3[n2] });
      var i3 = r3.length, o2 = r3.slice();
      if (!i3)
        return [new qt(0), 0];
      if (1 == i3) {
        var s3 = new qt(r3[0].s + 1);
        return s3[r3[0].s] = 1, [s3, 1];
      }
      r3.sort(function(e4, t4) {
        return e4.f - t4.f;
      }), r3.push({ s: -1, f: 25001 });
      var a2 = r3[0], c2 = r3[1], u2 = 0, l2 = 1, d2 = 2;
      for (r3[0] = { s: -1, f: a2.f + c2.f, l: a2, r: c2 }; l2 != i3 - 1; )
        a2 = r3[r3[u2].f < r3[d2].f ? u2++ : d2++], c2 = r3[u2 != l2 && r3[u2].f < r3[d2].f ? u2++ : d2++], r3[l2++] = { s: -1, f: a2.f + c2.f, l: a2, r: c2 };
      var p2 = o2[0].s;
      for (n2 = 1; n2 < i3; ++n2)
        o2[n2].s > p2 && (p2 = o2[n2].s);
      var f4 = new Dt(p2 + 1), h3 = cr(r3[l2 - 1], f4, 0);
      if (h3 > t3) {
        n2 = 0;
        var _2 = 0, g2 = h3 - t3, v2 = 1 << g2;
        for (o2.sort(function(e4, t4) {
          return f4[t4.s] - f4[e4.s] || e4.f - t4.f;
        }); n2 < i3; ++n2) {
          var y2 = o2[n2].s;
          if (!(f4[y2] > t3))
            break;
          _2 += v2 - (1 << h3 - f4[y2]), f4[y2] = t3;
        }
        for (_2 >>>= g2; _2 > 0; ) {
          var m3 = o2[n2].s;
          f4[m3] < t3 ? _2 -= 1 << t3 - f4[m3]++ - 1 : ++n2;
        }
        for (; n2 >= 0 && _2; --n2) {
          var b2 = o2[n2].s;
          f4[b2] == t3 && (--f4[b2], ++_2);
        }
        h3 = t3;
      }
      return [new qt(f4), h3];
    };
    var cr = function e3(t3, r3, n2) {
      return -1 == t3.s ? Math.max(e3(t3.l, r3, n2 + 1), e3(t3.r, r3, n2 + 1)) : r3[t3.s] = n2;
    };
    var ur = function(e3) {
      for (var t3 = e3.length; t3 && !e3[--t3]; )
        ;
      for (var r3 = new Dt(++t3), n2 = 0, i3 = e3[0], o2 = 1, s3 = function(e4) {
        r3[n2++] = e4;
      }, a2 = 1; a2 <= t3; ++a2)
        if (e3[a2] == i3 && a2 != t3)
          ++o2;
        else {
          if (!i3 && o2 > 2) {
            for (; o2 > 138; o2 -= 138)
              s3(32754);
            o2 > 2 && (s3(o2 > 10 ? o2 - 11 << 5 | 28690 : o2 - 3 << 5 | 12305), o2 = 0);
          } else if (o2 > 3) {
            for (s3(i3), --o2; o2 > 6; o2 -= 6)
              s3(8304);
            o2 > 2 && (s3(o2 - 3 << 5 | 8208), o2 = 0);
          }
          for (; o2--; )
            s3(i3);
          o2 = 1, i3 = e3[a2];
        }
      return [r3.subarray(0, n2), t3];
    };
    var lr = function(e3, t3) {
      for (var r3 = 0, n2 = 0; n2 < t3.length; ++n2)
        r3 += e3[n2] * t3[n2];
      return r3;
    };
    var dr = function(e3, t3, r3) {
      var n2 = r3.length, i3 = nr(t3 + 2);
      e3[i3] = 255 & n2, e3[i3 + 1] = n2 >>> 8, e3[i3 + 2] = 255 ^ e3[i3], e3[i3 + 3] = 255 ^ e3[i3 + 1];
      for (var o2 = 0; o2 < n2; ++o2)
        e3[i3 + o2 + 4] = r3[o2];
      return 8 * (i3 + 4 + n2);
    };
    var pr = function(e3, t3, r3, n2, i3, o2, s3, a2, c2, u2, l2) {
      or(t3, l2++, r3), ++i3[256];
      for (var d2 = ar(i3, 15), p2 = d2[0], f4 = d2[1], h3 = ar(o2, 15), _2 = h3[0], g2 = h3[1], v2 = ur(p2), y2 = v2[0], m3 = v2[1], b2 = ur(_2), w2 = b2[0], k2 = b2[1], F3 = new Dt(19), S3 = 0; S3 < y2.length; ++S3)
        F3[31 & y2[S3]]++;
      for (S3 = 0; S3 < w2.length; ++S3)
        F3[31 & w2[S3]]++;
      for (var P2 = ar(F3, 7), I2 = P2[0], E2 = P2[1], O2 = 19; O2 > 4 && !I2[Ht[O2 - 1]]; --O2)
        ;
      var x3, A3, C2, T2, M2 = u2 + 5 << 3, $2 = lr(i3, Yt) + lr(o2, Kt) + s3, R2 = lr(i3, p2) + lr(o2, _2) + s3 + 14 + 3 * O2 + lr(F3, I2) + (2 * F3[16] + 3 * F3[17] + 7 * F3[18]);
      if (M2 <= $2 && M2 <= R2)
        return dr(t3, l2, e3.subarray(c2, c2 + u2));
      if (or(t3, l2, 1 + (R2 < $2)), l2 += 2, R2 < $2) {
        x3 = Xt(p2, f4, 0), A3 = p2, C2 = Xt(_2, g2, 0), T2 = _2;
        var j2 = Xt(I2, E2, 0);
        or(t3, l2, m3 - 257), or(t3, l2 + 5, k2 - 1), or(t3, l2 + 10, O2 - 4), l2 += 14;
        for (S3 = 0; S3 < O2; ++S3)
          or(t3, l2 + 3 * S3, I2[Ht[S3]]);
        l2 += 3 * O2;
        for (var q2 = [y2, w2], D2 = 0; D2 < 2; ++D2) {
          var N2 = q2[D2];
          for (S3 = 0; S3 < N2.length; ++S3) {
            var L2 = 31 & N2[S3];
            or(t3, l2, j2[L2]), l2 += I2[L2], L2 > 15 && (or(t3, l2, N2[S3] >>> 5 & 127), l2 += N2[S3] >>> 12);
          }
        }
      } else
        x3 = tr, A3 = Yt, C2 = rr, T2 = Kt;
      for (S3 = 0; S3 < a2; ++S3)
        if (n2[S3] > 255) {
          L2 = n2[S3] >>> 18 & 31;
          sr(t3, l2, x3[L2 + 257]), l2 += A3[L2 + 257], L2 > 7 && (or(t3, l2, n2[S3] >>> 23 & 31), l2 += Lt[L2]);
          var B2 = 31 & n2[S3];
          sr(t3, l2, C2[B2]), l2 += T2[B2], B2 > 3 && (sr(t3, l2, n2[S3] >>> 5 & 8191), l2 += Bt[B2]);
        } else
          sr(t3, l2, x3[n2[S3]]), l2 += A3[n2[S3]];
      return sr(t3, l2, x3[256]), l2 + A3[256];
    };
    var fr = new Nt([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    var hr = new qt(0);
    var _r = function() {
      for (var e3 = new Nt(256), t3 = 0; t3 < 256; ++t3) {
        for (var r3 = t3, n2 = 9; --n2; )
          r3 = (1 & r3 && 3988292384) ^ r3 >>> 1;
        e3[t3] = r3;
      }
      return e3;
    }();
    var gr = function() {
      var e3 = 4294967295;
      return { p: function(t3) {
        for (var r3 = e3, n2 = 0; n2 < t3.length; ++n2)
          r3 = _r[255 & r3 ^ t3[n2]] ^ r3 >>> 8;
        e3 = r3;
      }, d: function() {
        return 4294967295 ^ e3;
      } };
    };
    var vr = function(e3, t3, r3, n2, i3) {
      return function(e4, t4, r4, n3, i4, o2) {
        var s3 = e4.length, a2 = new qt(n3 + s3 + 5 * (1 + Math.floor(s3 / 7e3)) + i4), c2 = a2.subarray(n3, a2.length - i4), u2 = 0;
        if (!t4 || s3 < 8)
          for (var l2 = 0; l2 <= s3; l2 += 65535) {
            var d2 = l2 + 65535;
            d2 < s3 ? u2 = dr(c2, u2, e4.subarray(l2, d2)) : (c2[l2] = o2, u2 = dr(c2, u2, e4.subarray(l2, s3)));
          }
        else {
          for (var p2 = fr[t4 - 1], f4 = p2 >>> 13, h3 = 8191 & p2, _2 = (1 << r4) - 1, g2 = new Dt(32768), v2 = new Dt(_2 + 1), y2 = Math.ceil(r4 / 3), m3 = 2 * y2, b2 = function(t5) {
            return (e4[t5] ^ e4[t5 + 1] << y2 ^ e4[t5 + 2] << m3) & _2;
          }, w2 = new Nt(25e3), k2 = new Dt(288), F3 = new Dt(32), S3 = 0, P2 = 0, I2 = (l2 = 0, 0), E2 = 0, O2 = 0; l2 < s3; ++l2) {
            var x3 = b2(l2), A3 = 32767 & l2, C2 = v2[x3];
            if (g2[A3] = C2, v2[x3] = A3, E2 <= l2) {
              var T2 = s3 - l2;
              if ((S3 > 7e3 || I2 > 24576) && T2 > 423) {
                u2 = pr(e4, c2, 0, w2, k2, F3, P2, I2, O2, l2 - O2, u2), I2 = S3 = P2 = 0, O2 = l2;
                for (var M2 = 0; M2 < 286; ++M2)
                  k2[M2] = 0;
                for (M2 = 0; M2 < 30; ++M2)
                  F3[M2] = 0;
              }
              var $2 = 2, R2 = 0, j2 = h3, q2 = A3 - C2 & 32767;
              if (T2 > 2 && x3 == b2(l2 - q2))
                for (var D2 = Math.min(f4, T2) - 1, N2 = Math.min(32767, l2), L2 = Math.min(258, T2); q2 <= N2 && --j2 && A3 != C2; ) {
                  if (e4[l2 + $2] == e4[l2 + $2 - q2]) {
                    for (var B2 = 0; B2 < L2 && e4[l2 + B2] == e4[l2 + B2 - q2]; ++B2)
                      ;
                    if (B2 > $2) {
                      if ($2 = B2, R2 = q2, B2 > D2)
                        break;
                      var H2 = Math.min(q2, B2 - 2), U2 = 0;
                      for (M2 = 0; M2 < H2; ++M2) {
                        var V2 = l2 - q2 + M2 + 32768 & 32767, W2 = V2 - g2[V2] + 32768 & 32767;
                        W2 > U2 && (U2 = W2, C2 = V2);
                      }
                    }
                  }
                  q2 += (A3 = C2) - (C2 = g2[A3]) + 32768 & 32767;
                }
              if (R2) {
                w2[I2++] = 268435456 | Gt[$2] << 18 | Qt[R2];
                var G2 = 31 & Gt[$2], Q2 = 31 & Qt[R2];
                P2 += Lt[G2] + Bt[Q2], ++k2[257 + G2], ++F3[Q2], E2 = l2 + $2, ++S3;
              } else
                w2[I2++] = e4[l2], ++k2[e4[l2]];
            }
          }
          u2 = pr(e4, c2, o2, w2, k2, F3, P2, I2, O2, l2 - O2, u2), o2 || (u2 = dr(c2, u2, hr));
        }
        return ir(a2, 0, n3 + nr(u2) + i4);
      }(e3, null == t3.level ? 6 : t3.level, null == t3.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e3.length)))) : 12 + t3.mem, r3, n2, !i3);
    };
    var yr = function(e3, t3, r3) {
      for (; r3; ++t3)
        e3[t3] = r3, r3 >>>= 8;
    };
    var mr = function(e3, t3) {
      var r3 = t3.filename;
      if (e3[0] = 31, e3[1] = 139, e3[2] = 8, e3[8] = t3.level < 2 ? 4 : 9 == t3.level ? 2 : 0, e3[9] = 3, 0 != t3.mtime && yr(e3, 4, Math.floor(new Date(t3.mtime || Date.now()) / 1e3)), r3) {
        e3[3] = 8;
        for (var n2 = 0; n2 <= r3.length; ++n2)
          e3[n2 + 10] = r3.charCodeAt(n2);
      }
    };
    var br = function(e3) {
      return 10 + (e3.filename && e3.filename.length + 1 || 0);
    };
    function wr(e3, t3) {
      void 0 === t3 && (t3 = {});
      var r3 = gr(), n2 = e3.length;
      r3.p(e3);
      var i3 = vr(e3, t3, br(t3), 8), o2 = i3.length;
      return mr(i3, t3), yr(i3, o2 - 8, r3.d()), yr(i3, o2 - 4, n2), i3;
    }
    function kr(e3, t3) {
      var r3 = e3.length;
      if (!t3 && "undefined" != typeof TextEncoder)
        return new TextEncoder().encode(e3);
      for (var n2 = new qt(e3.length + (e3.length >>> 1)), i3 = 0, o2 = function(e4) {
        n2[i3++] = e4;
      }, s3 = 0; s3 < r3; ++s3) {
        if (i3 + 5 > n2.length) {
          var a2 = new qt(i3 + 8 + (r3 - s3 << 1));
          a2.set(n2), n2 = a2;
        }
        var c2 = e3.charCodeAt(s3);
        c2 < 128 || t3 ? o2(c2) : c2 < 2048 ? (o2(192 | c2 >>> 6), o2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (o2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & e3.charCodeAt(++s3)) >>> 18), o2(128 | c2 >>> 12 & 63), o2(128 | c2 >>> 6 & 63), o2(128 | 63 & c2)) : (o2(224 | c2 >>> 12), o2(128 | c2 >>> 6 & 63), o2(128 | 63 & c2));
      }
      return ir(n2, 0, i3);
    }
    exports.Compression = void 0, (er = exports.Compression || (exports.Compression = {})).GZipJS = "gzip-js", er.LZ64 = "lz64", er.Base64 = "base64";
    var Fr;
    var Sr;
    var Pr;
    var Ir = function(e3, t3, r3) {
      var n2 = t3 || {};
      n2.ip = r3.ip ? 1 : 0, n2._ = (/* @__PURE__ */ new Date()).getTime().toString(), n2.ver = S2.LIB_VERSION;
      var i3 = e3.split("?");
      if (i3.length > 1) {
        var o2, s3 = v(i3[1].split("&"));
        try {
          for (s3.s(); !(o2 = s3.n()).done; ) {
            var a2 = o2.value.split("=")[0];
            n2[a2] && delete n2[a2];
          }
        } catch (e4) {
          s3.e(e4);
        } finally {
          s3.f();
        }
      }
      var c2 = e3.indexOf("?") > -1 ? "&" : "?";
      return e3 + c2 + function(e4) {
        var t4, r4, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "&", i4 = [];
        return L(e4, function(e5, n4) {
          t4 = encodeURIComponent(e5.toString()), r4 = encodeURIComponent(n4), i4[i4.length] = r4 + "=" + t4;
        }), i4.join(n3);
      }(n2);
    };
    var Er = function e3(t3, r3) {
      if (r3.blob && t3.buffer)
        return new Blob([t3.buffer], { type: "text/plain" });
      if (r3.sendBeacon || r3.blob) {
        var n2 = e3(t3, { method: "POST" });
        return new Blob([n2], { type: "application/x-www-form-urlencoded" });
      }
      if ("POST" !== r3.method)
        return null;
      var i3, o2;
      return i3 = Array.isArray(t3) || (o2 = t3, "[object Uint8Array]" === Object.prototype.toString.call(o2)) ? "data=" + encodeURIComponent(t3) : "data=" + encodeURIComponent(t3.data), "compression" in t3 && t3.compression && (i3 += "&compression=" + t3.compression), i3;
    };
    var Or = function(e3) {
      var t3 = e3.url, r3 = e3.data, n2 = e3.headers, i3 = e3.options, o2 = e3.captureMetrics, s3 = e3.callback, a2 = e3.retriesPerformedSoFar, c2 = e3.retryQueue, u2 = e3.onXHRError, l2 = e3.timeout, d2 = void 0 === l2 ? 1e4 : l2, p2 = new XMLHttpRequest();
      p2.open(i3.method || "GET", t3, true);
      var f4 = Er(r3, i3);
      o2.incr("_send_request"), o2.incr("_send_request_inflight"), L(n2, function(e4, t4) {
        p2.setRequestHeader(t4, e4);
      }), "POST" !== i3.method || i3.blob || p2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), p2.timeout = d2, p2.withCredentials = true, p2.onreadystatechange = function() {
        if (4 === p2.readyState)
          if (o2.incr("xhr-response"), o2.incr("xhr-response-".concat(p2.status)), o2.decr("_send_request_inflight"), 200 === p2.status) {
            if (s3) {
              var e4;
              try {
                e4 = JSON.parse(p2.responseText);
              } catch (e5) {
                return void D.error(e5);
              }
              s3(e4);
            }
          } else
            "function" == typeof u2 && u2(p2), [401, 403, 404, 500].indexOf(p2.status) < 0 && c2.enqueue({ url: t3, data: r3, options: i3, headers: n2, retriesPerformedSoFar: (a2 || 0) + 1, callback: s3 }), s3 && s3({ status: 0 });
      }, p2.send(f4);
    };
    var xr = function(e3) {
      a(i3, $t);
      var r3 = p(i3);
      function i3(e4, t3) {
        var o2;
        return n(this, i3), (o2 = r3.call(this)).captureMetrics = e4, o2.isPolling = false, o2.queue = [], o2.areWeOnline = true, o2.onXHRError = t3, "undefined" != typeof window && "onLine" in window.navigator && (o2.areWeOnline = window.navigator.onLine, window.addEventListener("online", function() {
          o2._handleWeAreNowOnline();
        }), window.addEventListener("offline", function() {
          o2.areWeOnline = false;
        })), o2;
      }
      return o(i3, [{ key: "enqueue", value: function(e4) {
        var t3 = e4.retriesPerformedSoFar || 0;
        if (!(t3 >= 10)) {
          var r4 = 3e3 * Math.pow(2, t3), n2 = new Date(Date.now() + r4);
          console.warn("Enqueued failed request for retry in ".concat(r4)), this.queue.push({ retryAt: n2, requestData: e4 }), this.isPolling || (this.isPolling = true, this.poll());
        }
      } }, { key: "poll", value: function() {
        var e4 = this;
        this._poller && clearTimeout(this._poller), this._poller = setTimeout(function() {
          e4.areWeOnline && e4.queue.length > 0 && e4.flush(), e4.poll();
        }, this._pollInterval);
      } }, { key: "flush", value: function() {
        var e4 = new Date(Date.now()), t3 = this.queue.filter(function(t4) {
          return t4.retryAt < e4;
        });
        if (t3.length > 0) {
          this.queue = this.queue.filter(function(t4) {
            return t4.retryAt >= e4;
          });
          var r4, n2 = v(t3);
          try {
            for (n2.s(); !(r4 = n2.n()).done; ) {
              var i4 = r4.value.requestData;
              this._executeXhrRequest(i4);
            }
          } catch (e5) {
            n2.e(e5);
          } finally {
            n2.f();
          }
        }
      } }, { key: "unload", value: function() {
        this._poller && (clearTimeout(this._poller), this._poller = void 0);
        var e4, r4 = v(this.queue);
        try {
          for (r4.s(); !(e4 = r4.n()).done; ) {
            var n2 = e4.value.requestData, i4 = n2.url, o2 = n2.data, s3 = n2.options;
            try {
              window.navigator.sendBeacon(i4, Er(o2, t2(t2({}, s3), {}, { sendBeacon: true })));
            } catch (e5) {
              S2.DEBUG && console.error(e5);
            }
          }
        } catch (e5) {
          r4.e(e5);
        } finally {
          r4.f();
        }
        this.queue = [];
      } }, { key: "_executeXhrRequest", value: function(e4) {
        var t3 = e4.url, r4 = e4.data, n2 = e4.options, i4 = e4.headers, o2 = e4.callback, s3 = e4.retriesPerformedSoFar;
        Or({ url: t3, data: r4 || {}, options: n2 || {}, headers: i4 || {}, retriesPerformedSoFar: s3 || 0, callback: o2, captureMetrics: this.captureMetrics, retryQueue: this, onXHRError: this.onXHRError });
      } }, { key: "_handleWeAreNowOnline", value: function() {
        this.areWeOnline = true, this.flush();
      } }]), i3;
    }();
    var Ar = 18e5;
    var Cr = 864e5;
    var Tr = function() {
      function e3(t3, r3) {
        n(this, e3), this.config = t3, this.persistence = r3, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null;
        var i3 = t3.persistence_name || t3.token;
        if (this.window_id_storage_key = "ph_" + i3 + "_window_id", this.primary_window_exists_storage_key = "ph_" + i3 + "_primary_window_exists", this._canUseSessionStorage()) {
          var o2 = Me.parse(this.window_id_storage_key), s3 = Me.parse(this.primary_window_exists_storage_key);
          o2 && !s3 ? this._windowId = o2 : Me.remove(this.window_id_storage_key), Me.set(this.primary_window_exists_storage_key, true);
        }
        this._listenToReloadWindow();
      }
      return o(e3, [{ key: "_canUseSessionStorage", value: function() {
        return "memory" !== this.config.persistence && !this.persistence.disabled && Me.is_supported();
      } }, { key: "_setWindowId", value: function(e4) {
        e4 !== this._windowId && (this._windowId = e4, this._canUseSessionStorage() && Me.set(this.window_id_storage_key, e4));
      } }, { key: "_getWindowId", value: function() {
        return this._windowId ? this._windowId : this._canUseSessionStorage() ? Me.parse(this.window_id_storage_key) : null;
      } }, { key: "_setSessionId", value: function(e4, t3, r3) {
        e4 === this._sessionId && t3 === this._sessionActivityTimestamp && r3 === this._sessionStartTimestamp || (this._sessionStartTimestamp = r3, this._sessionActivityTimestamp = t3, this._sessionId = e4, this.persistence.register(s2({}, Be, [t3, e4, r3])));
      } }, { key: "_getSessionId", value: function() {
        if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp)
          return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
        var e4 = this.persistence.props[Be];
        return Array.isArray(e4) && 2 === e4.length && e4.push(e4[0]), e4 || [0, null, 0];
      } }, { key: "resetSessionId", value: function() {
        this._setSessionId(null, null, null);
      } }, { key: "_listenToReloadWindow", value: function() {
        var e4 = this;
        window.addEventListener("beforeunload", function() {
          e4._canUseSessionStorage() && Me.remove(e4.primary_window_exists_storage_key);
        });
      } }, { key: "checkAndGetSessionAndWindowId", value: function() {
        var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null) || (/* @__PURE__ */ new Date()).getTime(), r3 = f3(this._getSessionId(), 3), n2 = r3[0], i3 = r3[1], o2 = r3[2], s3 = this._getWindowId(), a2 = o2 && o2 > 0 && Math.abs(t3 - o2) > Cr;
        !i3 || !e4 && Math.abs(t3 - n2) > Ar || a2 ? (i3 = oe(), s3 = oe(), o2 = t3) : s3 || (s3 = oe());
        var c2 = 0 === n2 || !e4 || a2 ? t3 : n2, u2 = 0 === o2 ? (/* @__PURE__ */ new Date()).getTime() : o2;
        return this._setWindowId(s3), this._setSessionId(i3, c2, u2), { sessionId: i3, windowId: s3 };
      } }]), e3;
    }();
    var Mr = o(function e3(t3, r3, i3, o2) {
      n(this, e3), this.name = "posthog-js", this.setupOnce = function(e4) {
        e4(function(e5) {
          var n2, s3, a2;
          if ("error" !== e5.level || !t3.__loaded)
            return e5;
          e5.tags || (e5.tags = {});
          var c2 = t3.config.ui_host || t3.config.api_host;
          e5.tags["PostHog Person URL"] = c2 + "/person/" + t3.get_distinct_id(), t3.sessionRecordingStarted() && (e5.tags["PostHog Recording URL"] = c2 + "/recordings/" + t3.sessionManager.checkAndGetSessionAndWindowId(true).sessionId);
          var u2 = (null === (n2 = e5.exception) || void 0 === n2 ? void 0 : n2.values) || [], l2 = { $sentry_event_id: e5.event_id, $sentry_exception: e5.exception, $sentry_exception_message: null === (s3 = u2[0]) || void 0 === s3 ? void 0 : s3.value, $sentry_exception_type: null === (a2 = u2[0]) || void 0 === a2 ? void 0 : a2.type, $sentry_tags: e5.tags };
          return r3 && i3 && (l2.$sentry_url = (o2 || "https://sentry.io/organizations/") + r3 + "/issues/?project=" + i3 + "&query=" + e5.event_id), t3.capture("$exception", l2), e5;
        });
      };
    });
    var $r = function(e3) {
      var t3 = function(t4, r3) {
        t4.event.userId || t4.event.anonymousId === e3.get_distinct_id() || e3.reset(), t4.event.userId && t4.event.userId !== e3.get_distinct_id() && (e3.register({ distinct_id: t4.event.userId }), e3.reloadFeatureFlags());
        var n2 = e3._calculate_event_properties(r3, t4.event.properties);
        return t4.event.properties = Object.assign({}, n2, t4.event.properties), t4;
      };
      return { name: "PostHog JS", type: "enrichment", version: "1.0.0", isLoaded: function() {
        return true;
      }, load: function() {
        return Promise.resolve();
      }, track: function(e4) {
        return t3(e4, e4.event.event);
      }, page: function(e4) {
        return t3(e4, "$pageview");
      }, identify: function(e4) {
        return t3(e4, "$identify");
      }, screen: function(e4) {
        return t3(e4, "$screen");
      } };
    };
    var Rr = function() {
      function e3() {
        n(this, e3), s2(this, "_seenFirstPageView", false);
      }
      return o(e3, [{ key: "onPageview", value: function() {
        this._seenFirstPageView && (this._pageViewId = oe()), this._seenFirstPageView = true;
      } }, { key: "getPageViewId", value: function() {
        return this._pageViewId || (this._pageViewId = oe()), this._pageViewId;
      } }]), e3;
    }();
    !function(e3) {
      e3[e3.INIT_MODULE = 0] = "INIT_MODULE", e3[e3.INIT_SNIPPET = 1] = "INIT_SNIPPET";
    }(Fr || (Fr = {}));
    var jr = function() {
    };
    var qr = {};
    var Dr = "posthog";
    var Nr = x2.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    var Lr = !Nr && -1 === T.indexOf("MSIE") && -1 === T.indexOf("Mozilla");
    var Br = function() {
      var e3, t3, r3;
      return { api_host: "https://app.posthog.com", api_method: "POST", api_transport: "XHR", ui_host: null, token: "", autocapture: true, rageclick: true, cross_subdomain_cookie: -1 === (null == C || null === (e3 = C.location) || void 0 === e3 || null === (t3 = e3.hostname) || void 0 === t3 ? void 0 : t3.indexOf("herokuapp.com")), persistence: "cookie", persistence_name: "", cookie_name: "", loaded: jr, store_google: true, custom_campaign_params: [], save_referrer: true, test: false, verbose: false, img: false, capture_pageview: true, capture_pageleave: true, debug: false, cookie_expiration: 365, upgrade: false, disable_session_recording: false, disable_persistence: false, disable_cookie: false, enable_recording_console_log: void 0, secure_cookie: "https:" === (null == x2 || null === (r3 = x2.location) || void 0 === r3 ? void 0 : r3.protocol), ip: true, opt_out_capturing_by_default: false, opt_out_persistence_by_default: false, opt_out_capturing_persistence_type: "localStorage", opt_out_capturing_cookie_prefix: null, opt_in_site_apps: false, property_blacklist: [], respect_dnt: false, sanitize_properties: null, xhr_headers: {}, inapp_protocol: "//", inapp_link_new_window: false, request_batching: true, properties_string_max_length: 65535, session_recording: { blockClass: "ph-no-capture", blockSelector: null, ignoreClass: "ph-ignore-input", maskAllInputs: true, maskInputOptions: {}, maskInputFn: null, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true }, mask_all_element_attributes: false, mask_all_text: false, advanced_disable_decide: false, advanced_disable_toolbar_metrics: false, on_xhr_error: function(e4) {
        var t4 = "Bad HTTP status: " + e4.status + " " + e4.statusText;
        console.error(t4);
      }, get_device_id: function(e4) {
        return e4;
      }, _onCapture: jr, _capture_metrics: false, capture_performance: void 0, name: "posthog", callback_fn: "posthog._jsc", bootstrap: {}, disable_compression: false };
    };
    var Hr = function(e3, t3, r3, n2) {
      var i3, o2 = r3 !== Dr && Pr ? r3 ? Pr[r3] : void 0 : Pr, s3 = { initComplete: false, syncCode: false }, a2 = function(e4) {
        return function(t4) {
          s3[e4] || (s3[e4] = true, s3.initComplete && s3.syncCode && (null == n2 || n2(t4)));
        };
      };
      if (o2 && Sr === Fr.INIT_MODULE)
        i3 = o2;
      else {
        if (o2 && !U(o2))
          return void console.error("You have already initialized " + r3);
        i3 = new Ur();
      }
      if (i3._init(e3, t3, r3, a2("initComplete")), i3.toolbar.maybeLoadToolbar(), i3.sessionRecording = new St(i3), i3.sessionRecording.startRecordingIfEnabled(), i3.webPerformance = new Ot(i3), i3.webPerformance.startObservingIfEnabled(), i3.__autocapture = i3.get_config("autocapture"), Ze._setIsAutocaptureEnabled(i3), Ze._isAutocaptureEnabled) {
        i3.__autocapture = i3.get_config("autocapture");
        Ze.enabledForProject(i3.get_config("token"), 100, 100) ? Ze.isBrowserSupported() ? Ze.init(i3) : (i3.__autocapture = false, D.log("Disabling Automatic Event Collection because this browser is not supported")) : (i3.__autocapture = false, D.log("Not in active bucket: disabling Automatic Event Collection."));
      }
      return S2.DEBUG = S2.DEBUG || i3.get_config("debug"), void 0 !== o2 && U(o2) && (i3._execute_array.call(i3.people, o2.people), i3._execute_array(o2)), a2("syncCode")(i3), i3;
    };
    var Ur = function() {
      function e3() {
        var t3 = this;
        n(this, e3), this.config = Br(), this.compression = {}, this.decideEndpointWasHit = false, this.SentryIntegration = Mr, this.segmentIntegration = function() {
          return $r(t3);
        }, this.__captureHooks = [], this.__request_queue = [], this.__loaded = false, this.__loaded_recorder_version = void 0, this.__autocapture = void 0, this._jsc = function() {
        }, this.people = new lt(this), this.featureFlags = new _t(this), this.feature_flags = this.featureFlags, this.toolbar = new Mt(this), this.pageViewIdManager = new Rr(), this._captureMetrics = void 0, this._requestQueue = void 0, this._retryQueue = void 0, this.persistence = void 0, this.sessionPersistence = void 0, this.sessionManager = void 0;
      }
      return o(e3, [{ key: "init", value: function(e4, t3, r3) {
        if (Q(r3))
          console.error("You must name your new library: init(token, config, name)");
        else {
          if (r3 !== Dr) {
            var n2 = Hr(e4, t3, r3, function(e5) {
              Pr[r3] = e5, e5._loaded();
            });
            return Pr[r3] = n2, n2;
          }
          console.error("You must initialize the main posthog object right after you include the PostHog js snippet");
        }
      } }, { key: "_init", value: function(e4) {
        var r3, n2, i3 = this, o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s3 = arguments.length > 2 ? arguments[2] : void 0, a2 = arguments.length > 3 ? arguments[3] : void 0;
        this.__loaded = true, this.config = {}, this._triggered_notifs = [];
        var c2, u2 = { segmentRegister: false, syncCode: false }, l2 = function(e5) {
          return function() {
            u2[e5] || (u2[e5] = true, u2.segmentRegister && u2.syncCode && (null == a2 || a2(i3)));
          };
        };
        (this.set_config(H({}, Br(), o2, { name: s3, token: e4, callback_fn: (s3 === Dr ? s3 : Dr + "." + s3) + "._jsc" })), this._jsc = function() {
        }, null != x2 && null !== (r3 = x2.rrweb) && void 0 !== r3 && r3.record || null != x2 && x2.rrwebRecord) && (this.__loaded_recorder_version = null == x2 || null === (c2 = x2.rrweb) || void 0 === c2 ? void 0 : c2.version);
        if (this._captureMetrics = new jt(this.get_config("_capture_metrics")), this._requestQueue = new Rt(this._captureMetrics, this._handle_queued_event.bind(this)), this._retryQueue = new xr(this._captureMetrics, this.get_config("on_xhr_error")), this.__captureHooks = [], this.__request_queue = [], this.persistence = new Je(this.config), this.sessionManager = new Tr(this.config, this.persistence), this.sessionPersistence = "sessionStorage" === this.config.persistence ? this.persistence : new Je(t2(t2({}, this.config), {}, { persistence: "sessionStorage" })), this._gdpr_init(), o2.segment ? (this.config.get_device_id = function() {
          return o2.segment.user().anonymousId();
        }, o2.segment.user().id() && (this.register({ distinct_id: o2.segment.user().id() }), this.persistence.set_user_state("identified")), o2.segment.register(this.segmentIntegration()).then(l2("segmentRegister"))) : l2("segmentRegister")(), void 0 !== (null === (n2 = o2.bootstrap) || void 0 === n2 ? void 0 : n2.distinctID)) {
          var d2, p2, f4 = this.get_config("get_device_id")(oe()), h3 = null !== (d2 = o2.bootstrap) && void 0 !== d2 && d2.isIdentifiedID ? f4 : o2.bootstrap.distinctID;
          this.persistence.set_user_state(null !== (p2 = o2.bootstrap) && void 0 !== p2 && p2.isIdentifiedID ? "identified" : "anonymous"), this.register({ distinct_id: o2.bootstrap.distinctID, $device_id: h3 });
        }
        if (this._hasBootstrappedFeatureFlags()) {
          var _2, g2, v2 = Object.keys((null === (_2 = o2.bootstrap) || void 0 === _2 ? void 0 : _2.featureFlags) || {}).filter(function(e5) {
            var t3, r4;
            return !(null === (t3 = o2.bootstrap) || void 0 === t3 || null === (r4 = t3.featureFlags) || void 0 === r4 || !r4[e5]);
          }).reduce(function(e5, t3) {
            var r4, n3;
            return e5[t3] = (null === (r4 = o2.bootstrap) || void 0 === r4 || null === (n3 = r4.featureFlags) || void 0 === n3 ? void 0 : n3[t3]) || false, e5;
          }, {}), y2 = Object.keys((null === (g2 = o2.bootstrap) || void 0 === g2 ? void 0 : g2.featureFlagPayloads) || {}).filter(function(e5) {
            return v2[e5];
          }).reduce(function(e5, t3) {
            var r4, n3, i4, s4;
            null !== (r4 = o2.bootstrap) && void 0 !== r4 && null !== (n3 = r4.featureFlagPayloads) && void 0 !== n3 && n3[t3] && (e5[t3] = null === (i4 = o2.bootstrap) || void 0 === i4 || null === (s4 = i4.featureFlagPayloads) || void 0 === s4 ? void 0 : s4[t3]);
            return e5;
          }, {});
          this.featureFlags.receivedFeatureFlags({ featureFlags: v2, featureFlagPayloads: y2 });
        }
        if (!this.get_distinct_id()) {
          var m3 = this.get_config("get_device_id")(oe());
          this.register_once({ distinct_id: m3, $device_id: m3 }, ""), this.persistence.set_user_state("anonymous");
        }
        x2.addEventListener && x2.addEventListener("onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), l2("syncCode")();
      } }, { key: "_loaded", value: function() {
        this.featureFlags.setReloadingPaused(true);
        try {
          this.get_config("loaded")(this);
        } catch (e4) {
          console.error("`loaded` function failed", e4);
        }
        this._start_queue_if_opted_in(), this.get_config("capture_pageview") && this.capture("$pageview", {}, { send_instantly: true }), this.get_config("advanced_disable_decide") || new At(this).call(), this.featureFlags.resetRequestQueue(), this.featureFlags.setReloadingPaused(false);
      } }, { key: "_start_queue_if_opted_in", value: function() {
        this.has_opted_out_capturing() || this.get_config("request_batching") && this._requestQueue.poll();
      } }, { key: "_dom_loaded", value: function() {
        var e4 = this;
        this.has_opted_out_capturing() || B(this.__request_queue, function(t3) {
          e4._send_request.apply(e4, h2(t3));
        }), this.__request_queue = [], this._start_queue_if_opted_in();
      } }, { key: "_prepare_callback", value: function(e4, t3) {
        if (Q(e4))
          return null;
        if (Nr)
          return function(r4) {
            e4(r4, t3);
          };
        var r3 = this._jsc, n2 = "" + Math.floor(1e8 * Math.random()), i3 = this.get_config("callback_fn") + "[" + n2 + "]";
        return r3[n2] = function(i4) {
          delete r3[n2], e4(i4, t3);
        }, i3;
      } }, { key: "_handle_unload", value: function() {
        this.get_config("request_batching") ? (this.get_config("capture_pageview") && this.get_config("capture_pageleave") && this.capture("$pageleave"), this.get_config("_capture_metrics") && (this._requestQueue.updateUnloadMetrics(), this.capture("$capture_metrics", this._captureMetrics.metrics)), this._requestQueue.unload(), this._retryQueue.unload()) : this.get_config("capture_pageview") && this.get_config("capture_pageleave") && this.capture("$pageleave", null, { transport: "sendBeacon" });
      } }, { key: "_handle_queued_event", value: function(e4, t3, r3) {
        var n2 = JSON.stringify(t3);
        this.__compress_and_send_json_request(e4, n2, r3 || qr, jr);
      } }, { key: "__compress_and_send_json_request", value: function(e4, r3, n2, i3) {
        var o2, s3 = function(e5, r4, n3) {
          return e5 === exports.Compression.LZ64 ? [{ data: F2.compressToBase64(r4), compression: exports.Compression.LZ64 }, n3] : e5 === exports.Compression.GZipJS ? [wr(kr(r4), { mtime: 0 }), t2(t2({}, n3), {}, { blob: true, urlQueryArgs: { compression: exports.Compression.GZipJS } })] : [{ data: re(r4) }, n3];
        }((o2 = this.compression)[exports.Compression.GZipJS] ? exports.Compression.GZipJS : o2[exports.Compression.LZ64] ? exports.Compression.LZ64 : exports.Compression.Base64, r3, n2), a2 = f3(s3, 2), c2 = a2[0], u2 = a2[1];
        this._send_request(e4, c2, u2, i3);
      } }, { key: "_send_request", value: function(e4, r3, n2, i3) {
        if (Lr)
          this.__request_queue.push([e4, r3, n2, i3]);
        else {
          var o2 = { method: this.get_config("api_method"), transport: this.get_config("api_transport"), verbose: this.get_config("verbose") };
          n2 = H(o2, n2 || {}), Nr || (n2.method = "GET");
          var s3 = "sendBeacon" in x2.navigator && "sendBeacon" === n2.transport;
          if (e4 = Ir(e4, n2.urlQueryArgs || {}, { ip: this.get_config("ip") }), G(r3) && this.get_config("img")) {
            var a2 = C.createElement("img");
            a2.src = e4, C.body.appendChild(a2);
          } else if (s3)
            try {
              x2.navigator.sendBeacon(e4, Er(r3, t2(t2({}, n2), {}, { sendBeacon: true })));
            } catch (e5) {
              this.get_config("debug") && console.error(e5);
            }
          else if (Nr)
            try {
              Or({ url: e4, data: r3, headers: this.get_config("xhr_headers"), options: n2, captureMetrics: this._captureMetrics, callback: i3, retriesPerformedSoFar: 0, retryQueue: this._retryQueue, onXHRError: this.get_config("on_xhr_error") });
            } catch (e5) {
              console.error(e5);
            }
          else {
            var c2, u2 = C.createElement("script");
            u2.type = "text/javascript", u2.async = true, u2.defer = true, u2.src = e4;
            var l2 = C.getElementsByTagName("script")[0];
            null === (c2 = l2.parentNode) || void 0 === c2 || c2.insertBefore(u2, l2);
          }
        }
      } }, { key: "_execute_array", value: function(e4) {
        var t3, r3 = this, n2 = [], i3 = [], o2 = [];
        B(e4, function(e5) {
          e5 && (t3 = e5[0], U(t3) ? o2.push(e5) : "function" == typeof e5 ? e5.call(r3) : U(e5) && "alias" === t3 ? n2.push(e5) : U(e5) && -1 !== t3.indexOf("capture") && "function" == typeof r3[t3] ? o2.push(e5) : i3.push(e5));
        });
        var s3 = function(e5, t4) {
          B(e5, function(e6) {
            if (U(e6[0])) {
              var r4 = t4;
              L(e6, function(e7) {
                r4 = r4[e7[0]].apply(r4, e7.slice(1));
              });
            } else
              this[e6[0]].apply(this, e6.slice(1));
          }, t4);
        };
        s3(n2, this), s3(i3, this), s3(o2, this);
      } }, { key: "_hasBootstrappedFeatureFlags", value: function() {
        var e4, t3;
        return (null === (e4 = this.config.bootstrap) || void 0 === e4 ? void 0 : e4.featureFlags) && Object.keys(null === (t3 = this.config.bootstrap) || void 0 === t3 ? void 0 : t3.featureFlags).length > 0 || false;
      } }, { key: "push", value: function(e4) {
        this._execute_array([e4]);
      } }, { key: "capture", value: function(e4, t3) {
        var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : qr;
        if (this.__loaded && !at(this, false)) {
          this._captureMetrics.incr("capture"), "$snapshot" === e4 && this._captureMetrics.incr("snapshot");
          var n2 = (r3 = r3 || qr).transport;
          if (n2 && (r3.transport = n2), Q(e4) || "string" != typeof e4)
            console.error("No event name provided to posthog.capture");
          else if (!se(T)) {
            this.sessionPersistence.update_search_keyword(), this.get_config("store_google") && this.sessionPersistence.update_campaign_params(), this.get_config("save_referrer") && this.sessionPersistence.update_referrer_info();
            var i3 = { event: e4, properties: this._calculate_event_properties(e4, t3 || {}) };
            "$identify" === e4 && (i3.$set = r3.$set, i3.$set_once = r3.$set_once), (i3 = te(i3, r3._noTruncate ? null : this.get_config("properties_string_max_length"))).timestamp = r3.timestamp || /* @__PURE__ */ new Date(), this.get_config("debug") && D.log("PostHog.js send", i3);
            var o2 = JSON.stringify(i3), s3 = this.get_config("api_host") + (r3.endpoint || "/e/"), a2 = r3 !== qr;
            return !this.get_config("request_batching") || a2 && !r3._batchKey || r3.send_instantly ? this.__compress_and_send_json_request(s3, o2, r3) : this._requestQueue.enqueue(s3, i3, r3), this._invokeCaptureHooks(e4, i3), i3;
          }
        }
      } }, { key: "_addCaptureHook", value: function(e4) {
        this.__captureHooks.push(e4);
      } }, { key: "_invokeCaptureHooks", value: function(e4, t3) {
        this.config._onCapture(e4, t3), L(this.__captureHooks, function(t4) {
          return t4(e4);
        });
      } }, { key: "_calculate_event_properties", value: function(e4, r3) {
        var n2, i3 = this.persistence.remove_event_timer(e4), o2 = t2({}, r3);
        if (o2.token = this.get_config("token"), "$snapshot" === e4) {
          var s3 = t2(t2({}, this.persistence.properties()), this.sessionPersistence.properties());
          return o2.distinct_id = s3.distinct_id, o2;
        }
        var a2 = de.properties();
        if (this.sessionManager) {
          var c2 = this.sessionManager.checkAndGetSessionAndWindowId(), u2 = c2.sessionId, l2 = c2.windowId;
          o2.$session_id = u2, o2.$window_id = l2;
        }
        if (null !== (n2 = this.webPerformance) && void 0 !== n2 && n2.isEnabled && ("$pageview" === e4 && this.pageViewIdManager.onPageview(), o2 = H(o2, { $pageview_id: this.pageViewIdManager.getPageViewId() })), "$performance_event" === e4) {
          var d2 = this.persistence.properties();
          return o2.distinct_id = d2.distinct_id, o2.$current_url = a2.$current_url, o2;
        }
        if (void 0 !== i3) {
          var p2 = (/* @__PURE__ */ new Date()).getTime() - i3;
          o2.$duration = parseFloat((p2 / 1e3).toFixed(3));
        }
        o2 = H({}, de.properties(), this.persistence.properties(), this.sessionPersistence.properties(), o2);
        var f4 = this.get_config("property_blacklist");
        U(f4) ? L(f4, function(e5) {
          delete o2[e5];
        }) : console.error("Invalid value for property_blacklist config: " + f4);
        var h3 = this.get_config("sanitize_properties");
        return h3 && (o2 = h3(o2, e4)), o2;
      } }, { key: "register", value: function(e4, t3) {
        this.persistence.register(e4, t3);
      } }, { key: "register_once", value: function(e4, t3, r3) {
        this.persistence.register_once(e4, t3, r3);
      } }, { key: "register_for_session", value: function(e4) {
        this.sessionPersistence.register(e4);
      } }, { key: "unregister", value: function(e4) {
        this.persistence.unregister(e4);
      } }, { key: "unregister_for_session", value: function(e4) {
        this.sessionPersistence.unregister(e4);
      } }, { key: "_register_single", value: function(e4, t3) {
        this.register(s2({}, e4, t3));
      } }, { key: "getFeatureFlag", value: function(e4, t3) {
        return this.featureFlags.getFeatureFlag(e4, t3);
      } }, { key: "getFeatureFlagPayload", value: function(e4) {
        var t3 = this.featureFlags.getFeatureFlagPayload(e4);
        try {
          return JSON.parse(t3);
        } catch (e5) {
          return t3;
        }
      } }, { key: "isFeatureEnabled", value: function(e4, t3) {
        return this.featureFlags.isFeatureEnabled(e4, t3);
      } }, { key: "reloadFeatureFlags", value: function() {
        this.featureFlags.reloadFeatureFlags();
      } }, { key: "updateEarlyAccessFeatureEnrollment", value: function(e4, t3) {
        this.featureFlags.updateEarlyAccessFeatureEnrollment(e4, t3);
      } }, { key: "getEarlyAccessFeatures", value: function(e4) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return this.featureFlags.getEarlyAccessFeatures(e4, t3);
      } }, { key: "onFeatureFlags", value: function(e4) {
        return this.featureFlags.onFeatureFlags(e4);
      } }, { key: "identify", value: function(e4, t3, r3) {
        if (e4) {
          this._captureMetrics.incr("identify");
          var n2 = this.get_distinct_id();
          if (this.register({ $user_id: e4 }), !this.get_property("$device_id")) {
            var i3 = n2;
            this.register_once({ $had_persisted_distinct_id: true, $device_id: i3 }, "");
          }
          e4 !== n2 && e4 !== this.get_property(Re) && (this.unregister(Re), this.register({ distinct_id: e4 }));
          var o2 = "anonymous" === this.persistence.get_user_state();
          e4 !== n2 && o2 ? (this.persistence.set_user_state("identified"), this.capture("$identify", { distinct_id: e4, $anon_distinct_id: n2 }, { $set: t3 || {}, $set_once: r3 || {} }), this.featureFlags.setAnonymousDistinctId(n2)) : (t3 && this.people.set(t3), r3 && this.people.set_once(r3)), e4 !== n2 && this.reloadFeatureFlags();
        } else
          console.error("Unique user id has not been set in posthog.identify");
      } }, { key: "group", value: function(e4, r3, n2) {
        if (e4 && r3) {
          this._captureMetrics.incr("group");
          var i3 = this.getGroups();
          i3[e4] !== r3 && this.resetGroupPropertiesForFlags(e4), this.register({ $groups: t2(t2({}, i3), {}, s2({}, e4, r3)) }), n2 && (this.capture("$groupidentify", { $group_type: e4, $group_key: r3, $group_set: n2 }), this.setGroupPropertiesForFlags(s2({}, e4, n2))), i3[e4] === r3 || n2 || this.reloadFeatureFlags();
        } else
          console.error("posthog.group requires a group type and group key");
      } }, { key: "resetGroups", value: function() {
        this.register({ $groups: {} }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
      } }, { key: "setPersonPropertiesForFlags", value: function(e4) {
        var t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.featureFlags.setPersonPropertiesForFlags(e4, t3);
      } }, { key: "resetPersonPropertiesForFlags", value: function() {
        this.featureFlags.resetPersonPropertiesForFlags();
      } }, { key: "setGroupPropertiesForFlags", value: function(e4) {
        var t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.featureFlags.setGroupPropertiesForFlags(e4, t3);
      } }, { key: "resetGroupPropertiesForFlags", value: function(e4) {
        this.featureFlags.resetGroupPropertiesForFlags(e4);
      } }, { key: "reset", value: function(e4) {
        var t3 = this.get_property("$device_id");
        this.persistence.clear(), this.sessionPersistence.clear(), this.persistence.set_user_state("anonymous"), this.sessionManager.resetSessionId();
        var r3 = this.get_config("get_device_id")(oe());
        this.register_once({ distinct_id: r3, $device_id: e4 ? r3 : t3 }, "");
      } }, { key: "get_distinct_id", value: function() {
        return this.get_property("distinct_id");
      } }, { key: "getGroups", value: function() {
        return this.get_property("$groups") || {};
      } }, { key: "alias", value: function(e4, t3) {
        return e4 === this.get_property($e) ? (D.critical("Attempting to create alias for existing People user - aborting."), -2) : (Q(t3) && (t3 = this.get_distinct_id()), e4 !== t3 ? (this._register_single(Re, e4), this.capture("$create_alias", { alias: e4, distinct_id: t3 })) : (console.error("alias matches current distinct_id - skipping api call."), this.identify(e4), -1));
      } }, { key: "set_config", value: function(e4) {
        var r3 = t2({}, this.config);
        G(e4) && (H(this.config, e4), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), this.sessionPersistence && this.sessionPersistence.update_config(this.config), Oe.is_supported() && "true" === Oe.get("ph_debug") && (this.config.debug = true), this.get_config("debug") && (S2.DEBUG = true), this.sessionRecording && void 0 !== e4.disable_session_recording && r3.disable_session_recording !== e4.disable_session_recording && (e4.disable_session_recording ? this.sessionRecording.stopRecording() : this.sessionRecording.startRecordingIfEnabled()));
      } }, { key: "startSessionRecording", value: function() {
        this.set_config({ disable_session_recording: false });
      } }, { key: "stopSessionRecording", value: function() {
        this.set_config({ disable_session_recording: true });
      } }, { key: "sessionRecordingStarted", value: function() {
        var e4;
        return !(null === (e4 = this.sessionRecording) || void 0 === e4 || !e4.started());
      } }, { key: "loadToolbar", value: function(e4) {
        return this.toolbar.loadToolbar(e4);
      } }, { key: "get_config", value: function(e4) {
        var t3;
        return null === (t3 = this.config) || void 0 === t3 ? void 0 : t3[e4];
      } }, { key: "get_property", value: function(e4) {
        return this.persistence.props[e4];
      } }, { key: "getSessionProperty", value: function(e4) {
        return this.sessionPersistence.props[e4];
      } }, { key: "toString", value: function() {
        var e4, t3 = null !== (e4 = this.get_config("name")) && void 0 !== e4 ? e4 : Dr;
        return t3 !== Dr && (t3 = Dr + "." + t3), t3;
      } }, { key: "_gdpr_init", value: function() {
        "localStorage" === this.get_config("opt_out_capturing_persistence_type") && Oe.is_supported() && (!this.has_opted_in_capturing() && this.has_opted_in_capturing({ persistence_type: "cookie" }) && this.opt_in_capturing({ enable_persistence: false }), !this.has_opted_out_capturing() && this.has_opted_out_capturing({ persistence_type: "cookie" }) && this.opt_out_capturing({ clear_persistence: false }), this.clear_opt_in_out_capturing({ persistence_type: "cookie", enable_persistence: false })), this.has_opted_out_capturing() ? this._gdpr_update_persistence({ clear_persistence: true }) : this.has_opted_in_capturing() || !this.get_config("opt_out_capturing_by_default") && !Ie.get("ph_optout") || (Ie.remove("ph_optout"), this.opt_out_capturing({ clear_persistence: this.get_config("opt_out_persistence_by_default") }));
      } }, { key: "_gdpr_update_persistence", value: function(e4) {
        var t3;
        if (e4 && e4.clear_persistence)
          t3 = true;
        else {
          if (!e4 || !e4.enable_persistence)
            return;
          t3 = false;
        }
        this.get_config("disable_persistence") || this.persistence.disabled === t3 || this.persistence.set_disabled(t3), this.get_config("disable_persistence") || this.sessionPersistence.disabled === t3 || this.sessionPersistence.set_disabled(t3);
      } }, { key: "_gdpr_call_func", value: function(e4, t3) {
        return t3 = H({ capture: this.capture.bind(this), persistence_type: this.get_config("opt_out_capturing_persistence_type"), cookie_prefix: this.get_config("opt_out_capturing_cookie_prefix"), cookie_expiration: this.get_config("cookie_expiration"), cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"), secure_cookie: this.get_config("secure_cookie") }, t3 || {}), Oe.is_supported() || "localStorage" !== t3.persistence_type || (t3.persistence_type = "cookie"), e4(this.get_config("token"), { capture: t3.capture, captureEventName: t3.capture_event_name, captureProperties: t3.capture_properties, persistenceType: t3.persistence_type, persistencePrefix: t3.cookie_prefix, cookieExpiration: t3.cookie_expiration, crossSubdomainCookie: t3.cross_subdomain_cookie, secureCookie: t3.secure_cookie });
      } }, { key: "opt_in_capturing", value: function(e4) {
        e4 = H({ enable_persistence: true }, e4 || {}), this._gdpr_call_func(Ye, e4), this._gdpr_update_persistence(e4);
      } }, { key: "opt_out_capturing", value: function(e4) {
        var t3 = H({ clear_persistence: true }, e4 || {});
        this._gdpr_call_func(Ke, t3), this._gdpr_update_persistence(t3);
      } }, { key: "has_opted_in_capturing", value: function(e4) {
        return this._gdpr_call_func(et, e4);
      } }, { key: "has_opted_out_capturing", value: function(e4) {
        return this._gdpr_call_func(tt, e4);
      } }, { key: "clear_opt_in_out_capturing", value: function(e4) {
        var t3 = H({ enable_persistence: true }, null != e4 ? e4 : {});
        this._gdpr_call_func(rt, t3), this._gdpr_update_persistence(t3);
      } }, { key: "debug", value: function(e4) {
        false === e4 ? (x2.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({ debug: false })) : (x2.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({ debug: true }));
      } }, { key: "decodeLZ64", value: function(e4) {
        return F2.decompressFromBase64(e4 || null);
      } }]), e3;
    }();
    !function(e3, t3) {
      for (var r3 = 0; r3 < t3.length; r3++)
        e3.prototype[t3[r3]] = Y(e3.prototype[t3[r3]]);
    }(Ur, ["identify"]);
    var Vr = {};
    var Wr = function() {
      Pr.init = function(e3, t3, r3) {
        if (r3)
          return Pr[r3] || (Pr[r3] = Vr[r3] = Hr(e3 || "", t3 || {}, r3, function(e4) {
            Pr[r3] = Vr[r3] = e4, e4._loaded();
          })), Pr[r3];
        var n2 = Pr;
        return Vr[Dr] ? n2 = Vr[Dr] : e3 && (n2 = Hr(e3, t3 || {}, Dr, function(e4) {
          Vr[Dr] = e4, e4._loaded();
        }), Vr[Dr] = n2), Pr = n2, Sr === Fr.INIT_SNIPPET && (x2[Dr] = Pr), L(Vr, function(e4, t4) {
          t4 !== Dr && (Pr[t4] = e4);
        }), n2;
      };
    };
    var Gr = function() {
      function e3() {
        e3.done || (e3.done = true, Lr = false, L(Vr, function(e4) {
          e4._dom_loaded();
        }));
      }
      C.addEventListener && ("complete" === C.readyState ? e3() : C.addEventListener("DOMContentLoaded", e3, false)), ue(x2, "load", e3, true);
    };
    var Qr = (Sr = Fr.INIT_MODULE, Pr = new Ur(), Wr(), Pr.init(), Gr(), Pr);
    exports.PostHog = Ur, exports.default = Qr, exports.posthog = Qr;
  }
});

// ../../node_modules/rusha/dist/rusha.js
var require_rusha = __commonJS({
  "../../node_modules/rusha/dist/rusha.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Rusha"] = factory();
      else
        root["Rusha"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 3);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var RushaCore = __webpack_require__(5);
            var _require = __webpack_require__(1), toHex = _require.toHex, ceilHeapSize = _require.ceilHeapSize;
            var conv = __webpack_require__(6);
            var padlen = function(len) {
              for (len += 9; len % 64 > 0; len += 1) {
              }
              return len;
            };
            var padZeroes = function(bin, len) {
              var h8 = new Uint8Array(bin.buffer);
              var om = len % 4, align = len - om;
              switch (om) {
                case 0:
                  h8[align + 3] = 0;
                case 1:
                  h8[align + 2] = 0;
                case 2:
                  h8[align + 1] = 0;
                case 3:
                  h8[align + 0] = 0;
              }
              for (var i2 = (len >> 2) + 1; i2 < bin.length; i2++) {
                bin[i2] = 0;
              }
            };
            var padData = function(bin, chunkLen, msgLen) {
              bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
              bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen / (1 << 29) | 0;
              bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
            };
            var getRawDigest = function(heap, padMaxChunkLen) {
              var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
              var out = new Int32Array(5);
              var arr = new DataView(out.buffer);
              arr.setInt32(0, io[0], false);
              arr.setInt32(4, io[1], false);
              arr.setInt32(8, io[2], false);
              arr.setInt32(12, io[3], false);
              arr.setInt32(16, io[4], false);
              return out;
            };
            var Rusha = function() {
              function Rusha2(chunkSize) {
                _classCallCheck(this, Rusha2);
                chunkSize = chunkSize || 64 * 1024;
                if (chunkSize % 64 > 0) {
                  throw new Error("Chunk size must be a multiple of 128 bit");
                }
                this._offset = 0;
                this._maxChunkLen = chunkSize;
                this._padMaxChunkLen = padlen(chunkSize);
                this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
                this._h32 = new Int32Array(this._heap);
                this._h8 = new Int8Array(this._heap);
                this._core = new RushaCore({ Int32Array }, {}, this._heap);
              }
              Rusha2.prototype._initState = function _initState(heap, padMsgLen) {
                this._offset = 0;
                var io = new Int32Array(heap, padMsgLen + 320, 5);
                io[0] = 1732584193;
                io[1] = -271733879;
                io[2] = -1732584194;
                io[3] = 271733878;
                io[4] = -1009589776;
              };
              Rusha2.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
                var padChunkLen = padlen(chunkLen);
                var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
                padZeroes(view, chunkLen);
                padData(view, chunkLen, msgLen);
                return padChunkLen;
              };
              Rusha2.prototype._write = function _write(data, chunkOffset, chunkLen, off) {
                conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);
              };
              Rusha2.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
                var padChunkLen = chunkLen;
                this._write(data, chunkOffset, chunkLen);
                if (finalize) {
                  padChunkLen = this._padChunk(chunkLen, msgLen);
                }
                this._core.hash(padChunkLen, this._padMaxChunkLen);
              };
              Rusha2.prototype.rawDigest = function rawDigest(str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                this._initState(this._heap, this._padMaxChunkLen);
                var chunkOffset = 0, chunkLen = this._maxChunkLen;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                  this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(this._heap, this._padMaxChunkLen);
              };
              Rusha2.prototype.digest = function digest(str) {
                return toHex(this.rawDigest(str).buffer);
              };
              Rusha2.prototype.digestFromString = function digestFromString(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromBuffer = function digestFromBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.resetState = function resetState() {
                this._initState(this._heap, this._padMaxChunkLen);
                return this;
              };
              Rusha2.prototype.append = function append(chunk) {
                var chunkOffset = 0;
                var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
                var turnOffset = this._offset % this._maxChunkLen;
                var inputLen = void 0;
                this._offset += chunkLen;
                while (chunkOffset < chunkLen) {
                  inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);
                  this._write(chunk, chunkOffset, inputLen, turnOffset);
                  turnOffset += inputLen;
                  chunkOffset += inputLen;
                  if (turnOffset === this._maxChunkLen) {
                    this._core.hash(this._maxChunkLen, this._padMaxChunkLen);
                    turnOffset = 0;
                  }
                }
                return this;
              };
              Rusha2.prototype.getState = function getState() {
                var turnOffset = this._offset % this._maxChunkLen;
                var heap = void 0;
                if (!turnOffset) {
                  var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
                } else {
                  heap = this._heap.slice(0);
                }
                return {
                  offset: this._offset,
                  heap
                };
              };
              Rusha2.prototype.setState = function setState(state) {
                this._offset = state.offset;
                if (state.heap.byteLength === 20) {
                  var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  io.set(new Int32Array(state.heap));
                } else {
                  this._h32.set(new Int32Array(state.heap));
                }
                return this;
              };
              Rusha2.prototype.rawEnd = function rawEnd() {
                var msgLen = this._offset;
                var chunkLen = msgLen % this._maxChunkLen;
                var padChunkLen = this._padChunk(chunkLen, msgLen);
                this._core.hash(padChunkLen, this._padMaxChunkLen);
                var result = getRawDigest(this._heap, this._padMaxChunkLen);
                this._initState(this._heap, this._padMaxChunkLen);
                return result;
              };
              Rusha2.prototype.end = function end() {
                return toHex(this.rawEnd().buffer);
              };
              return Rusha2;
            }();
            module2.exports = Rusha;
            module2.exports._core = RushaCore;
          },
          /* 1 */
          /***/
          function(module2, exports2) {
            var precomputedHex = new Array(256);
            for (var i2 = 0; i2 < 256; i2++) {
              precomputedHex[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
            }
            module2.exports.toHex = function(arrayBuffer) {
              var binarray = new Uint8Array(arrayBuffer);
              var res = new Array(arrayBuffer.byteLength);
              for (var _i = 0; _i < res.length; _i++) {
                res[_i] = precomputedHex[binarray[_i]];
              }
              return res.join("");
            };
            module2.exports.ceilHeapSize = function(v) {
              var p = 0;
              if (v <= 65536)
                return 65536;
              if (v < 16777216) {
                for (p = 1; p < v; p = p << 1) {
                }
              } else {
                for (p = 16777216; p < v; p += 16777216) {
                }
              }
              return p;
            };
            module2.exports.isDedicatedWorkerScope = function(self2) {
              var isRunningInWorker = "WorkerGlobalScope" in self2 && self2 instanceof self2.WorkerGlobalScope;
              var isRunningInSharedWorker = "SharedWorkerGlobalScope" in self2 && self2 instanceof self2.SharedWorkerGlobalScope;
              var isRunningInServiceWorker = "ServiceWorkerGlobalScope" in self2 && self2 instanceof self2.ServiceWorkerGlobalScope;
              return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
            };
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = function() {
              var Rusha = __webpack_require__(0);
              var hashData = function(hasher, data, cb) {
                try {
                  return cb(null, hasher.digest(data));
                } catch (e2) {
                  return cb(e2);
                }
              };
              var hashFile = function(hasher, readTotal, blockSize, file, cb) {
                var reader = new self.FileReader();
                reader.onloadend = function onloadend() {
                  if (reader.error) {
                    return cb(reader.error);
                  }
                  var buffer = reader.result;
                  readTotal += reader.result.byteLength;
                  try {
                    hasher.append(buffer);
                  } catch (e2) {
                    cb(e2);
                    return;
                  }
                  if (readTotal < file.size) {
                    hashFile(hasher, readTotal, blockSize, file, cb);
                  } else {
                    cb(null, hasher.end());
                  }
                };
                reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
              };
              var workerBehaviourEnabled = true;
              self.onmessage = function(event) {
                if (!workerBehaviourEnabled) {
                  return;
                }
                var data = event.data.data, file = event.data.file, id = event.data.id;
                if (typeof id === "undefined")
                  return;
                if (!file && !data)
                  return;
                var blockSize = event.data.blockSize || 4 * 1024 * 1024;
                var hasher = new Rusha(blockSize);
                hasher.resetState();
                var done = function(err, hash) {
                  if (!err) {
                    self.postMessage({ id, hash });
                  } else {
                    self.postMessage({ id, error: err.name });
                  }
                };
                if (data)
                  hashData(hasher, data, done);
                if (file)
                  hashFile(hasher, 0, blockSize, file, done);
              };
              return function() {
                workerBehaviourEnabled = false;
              };
            };
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var work = __webpack_require__(4);
            var Rusha = __webpack_require__(0);
            var createHash = __webpack_require__(7);
            var runWorker = __webpack_require__(2);
            var _require = __webpack_require__(1), isDedicatedWorkerScope = _require.isDedicatedWorkerScope;
            var isRunningInDedicatedWorker = typeof self !== "undefined" && isDedicatedWorkerScope(self);
            Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function() {
            };
            Rusha.createWorker = function() {
              var worker = work(
                /*require.resolve*/
                2
              );
              var terminate = worker.terminate;
              worker.terminate = function() {
                URL.revokeObjectURL(worker.objectURL);
                terminate.call(worker);
              };
              return worker;
            };
            Rusha.createHash = createHash;
            module2.exports = Rusha;
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function webpackBootstrapFunc(modules) {
              var installedModules = {};
              function __webpack_require__2(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module3 = installedModules[moduleId] = {
                  /******/
                  i: moduleId,
                  /******/
                  l: false,
                  /******/
                  exports: {}
                  /******/
                };
                modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                module3.l = true;
                return module3.exports;
              }
              __webpack_require__2.m = modules;
              __webpack_require__2.c = installedModules;
              __webpack_require__2.i = function(value) {
                return value;
              };
              __webpack_require__2.d = function(exports3, name, getter) {
                if (!__webpack_require__2.o(exports3, name)) {
                  Object.defineProperty(exports3, name, {
                    /******/
                    configurable: false,
                    /******/
                    enumerable: true,
                    /******/
                    get: getter
                    /******/
                  });
                }
              };
              __webpack_require__2.r = function(exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
              };
              __webpack_require__2.n = function(module3) {
                var getter = module3 && module3.__esModule ? (
                  /******/
                  function getDefault() {
                    return module3["default"];
                  }
                ) : (
                  /******/
                  function getModuleExports() {
                    return module3;
                  }
                );
                __webpack_require__2.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __webpack_require__2.p = "/";
              __webpack_require__2.oe = function(err) {
                console.error(err);
                throw err;
              };
              var f3 = __webpack_require__2(__webpack_require__2.s = ENTRY_MODULE);
              return f3.default || f3;
            }
            var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
            var dependencyRegExp = "\\((/\\*.*?\\*/)?s?.*?(" + moduleNameReqExp + ").*?\\)";
            function quoteRegExp(str) {
              return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
            }
            function getModuleDependencies(sources, module3, queueName) {
              var retval = {};
              retval[queueName] = [];
              var fnString = module3.toString();
              var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
              if (!wrapperSignature)
                return retval;
              var webpackRequireName = wrapperSignature[1];
              var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
              var match;
              while (match = re.exec(fnString)) {
                if (match[3] === "dll-reference")
                  continue;
                retval[queueName].push(match[3]);
              }
              re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
              while (match = re.exec(fnString)) {
                if (!sources[match[2]]) {
                  retval[queueName].push(match[1]);
                  sources[match[2]] = __webpack_require__(match[1]).m;
                }
                retval[match[2]] = retval[match[2]] || [];
                retval[match[2]].push(match[4]);
              }
              return retval;
            }
            function hasValuesInQueues(queues) {
              var keys = Object.keys(queues);
              return keys.reduce(function(hasValues, key) {
                return hasValues || queues[key].length > 0;
              }, false);
            }
            function getRequiredModules(sources, moduleId) {
              var modulesQueue = {
                main: [moduleId]
              };
              var requiredModules = {
                main: []
              };
              var seenModules = {
                main: {}
              };
              while (hasValuesInQueues(modulesQueue)) {
                var queues = Object.keys(modulesQueue);
                for (var i2 = 0; i2 < queues.length; i2++) {
                  var queueName = queues[i2];
                  var queue = modulesQueue[queueName];
                  var moduleToCheck = queue.pop();
                  seenModules[queueName] = seenModules[queueName] || {};
                  if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                    continue;
                  seenModules[queueName][moduleToCheck] = true;
                  requiredModules[queueName] = requiredModules[queueName] || [];
                  requiredModules[queueName].push(moduleToCheck);
                  var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                  var newModulesKeys = Object.keys(newModules);
                  for (var j = 0; j < newModulesKeys.length; j++) {
                    modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                    modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                  }
                }
              }
              return requiredModules;
            }
            module2.exports = function(moduleId, options) {
              options = options || {};
              var sources = {
                main: __webpack_require__.m
              };
              var requiredModules = options.all ? { main: Object.keys(sources) } : getRequiredModules(sources, moduleId);
              var src = "";
              Object.keys(requiredModules).filter(function(m2) {
                return m2 !== "main";
              }).forEach(function(module3) {
                var entryModule = 0;
                while (requiredModules[module3][entryModule]) {
                  entryModule++;
                }
                requiredModules[module3].push(entryModule);
                sources[module3][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                src = src + "var " + module3 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module3].map(function(id) {
                  return "" + JSON.stringify(id) + ": " + sources[module3][id].toString();
                }).join(",") + "});\n";
              });
              src = src + "(" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id) {
                return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
              }).join(",") + "})(self);";
              var blob = new window.Blob([src], { type: "text/javascript" });
              if (options.bare) {
                return blob;
              }
              var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
              var workerUrl = URL2.createObjectURL(blob);
              var worker = new window.Worker(workerUrl);
              worker.objectURL = workerUrl;
              return worker;
            };
          },
          /* 5 */
          /***/
          function(module2, exports2) {
            module2.exports = function RushaCore(stdlib$840, foreign$841, heap$842) {
              ;
              var H$843 = new stdlib$840.Int32Array(heap$842);
              function hash$844(k$845, x$846) {
                k$845 = k$845 | 0;
                x$846 = x$846 | 0;
                var i$847 = 0, j$848 = 0, y0$849 = 0, z0$850 = 0, y1$851 = 0, z1$852 = 0, y2$853 = 0, z2$854 = 0, y3$855 = 0, z3$856 = 0, y4$857 = 0, z4$858 = 0, t0$859 = 0, t1$860 = 0;
                y0$849 = H$843[x$846 + 320 >> 2] | 0;
                y1$851 = H$843[x$846 + 324 >> 2] | 0;
                y2$853 = H$843[x$846 + 328 >> 2] | 0;
                y3$855 = H$843[x$846 + 332 >> 2] | 0;
                y4$857 = H$843[x$846 + 336 >> 2] | 0;
                for (i$847 = 0; (i$847 | 0) < (k$845 | 0); i$847 = i$847 + 64 | 0) {
                  z0$850 = y0$849;
                  z1$852 = y1$851;
                  z2$854 = y2$853;
                  z3$856 = y3$855;
                  z4$858 = y4$857;
                  for (j$848 = 0; (j$848 | 0) < 64; j$848 = j$848 + 4 | 0) {
                    t1$860 = H$843[i$847 + j$848 >> 2] | 0;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[k$845 + j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 64 | 0; (j$848 | 0) < (k$845 + 80 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 80 | 0; (j$848 | 0) < (k$845 + 160 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1859775393 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 160 | 0; (j$848 | 0) < (k$845 + 240 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | y1$851 & y3$855 | y2$853 & y3$855) | 0) + ((t1$860 + y4$857 | 0) - 1894007588 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 240 | 0; (j$848 | 0) < (k$845 + 320 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) - 899497514 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  y0$849 = y0$849 + z0$850 | 0;
                  y1$851 = y1$851 + z1$852 | 0;
                  y2$853 = y2$853 + z2$854 | 0;
                  y3$855 = y3$855 + z3$856 | 0;
                  y4$857 = y4$857 + z4$858 | 0;
                }
                H$843[x$846 + 320 >> 2] = y0$849;
                H$843[x$846 + 324 >> 2] = y1$851;
                H$843[x$846 + 328 >> 2] = y2$853;
                H$843[x$846 + 332 >> 2] = y3$855;
                H$843[x$846 + 336 >> 2] = y4$857;
              }
              return { hash: hash$844 };
            };
          },
          /* 6 */
          /***/
          function(module2, exports2) {
            var _this = this;
            var reader = void 0;
            if (typeof self !== "undefined" && typeof self.FileReaderSync !== "undefined") {
              reader = new self.FileReaderSync();
            }
            var convStr = function(str, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
              switch (om) {
                case 0:
                  H8[off] = str.charCodeAt(start + 3);
                case 1:
                  H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
                case 2:
                  H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
                case 3:
                  H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2] = str.charCodeAt(start + i2) << 24 | str.charCodeAt(start + i2 + 1) << 16 | str.charCodeAt(start + i2 + 2) << 8 | str.charCodeAt(start + i2 + 3);
              }
              switch (lm) {
                case 3:
                  H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
                case 2:
                  H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
                case 1:
                  H8[off + j + 3 | 0] = str.charCodeAt(start + j);
              }
            };
            var convBuf = function(buf, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
              switch (om) {
                case 0:
                  H8[off] = buf[start + 3];
                case 1:
                  H8[off + 1 - (om << 1) | 0] = buf[start + 2];
                case 2:
                  H8[off + 2 - (om << 1) | 0] = buf[start + 1];
                case 3:
                  H8[off + 3 - (om << 1) | 0] = buf[start];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2 | 0] = buf[start + i2] << 24 | buf[start + i2 + 1] << 16 | buf[start + i2 + 2] << 8 | buf[start + i2 + 3];
              }
              switch (lm) {
                case 3:
                  H8[off + j + 1 | 0] = buf[start + j + 2];
                case 2:
                  H8[off + j + 2 | 0] = buf[start + j + 1];
                case 1:
                  H8[off + j + 3 | 0] = buf[start + j];
              }
            };
            var convBlob = function(blob, H8, H32, start, len, off) {
              var i2 = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
              var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
              switch (om) {
                case 0:
                  H8[off] = buf[3];
                case 1:
                  H8[off + 1 - (om << 1) | 0] = buf[2];
                case 2:
                  H8[off + 2 - (om << 1) | 0] = buf[1];
                case 3:
                  H8[off + 3 - (om << 1) | 0] = buf[0];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i2 = 4 - om; i2 < j; i2 = i2 + 4 | 0) {
                H32[off + i2 >> 2 | 0] = buf[i2] << 24 | buf[i2 + 1] << 16 | buf[i2 + 2] << 8 | buf[i2 + 3];
              }
              switch (lm) {
                case 3:
                  H8[off + j + 1 | 0] = buf[j + 2];
                case 2:
                  H8[off + j + 2 | 0] = buf[j + 1];
                case 1:
                  H8[off + j + 3 | 0] = buf[j];
              }
            };
            module2.exports = function(data, H8, H32, start, len, off) {
              if (typeof data === "string") {
                return convStr(data, H8, H32, start, len, off);
              }
              if (data instanceof Array) {
                return convBuf(data, H8, H32, start, len, off);
              }
              if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {
                return convBuf(data, H8, H32, start, len, off);
              }
              if (data instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data), H8, H32, start, len, off);
              }
              if (data.buffer instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);
              }
              if (data instanceof Blob) {
                return convBlob(data, H8, H32, start, len, off);
              }
              throw new Error("Unsupported data type.");
            };
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Rusha = __webpack_require__(0);
            var _require = __webpack_require__(1), toHex = _require.toHex;
            var Hash = function() {
              function Hash2() {
                _classCallCheck(this, Hash2);
                this._rusha = new Rusha();
                this._rusha.resetState();
              }
              Hash2.prototype.update = function update3(data) {
                this._rusha.append(data);
                return this;
              };
              Hash2.prototype.digest = function digest(encoding) {
                var digest2 = this._rusha.rawEnd().buffer;
                if (!encoding) {
                  return digest2;
                }
                if (encoding === "hex") {
                  return toHex(digest2);
                }
                throw new Error("unsupported digest encoding");
              };
              _createClass(Hash2, [{
                key: "state",
                get: function() {
                  return this._rusha.getState();
                },
                set: function(state) {
                  this._rusha.setState(state);
                }
              }]);
              return Hash2;
            }();
            module2.exports = function() {
              return new Hash();
            };
          }
          /******/
        ])
      );
    });
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob2 = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l = obj.length; i2 < l; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        forEach(arguments[i2], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i2;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i2 = thing.length;
      if (isUndefined(i2))
        return null;
      var arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    function encode2(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode2(key) + "=" + encode2(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/AxiosError.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    function AxiosError(message, code, config3, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config3 && (this.config = config3);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config3, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config3, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module.exports = AxiosError;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    function toFormData2(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module.exports = toFormData2;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var AxiosError = require_AxiosError();
    module.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path4, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path4)) {
              cookie.push("path=" + path4);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i2;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i2 = line.indexOf(":");
        key = utils.trim(line.substr(0, i2)).toLowerCase();
        val = utils.trim(line.substr(i2 + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var AxiosError = require_AxiosError();
    var utils = require_utils4();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module.exports = CanceledError;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module.exports = function xhrAdapter(config3) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config3.data;
        var requestHeaders = config3.headers;
        var responseType = config3.responseType;
        var onCanceled;
        function done() {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(onCanceled);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config3.auth) {
          var username = config3.auth.username || "";
          var password = config3.auth.password ? unescape(encodeURIComponent(config3.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config3.baseURL, config3.url);
        request.open(config3.method.toUpperCase(), buildURL(fullPath, config3.params, config3.paramsSerializer), true);
        request.timeout = config3.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config3,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config3, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config3, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config3.transitional || transitionalDefaults;
          if (config3.timeoutErrorMessage) {
            timeoutErrorMessage = config3.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config3,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config3.withCredentials || isURLSameOrigin(fullPath)) && config3.xsrfCookieName ? cookies.read(config3.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config3.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config3.withCredentials)) {
          request.withCredentials = !!config3.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config3.responseType;
        }
        if (typeof config3.onDownloadProgress === "function") {
          request.addEventListener("progress", config3.onDownloadProgress);
        }
        if (typeof config3.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config3.onUploadProgress);
        }
        if (config3.cancelToken || config3.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config3.cancelToken && config3.cancelToken.subscribe(onCanceled);
          if (config3.signal) {
            config3.signal.aborted ? onCanceled() : config3.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config3));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var debug;
    module.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var url = __require("url");
    var URL2 = url.URL;
    var http3 = __require("http");
    var https2 = __require("https");
    var Writable = __require("stream").Writable;
    var assert = __require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i2 = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i2 < buffers.length) {
              var buffer = buffers[i2++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location2 = response.headers.location;
      if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location2);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get2(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get2, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    module.exports = wrap({ http: http3, https: https2 });
    module.exports.wrap = wrap;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/env/data.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      "version": "0.27.2"
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/adapters/http.js
var require_http4 = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/adapters/http.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http3 = __require("http");
    var https2 = __require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = __require("url");
    var zlib2 = __require("zlib");
    var VERSION = require_data().version;
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var isHttps = /https:?/;
    var supportedProtocols = ["http:", "https:", "file:"];
    function setProxy(options, proxy, location2) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location2;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module.exports = function httpAdapter(config3) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(onCanceled);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve2 = function resolve3(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config3.data;
        var headers = config3.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
          Object.assign(headers, data.getHeaders());
        } else if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config3
            ));
          }
          if (config3.maxBodyLength > -1 && data.length > config3.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config3
            ));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config3.auth) {
          var username = config3.auth.username || "";
          var password = config3.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config3.baseURL, config3.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || supportedProtocols[0];
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config3
          ));
        }
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config3.httpsAgent : config3.httpAgent;
        try {
          buildURL(parsed.path, config3.params, config3.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config3;
          customErr.url = config3.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config3.params, config3.paramsSerializer).replace(/^\?/, ""),
          method: config3.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config3.httpAgent, https: config3.httpsAgent },
          auth
        };
        if (config3.socketPath) {
          options.socketPath = config3.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config3.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s2) {
                return s2.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config3.transport) {
          transport = config3.transport;
        } else if (config3.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http3;
        } else {
          if (config3.maxRedirects) {
            options.maxRedirects = config3.maxRedirects;
          }
          if (config3.beforeRedirect) {
            options.beforeRedirect = config3.beforeRedirect;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config3.maxBodyLength > -1) {
          options.maxBodyLength = config3.maxBodyLength;
        }
        if (config3.insecureHTTPParser) {
          options.insecureHTTPParser = config3.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config3.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config3,
            request: lastRequest
          };
          if (config3.responseType === "stream") {
            response.data = stream;
            settle(resolve2, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config3.maxContentLength > -1 && totalResponseBytes > config3.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config3.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config3,
                  lastRequest
                ));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(new AxiosError(
                "maxContentLength size of " + config3.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config3,
                lastRequest
              ));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(AxiosError.from(err, null, config3, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config3.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config3.responseEncoding);
                  if (!config3.responseEncoding || config3.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(AxiosError.from(err, null, config3, response.request, response));
              }
              settle(resolve2, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config3, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config3.timeout) {
          var timeout = parseInt(config3.timeout, 10);
          if (isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config3,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config3.transitional || transitionalDefaults;
            reject(new AxiosError(
              "timeout of " + timeout + "ms exceeded",
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config3,
              req
            ));
          });
        }
        if (config3.cancelToken || config3.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          };
          config3.cancelToken && config3.cancelToken.subscribe(onCanceled);
          if (config3.signal) {
            config3.signal.aborted ? onCanceled() : config3.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(AxiosError.from(err, config3, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var Stream3 = __require("stream").Stream;
    var util2 = __require("util");
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream3);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r2 = Stream3.prototype.pipe.apply(this, arguments);
      this.resume();
      return r2;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var util2 = __require("util");
    var Stream3 = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream3);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream3.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path4) {
      if (!path4 || typeof path4 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path4).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types3) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types3[extension2]) {
            var from = preference.indexOf(db[types3[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types3[extension2] !== "application/octet-stream" && (from > to || from === to && types3[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types3[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/asynckit/lib/defer.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async2 = __commonJS({
  "../../node_modules/asynckit/lib/async.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var defer = require_defer();
    module.exports = async;
    function async(callback) {
      var isAsync2 = false;
      defer(function() {
        isAsync2 = true;
      });
      return function async_callback(err, result) {
        if (isAsync2) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/asynckit/lib/abort.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/asynckit/lib/iterate.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var async = require_async2();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/asynckit/lib/state.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/asynckit/lib/terminator.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var abort = require_abort();
    var async = require_async2();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/asynckit/parallel.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/asynckit/serialOrdered.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/asynckit/serial.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var serialOrdered = require_serialOrdered();
    module.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/asynckit/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/form-data/lib/populate.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/form-data/lib/form_data.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var CombinedStream = require_combined_stream();
    var util2 = __require("util");
    var path4 = __require("path");
    var http3 = __require("http");
    var https2 = __require("https");
    var parseUrl = __require("url").parse;
    var fs7 = __require("fs");
    var Stream3 = __require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module.exports = FormData4;
    util2.inherits(FormData4, CombinedStream);
    function FormData4(options) {
      if (!(this instanceof FormData4)) {
        return new FormData4(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData4.LINE_BREAK = "\r\n";
    FormData4.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData4.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData4.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData4.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream3)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData4.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs7.stat(value.path, function(err, stat2) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat2.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData4.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData4.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData4.LINE_BREAK + contents + FormData4.LINE_BREAK;
    };
    FormData4.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path4.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path4.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path4.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData4.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData4.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData4.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData4.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData4.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData4.LINE_BREAK;
    };
    FormData4.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData4.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData4.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData4.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i2 = 0, len = this._streams.length; i2 < len; i2++) {
        if (typeof this._streams[i2] !== "function") {
          if (Buffer.isBuffer(this._streams[i2])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i2]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i2])]);
          }
          if (typeof this._streams[i2] !== "string" || this._streams[i2].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData4.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData4.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i2 = 0; i2 < 24; i2++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData4.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData4.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData4.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData4.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http3.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData4.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData4.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/defaults/env/FormData.js
var require_FormData = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/defaults/env/FormData.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = require_form_data();
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData2 = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http4();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData2(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_FormData()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config3) {
      if (config3.cancelToken) {
        config3.cancelToken.throwIfRequested();
      }
      if (config3.signal && config3.signal.aborted) {
        throw new CanceledError();
      }
    }
    module.exports = function dispatchRequest(config3) {
      throwIfCancellationRequested(config3);
      config3.headers = config3.headers || {};
      config3.data = transformData.call(
        config3,
        config3.data,
        config3.headers,
        config3.transformRequest
      );
      config3.headers = utils.merge(
        config3.headers.common || {},
        config3.headers[config3.method] || {},
        config3.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config3.headers[method];
        }
      );
      var adapter = config3.adapter || defaults.adapter;
      return adapter(config3).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config3);
        response.data = transformData.call(
          config3,
          response.data,
          response.headers,
          config3.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config3);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config3,
              reason.response.data,
              reason.response.headers,
              config3.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    module.exports = function mergeConfig(config1, config22) {
      config22 = config22 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config22[prop])) {
          return getMergedValue(void 0, config22[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config22) {
          return getMergedValue(config1[prop], config22[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config22)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var VERSION = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i2 = keys.length;
      while (i2-- > 0) {
        var opt = keys[i2];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config3) {
      if (typeof configOrUrl === "string") {
        config3 = config3 || {};
        config3.url = configOrUrl;
      } else {
        config3 = configOrUrl || {};
      }
      config3 = mergeConfig(this.defaults, config3);
      if (config3.method) {
        config3.method = config3.method.toLowerCase();
      } else if (this.defaults.method) {
        config3.method = this.defaults.method.toLowerCase();
      } else {
        config3.method = "get";
      }
      var transitional = config3.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config3);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config3;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config3) {
      config3 = mergeConfig(this.defaults, config3);
      var fullPath = buildFullPath(config3.baseURL, config3.url);
      return buildURL(fullPath, config3.params, config3.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url,
          data: (config3 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config3) {
          return this.request(mergeConfig(config3 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module.exports = Axios;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i2;
        var l = token._listeners.length;
        for (i2 = 0; i2 < l; i2++) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve2) {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// ../../node_modules/posthog-node/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var utils = require_utils4();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.CanceledError = require_CanceledError();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.toFormData = require_toFormData();
    axios.AxiosError = require_AxiosError();
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises3) {
      return Promise.all(promises3);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// ../../node_modules/posthog-node/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../../node_modules/posthog-node/node_modules/axios/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = require_axios();
  }
});

// ../../node_modules/posthog-node/lib/index.cjs.js
var require_index_cjs = __commonJS({
  "../../node_modules/posthog-node/lib/index.cjs.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var rusha = require_rusha();
    var axios = require_axios2();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
    }
    var axios__default = /* @__PURE__ */ _interopDefaultLegacy(axios);
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s2 = arguments[i2];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    function __rest(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f4, y, t2, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f4)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f4 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
              return t2;
            if (y = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y = 0;
          } finally {
            f4 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    var version2 = "3.1.1";
    var PostHogPersistedProperty;
    (function(PostHogPersistedProperty2) {
      PostHogPersistedProperty2["AnonymousId"] = "anonymous_id";
      PostHogPersistedProperty2["DistinctId"] = "distinct_id";
      PostHogPersistedProperty2["Props"] = "props";
      PostHogPersistedProperty2["FeatureFlags"] = "feature_flags";
      PostHogPersistedProperty2["FeatureFlagPayloads"] = "feature_flag_payloads";
      PostHogPersistedProperty2["OverrideFeatureFlags"] = "override_feature_flags";
      PostHogPersistedProperty2["Queue"] = "queue";
      PostHogPersistedProperty2["OptedOut"] = "opted_out";
      PostHogPersistedProperty2["SessionId"] = "session_id";
      PostHogPersistedProperty2["SessionLastTimestamp"] = "session_timestamp";
      PostHogPersistedProperty2["PersonProperties"] = "person_properties";
      PostHogPersistedProperty2["GroupProperties"] = "group_properties";
    })(PostHogPersistedProperty || (PostHogPersistedProperty = {}));
    function assert(truthyValue, message) {
      if (!truthyValue) {
        throw new Error(message);
      }
    }
    function removeTrailingSlash(url) {
      return url === null || url === void 0 ? void 0 : url.replace(/\/+$/, "");
    }
    function retriable(fn, props) {
      if (props === void 0) {
        props = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, retryCount, _b, retryDelay, _c, retryCheck, lastError, i2, res, e_1;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _a = props.retryCount, retryCount = _a === void 0 ? 3 : _a, _b = props.retryDelay, retryDelay = _b === void 0 ? 5e3 : _b, _c = props.retryCheck, retryCheck = _c === void 0 ? function() {
                return true;
              } : _c;
              lastError = null;
              i2 = 0;
              _d.label = 1;
            case 1:
              if (!(i2 < retryCount + 1))
                return [3, 7];
              if (!(i2 > 0))
                return [3, 3];
              return [4, new Promise(function(r2) {
                return setTimeout(r2, retryDelay);
              })];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              _d.trys.push([3, 5, , 6]);
              return [4, fn()];
            case 4:
              res = _d.sent();
              return [2, res];
            case 5:
              e_1 = _d.sent();
              lastError = e_1;
              if (!retryCheck(e_1)) {
                throw e_1;
              }
              return [3, 6];
            case 6:
              i2++;
              return [3, 1];
            case 7:
              throw lastError;
          }
        });
      });
    }
    function generateUUID(globalThis2) {
      var d = (/* @__PURE__ */ new Date()).getTime();
      var d2 = globalThis2 && globalThis2.performance && globalThis2.performance.now && globalThis2.performance.now() * 1e3 || 0;
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r2 = Math.random() * 16;
        if (d > 0) {
          r2 = (d + r2) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r2 = (d2 + r2) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r2 : r2 & 3 | 8).toString(16);
      });
    }
    function currentTimestamp() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    function currentISOTime() {
      return (/* @__PURE__ */ new Date()).toISOString();
    }
    function safeSetTimeout(fn, timeout) {
      var t2 = setTimeout(fn, timeout);
      (t2 === null || t2 === void 0 ? void 0 : t2.unref) && (t2 === null || t2 === void 0 ? void 0 : t2.unref());
      return t2;
    }
    var f3 = String.fromCharCode;
    var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i2 = 0; i2 < alphabet.length; i2++) {
          baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString = {
      compressToBase64: function(input) {
        if (input == null) {
          return "";
        }
        var res = LZString._compress(input, 6, function(a) {
          return keyStrBase64.charAt(a);
        });
        switch (res.length % 4) {
          default:
          case 0:
            return res;
          case 1:
            return res + "===";
          case 2:
            return res + "==";
          case 3:
            return res + "=";
        }
      },
      decompressFromBase64: function(input) {
        if (input == null) {
          return "";
        }
        if (input == "") {
          return null;
        }
        return LZString._decompress(input.length, 32, function(index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compress: function(uncompressed) {
        return LZString._compress(uncompressed, 16, function(a) {
          return f3(a);
        });
      },
      _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null) {
          return "";
        }
        var context_dictionary = {}, context_dictionaryToCreate = {}, context_data = [];
        var i2, value, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data_val = 0, context_data_position = 0, ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 8; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 16; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i2 = 0; i2 < 8; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i2 = 0; i2 < 16; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        value = 2;
        for (i2 = 0; i2 < context_numBits; i2++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else {
            context_data_position++;
          }
        }
        return context_data.join("");
      },
      decompress: function(compressed) {
        if (compressed == null) {
          return "";
        }
        if (compressed == "") {
          return null;
        }
        return LZString._decompress(compressed.length, 32768, function(index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function(length, resetValue, getNextValue) {
        var dictionary = [], result = [], data = { val: getNextValue(0), position: resetValue, index: 1 };
        var enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", i2, w, bits, resb, maxpower, power, c;
        for (i2 = 0; i2 < 3; i2 += 1) {
          dictionary[i2] = i2;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f3(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f3(bits);
            break;
          case 2:
            return "";
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return "";
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f3(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f3(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join("");
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    var SimpleEventEmitter = (
      /** @class */
      function() {
        function SimpleEventEmitter2() {
          this.events = {};
          this.events = {};
        }
        SimpleEventEmitter2.prototype.on = function(event, listener) {
          var _this = this;
          if (!this.events[event]) {
            this.events[event] = [];
          }
          this.events[event].push(listener);
          return function() {
            _this.events[event] = _this.events[event].filter(function(x2) {
              return x2 !== listener;
            });
          };
        };
        SimpleEventEmitter2.prototype.emit = function(event, payload) {
          for (var _i = 0, _a = this.events[event] || []; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener(payload);
          }
          for (var _b = 0, _c = this.events["*"] || []; _b < _c.length; _b++) {
            var listener = _c[_b];
            listener(event, payload);
          }
        };
        return SimpleEventEmitter2;
      }()
    );
    var PostHogFetchHttpError = (
      /** @class */
      function(_super) {
        __extends(PostHogFetchHttpError2, _super);
        function PostHogFetchHttpError2(response) {
          var _this = _super.call(this, "HTTP error while fetching PostHog: " + response.status) || this;
          _this.response = response;
          _this.name = "PostHogFetchHttpError";
          return _this;
        }
        return PostHogFetchHttpError2;
      }(Error)
    );
    var PostHogFetchNetworkError = (
      /** @class */
      function(_super) {
        __extends(PostHogFetchNetworkError2, _super);
        function PostHogFetchNetworkError2(error) {
          var _this = _super.call(this, "Network error while fetching PostHog", error instanceof Error ? { cause: error } : {}) || this;
          _this.error = error;
          _this.name = "PostHogFetchNetworkError";
          return _this;
        }
        return PostHogFetchNetworkError2;
      }(Error)
    );
    function isPostHogFetchError(err) {
      return typeof err === "object" && (err.name === "PostHogFetchHttpError" || err.name === "PostHogFetchNetworkError");
    }
    var PostHogCoreStateless = (
      /** @class */
      function() {
        function PostHogCoreStateless2(apiKey, options) {
          var _a, _b, _c, _d, _e;
          this.debugMode = false;
          this.pendingPromises = {};
          this.disableGeoip = true;
          this._events = new SimpleEventEmitter();
          assert(apiKey, "You must pass your PostHog project's api key.");
          this.apiKey = apiKey;
          this.host = removeTrailingSlash((options === null || options === void 0 ? void 0 : options.host) || "https://app.posthog.com");
          this.flushAt = (options === null || options === void 0 ? void 0 : options.flushAt) ? Math.max(options === null || options === void 0 ? void 0 : options.flushAt, 1) : 20;
          this.flushInterval = (_a = options === null || options === void 0 ? void 0 : options.flushInterval) !== null && _a !== void 0 ? _a : 1e4;
          this.captureMode = (options === null || options === void 0 ? void 0 : options.captureMode) || "form";
          this._optoutOverride = (options === null || options === void 0 ? void 0 : options.enable) === false;
          this._retryOptions = {
            retryCount: (_b = options === null || options === void 0 ? void 0 : options.fetchRetryCount) !== null && _b !== void 0 ? _b : 3,
            retryDelay: (_c = options === null || options === void 0 ? void 0 : options.fetchRetryDelay) !== null && _c !== void 0 ? _c : 3e3,
            retryCheck: isPostHogFetchError
          };
          this.requestTimeout = (_d = options === null || options === void 0 ? void 0 : options.requestTimeout) !== null && _d !== void 0 ? _d : 1e4;
          this.disableGeoip = (_e = options === null || options === void 0 ? void 0 : options.disableGeoip) !== null && _e !== void 0 ? _e : true;
        }
        PostHogCoreStateless2.prototype.getCommonEventProperties = function() {
          return {
            $lib: this.getLibraryId(),
            $lib_version: this.getLibraryVersion()
          };
        };
        Object.defineProperty(PostHogCoreStateless2.prototype, "optedOut", {
          get: function() {
            var _a, _b;
            return (_b = (_a = this.getPersistedProperty(PostHogPersistedProperty.OptedOut)) !== null && _a !== void 0 ? _a : this._optoutOverride) !== null && _b !== void 0 ? _b : false;
          },
          enumerable: false,
          configurable: true
        });
        PostHogCoreStateless2.prototype.optIn = function() {
          this.setPersistedProperty(PostHogPersistedProperty.OptedOut, false);
        };
        PostHogCoreStateless2.prototype.optOut = function() {
          this.setPersistedProperty(PostHogPersistedProperty.OptedOut, true);
        };
        PostHogCoreStateless2.prototype.on = function(event, cb) {
          return this._events.on(event, cb);
        };
        PostHogCoreStateless2.prototype.debug = function(enabled) {
          var _a;
          if (enabled === void 0) {
            enabled = true;
          }
          (_a = this.removeDebugCallback) === null || _a === void 0 ? void 0 : _a.call(this);
          this.debugMode = enabled;
          if (enabled) {
            this.removeDebugCallback = this.on("*", function(event, payload) {
              return console.log("PostHog Debug", event, payload);
            });
          }
        };
        PostHogCoreStateless2.prototype.buildPayload = function(payload) {
          return {
            distinct_id: payload.distinct_id,
            event: payload.event,
            properties: __assign(__assign({}, payload.properties || {}), this.getCommonEventProperties())
          };
        };
        PostHogCoreStateless2.prototype.identifyStateless = function(distinctId, properties, options) {
          var payload = __assign({}, this.buildPayload({
            distinct_id: distinctId,
            event: "$identify",
            properties
          }));
          this.enqueue("identify", payload, options);
          return this;
        };
        PostHogCoreStateless2.prototype.captureStateless = function(distinctId, event, properties, options) {
          var payload = this.buildPayload({ distinct_id: distinctId, event, properties });
          this.enqueue("capture", payload, options);
          return this;
        };
        PostHogCoreStateless2.prototype.aliasStateless = function(alias, distinctId, properties, options) {
          var payload = this.buildPayload({
            event: "$create_alias",
            distinct_id: distinctId,
            properties: __assign(__assign({}, properties || {}), { distinct_id: distinctId, alias })
          });
          this.enqueue("alias", payload, options);
          return this;
        };
        PostHogCoreStateless2.prototype.groupIdentifyStateless = function(groupType, groupKey, groupProperties, options, distinctId, eventProperties) {
          var payload = this.buildPayload({
            distinct_id: distinctId || "$".concat(groupType, "_").concat(groupKey),
            event: "$groupidentify",
            properties: __assign({ $group_type: groupType, $group_key: groupKey, $group_set: groupProperties || {} }, eventProperties || {})
          });
          this.enqueue("capture", payload, options);
          return this;
        };
        PostHogCoreStateless2.prototype.getDecide = function(distinctId, groups, personProperties, groupProperties, extraPayload) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          if (extraPayload === void 0) {
            extraPayload = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var url, fetchOptions;
            return __generator(this, function(_a) {
              url = "".concat(this.host, "/decide/?v=3");
              fetchOptions = {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(__assign({ token: this.apiKey, distinct_id: distinctId, groups, person_properties: personProperties, group_properties: groupProperties }, extraPayload))
              };
              return [2, this.fetchWithRetry(url, fetchOptions).then(function(response) {
                return response.json();
              }).catch(function(error) {
                console.error("Error fetching feature flags", error);
                return void 0;
              })];
            });
          });
        };
        PostHogCoreStateless2.prototype.getFeatureFlagStateless = function(key, distinctId, groups, personProperties, groupProperties, disableGeoip) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var featureFlags, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getFeatureFlagsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)];
                case 1:
                  featureFlags = _a.sent();
                  if (!featureFlags) {
                    return [2, void 0];
                  }
                  response = featureFlags[key];
                  if (response === void 0) {
                    response = false;
                  }
                  return [2, response];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.getFeatureFlagPayloadStateless = function(key, distinctId, groups, personProperties, groupProperties, disableGeoip) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var payloads, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getFeatureFlagPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)];
                case 1:
                  payloads = _a.sent();
                  if (!payloads) {
                    return [2, void 0];
                  }
                  response = payloads[key];
                  if (response === void 0) {
                    return [2, null];
                  }
                  return [2, this._parsePayload(response)];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.getFeatureFlagPayloadsStateless = function(distinctId, groups, personProperties, groupProperties, disableGeoip) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var payloads;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)];
                case 1:
                  payloads = _a.sent().payloads;
                  if (payloads) {
                    return [2, Object.fromEntries(Object.entries(payloads).map(function(_a2) {
                      var k = _a2[0], v = _a2[1];
                      return [k, _this._parsePayload(v)];
                    }))];
                  }
                  return [2, payloads];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype._parsePayload = function(response) {
          try {
            return JSON.parse(response);
          } catch (_a) {
            return response;
          }
        };
        PostHogCoreStateless2.prototype.getFeatureFlagsStateless = function(distinctId, groups, personProperties, groupProperties, disableGeoip) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip)];
                case 1:
                  return [2, _a.sent().flags];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.getFeatureFlagsAndPayloadsStateless = function(distinctId, groups, personProperties, groupProperties, disableGeoip) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var extraPayload, decideResponse, flags, payloads;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  extraPayload = {};
                  if (disableGeoip !== null && disableGeoip !== void 0 ? disableGeoip : this.disableGeoip) {
                    extraPayload["geoip_disable"] = true;
                  }
                  return [4, this.getDecide(distinctId, groups, personProperties, groupProperties, extraPayload)];
                case 1:
                  decideResponse = _a.sent();
                  flags = decideResponse === null || decideResponse === void 0 ? void 0 : decideResponse.featureFlags;
                  payloads = decideResponse === null || decideResponse === void 0 ? void 0 : decideResponse.featureFlagPayloads;
                  return [2, {
                    flags,
                    payloads
                  }];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.enqueue = function(type, _message, options) {
          var _this = this;
          var _a;
          if (this.optedOut) {
            this._events.emit(type, "Library is disabled. Not sending event. To re-enable, call posthog.enable()");
            return;
          }
          var message = __assign(__assign({}, _message), { type, library: this.getLibraryId(), library_version: this.getLibraryVersion(), timestamp: (options === null || options === void 0 ? void 0 : options.timestamp) ? options === null || options === void 0 ? void 0 : options.timestamp : currentISOTime() });
          var addGeoipDisableProperty = (_a = options === null || options === void 0 ? void 0 : options.disableGeoip) !== null && _a !== void 0 ? _a : this.disableGeoip;
          if (addGeoipDisableProperty) {
            if (!message.properties) {
              message.properties = {};
            }
            message["properties"]["$geoip_disable"] = true;
          }
          if (message.distinctId) {
            message.distinct_id = message.distinctId;
            delete message.distinctId;
          }
          var queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
          queue.push({ message });
          this.setPersistedProperty(PostHogPersistedProperty.Queue, queue);
          this._events.emit(type, message);
          if (queue.length >= this.flushAt) {
            this.flush();
          }
          if (this.flushInterval && !this._flushTimer) {
            this._flushTimer = safeSetTimeout(function() {
              return _this.flush();
            }, this.flushInterval);
          }
        };
        PostHogCoreStateless2.prototype.flushAsync = function() {
          var _this = this;
          return new Promise(function(resolve2, reject) {
            _this.flush(function(err, data) {
              return err ? reject(err) : resolve2(data);
            });
          });
        };
        PostHogCoreStateless2.prototype.flush = function(callback) {
          var _this = this;
          if (this._flushTimer) {
            clearTimeout(this._flushTimer);
            this._flushTimer = null;
          }
          var queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];
          if (!queue.length) {
            return callback === null || callback === void 0 ? void 0 : callback();
          }
          var items = queue.splice(0, this.flushAt);
          this.setPersistedProperty(PostHogPersistedProperty.Queue, queue);
          var messages = items.map(function(item) {
            return item.message;
          });
          var data = {
            api_key: this.apiKey,
            batch: messages,
            sent_at: currentISOTime()
          };
          var promiseUUID = generateUUID();
          var done = function(err) {
            if (err) {
              _this._events.emit("error", err);
            }
            callback === null || callback === void 0 ? void 0 : callback(err, messages);
            delete _this.pendingPromises[promiseUUID];
            _this._events.emit("flush", messages);
          };
          this.getCustomUserAgent();
          var payload = JSON.stringify(data);
          var url = this.captureMode === "form" ? "".concat(this.host, "/e/?ip=1&_=").concat(currentTimestamp(), "&v=").concat(this.getLibraryVersion()) : "".concat(this.host, "/batch/");
          var fetchOptions = this.captureMode === "form" ? {
            method: "POST",
            mode: "no-cors",
            credentials: "omit",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: "data=".concat(encodeURIComponent(LZString.compressToBase64(payload)), "&compression=lz64")
          } : {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: payload
          };
          var requestPromise = this.fetchWithRetry(url, fetchOptions);
          this.pendingPromises[promiseUUID] = requestPromise;
          requestPromise.then(function() {
            return done();
          }).catch(function(err) {
            done(err);
          });
        };
        PostHogCoreStateless2.prototype.fetchWithRetry = function(url, options, retryOptions) {
          var _a;
          var _b;
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  (_a = (_b = AbortSignal).timeout) !== null && _a !== void 0 ? _a : _b.timeout = function timeout(ms) {
                    var ctrl = new AbortController();
                    setTimeout(function() {
                      return ctrl.abort();
                    }, ms);
                    return ctrl.signal;
                  };
                  return [4, retriable(function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      var res, e_1;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            res = null;
                            _a2.label = 1;
                          case 1:
                            _a2.trys.push([1, 3, , 4]);
                            return [4, this.fetch(url, __assign({ signal: AbortSignal.timeout(this.requestTimeout) }, options))];
                          case 2:
                            res = _a2.sent();
                            return [3, 4];
                          case 3:
                            e_1 = _a2.sent();
                            throw new PostHogFetchNetworkError(e_1);
                          case 4:
                            if (res.status < 200 || res.status >= 400) {
                              throw new PostHogFetchHttpError(res);
                            }
                            return [2, res];
                        }
                      });
                    });
                  }, __assign(__assign({}, this._retryOptions), retryOptions))];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.shutdownAsync = function() {
          return __awaiter(this, void 0, void 0, function() {
            var e_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  clearTimeout(this._flushTimer);
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 5]);
                  return [4, this.flushAsync()];
                case 2:
                  _a.sent();
                  return [4, Promise.all(Object.values(this.pendingPromises).map(function(x2) {
                    return x2.catch(function() {
                    });
                  }))];
                case 3:
                  _a.sent();
                  return [3, 5];
                case 4:
                  e_2 = _a.sent();
                  if (!isPostHogFetchError(e_2)) {
                    throw e_2;
                  }
                  console.error("Error while shutting down PostHog", e_2);
                  return [3, 5];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PostHogCoreStateless2.prototype.shutdown = function() {
          void this.shutdownAsync();
        };
        return PostHogCoreStateless2;
      }()
    );
    (function(_super) {
      __extends(PostHogCore, _super);
      function PostHogCore(apiKey, options) {
        var _this = this;
        var _a, _b, _c;
        var disableGeoipOption = (_a = options === null || options === void 0 ? void 0 : options.disableGeoip) !== null && _a !== void 0 ? _a : false;
        _this = _super.call(this, apiKey, __assign(__assign({}, options), { disableGeoip: disableGeoipOption })) || this;
        _this.flagCallReported = {};
        _this.sendFeatureFlagEvent = (_b = options === null || options === void 0 ? void 0 : options.sendFeatureFlagEvent) !== null && _b !== void 0 ? _b : true;
        _this._sessionExpirationTimeSeconds = (_c = options === null || options === void 0 ? void 0 : options.sessionExpirationTimeSeconds) !== null && _c !== void 0 ? _c : 1800;
        return _this;
      }
      PostHogCore.prototype.setupBootstrap = function(options) {
        var _a, _b, _c, _d;
        if ((_a = options === null || options === void 0 ? void 0 : options.bootstrap) === null || _a === void 0 ? void 0 : _a.distinctId) {
          if ((_b = options === null || options === void 0 ? void 0 : options.bootstrap) === null || _b === void 0 ? void 0 : _b.isIdentifiedId) {
            this.setPersistedProperty(PostHogPersistedProperty.DistinctId, options.bootstrap.distinctId);
          } else {
            this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, options.bootstrap.distinctId);
          }
        }
        if ((_c = options === null || options === void 0 ? void 0 : options.bootstrap) === null || _c === void 0 ? void 0 : _c.featureFlags) {
          var activeFlags = Object.keys(((_d = options.bootstrap) === null || _d === void 0 ? void 0 : _d.featureFlags) || {}).filter(function(flag) {
            var _a2, _b2;
            return !!((_b2 = (_a2 = options.bootstrap) === null || _a2 === void 0 ? void 0 : _a2.featureFlags) === null || _b2 === void 0 ? void 0 : _b2[flag]);
          }).reduce(function(res, key) {
            var _a2, _b2;
            return res[key] = ((_b2 = (_a2 = options.bootstrap) === null || _a2 === void 0 ? void 0 : _a2.featureFlags) === null || _b2 === void 0 ? void 0 : _b2[key]) || false, res;
          }, {});
          this.setKnownFeatureFlags(activeFlags);
          (options === null || options === void 0 ? void 0 : options.bootstrap.featureFlagPayloads) && this.setKnownFeatureFlagPayloads(options === null || options === void 0 ? void 0 : options.bootstrap.featureFlagPayloads);
        }
      };
      Object.defineProperty(PostHogCore.prototype, "props", {
        // NOTE: Props are lazy loaded from localstorage hence the complex getter setter logic
        get: function() {
          if (!this._props) {
            this._props = this.getPersistedProperty(PostHogPersistedProperty.Props);
          }
          return this._props || {};
        },
        set: function(val) {
          this._props = val;
        },
        enumerable: false,
        configurable: true
      });
      PostHogCore.prototype.clearProps = function() {
        this.props = void 0;
      };
      PostHogCore.prototype.on = function(event, cb) {
        return this._events.on(event, cb);
      };
      PostHogCore.prototype.reset = function(propertiesToKeep) {
        var allPropertiesToKeep = __spreadArray([PostHogPersistedProperty.Queue], propertiesToKeep || [], true);
        this.clearProps();
        for (var _i = 0, _a = Object.keys(PostHogPersistedProperty); _i < _a.length; _i++) {
          var key = _a[_i];
          if (!allPropertiesToKeep.includes(PostHogPersistedProperty[key])) {
            this.setPersistedProperty(PostHogPersistedProperty[key], null);
          }
        }
      };
      PostHogCore.prototype.getCommonEventProperties = function() {
        var featureFlags = this.getFeatureFlags();
        var featureVariantProperties = {};
        if (featureFlags) {
          for (var _i = 0, _a = Object.entries(featureFlags); _i < _a.length; _i++) {
            var _b = _a[_i], feature = _b[0], variant = _b[1];
            featureVariantProperties["$feature/".concat(feature)] = variant;
          }
        }
        return __assign(__assign({ $active_feature_flags: featureFlags ? Object.keys(featureFlags) : void 0 }, featureVariantProperties), _super.prototype.getCommonEventProperties.call(this));
      };
      PostHogCore.prototype.enrichProperties = function(properties) {
        return __assign(__assign(__assign(__assign({}, this.props), properties || {}), this.getCommonEventProperties()), { $session_id: this.getSessionId() });
      };
      PostHogCore.prototype.getSessionId = function() {
        var sessionId = this.getPersistedProperty(PostHogPersistedProperty.SessionId);
        var sessionTimestamp = this.getPersistedProperty(PostHogPersistedProperty.SessionLastTimestamp) || 0;
        if (!sessionId || Date.now() - sessionTimestamp > this._sessionExpirationTimeSeconds * 1e3) {
          sessionId = generateUUID(globalThis);
          this.setPersistedProperty(PostHogPersistedProperty.SessionId, sessionId);
        }
        this.setPersistedProperty(PostHogPersistedProperty.SessionLastTimestamp, Date.now());
        return sessionId;
      };
      PostHogCore.prototype.resetSessionId = function() {
        this.setPersistedProperty(PostHogPersistedProperty.SessionId, null);
      };
      PostHogCore.prototype.getAnonymousId = function() {
        var anonId = this.getPersistedProperty(PostHogPersistedProperty.AnonymousId);
        if (!anonId) {
          anonId = generateUUID(globalThis);
          this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, anonId);
        }
        return anonId;
      };
      PostHogCore.prototype.getDistinctId = function() {
        return this.getPersistedProperty(PostHogPersistedProperty.DistinctId) || this.getAnonymousId();
      };
      PostHogCore.prototype.register = function(properties) {
        this.props = __assign(__assign({}, this.props), properties);
        this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);
      };
      PostHogCore.prototype.unregister = function(property) {
        delete this.props[property];
        this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);
      };
      PostHogCore.prototype.identify = function(distinctId, properties, options) {
        var previousDistinctId = this.getDistinctId();
        distinctId = distinctId || previousDistinctId;
        if (properties === null || properties === void 0 ? void 0 : properties.$groups) {
          this.groups(properties.$groups);
        }
        var allProperties = this.enrichProperties(__assign(__assign({}, properties), { $anon_distinct_id: this.getAnonymousId(), $set: properties }));
        if (distinctId !== previousDistinctId) {
          this.setPersistedProperty(PostHogPersistedProperty.AnonymousId, previousDistinctId);
          this.setPersistedProperty(PostHogPersistedProperty.DistinctId, distinctId);
          this.reloadFeatureFlags();
        }
        _super.prototype.identifyStateless.call(this, distinctId, allProperties, options);
        return this;
      };
      PostHogCore.prototype.capture = function(event, properties, options) {
        var distinctId = this.getDistinctId();
        if (properties === null || properties === void 0 ? void 0 : properties.$groups) {
          this.groups(properties.$groups);
        }
        var allProperties = this.enrichProperties(properties);
        _super.prototype.captureStateless.call(this, distinctId, event, allProperties, options);
        return this;
      };
      PostHogCore.prototype.alias = function(alias) {
        var distinctId = this.getDistinctId();
        var allProperties = this.enrichProperties({});
        _super.prototype.aliasStateless.call(this, alias, distinctId, allProperties);
        return this;
      };
      PostHogCore.prototype.autocapture = function(eventType, elements, properties, options) {
        if (properties === void 0) {
          properties = {};
        }
        var distinctId = this.getDistinctId();
        var payload = {
          distinct_id: distinctId,
          event: "$autocapture",
          properties: __assign(__assign({}, this.enrichProperties(properties)), { $event_type: eventType, $elements: elements })
        };
        this.enqueue("autocapture", payload, options);
        return this;
      };
      PostHogCore.prototype.groups = function(groups) {
        var existingGroups = this.props.$groups || {};
        this.register({
          $groups: __assign(__assign({}, existingGroups), groups)
        });
        if (Object.keys(groups).find(function(type) {
          return existingGroups[type] !== groups[type];
        })) {
          this.reloadFeatureFlags();
        }
        return this;
      };
      PostHogCore.prototype.group = function(groupType, groupKey, groupProperties, options) {
        var _a;
        this.groups((_a = {}, _a[groupType] = groupKey, _a));
        if (groupProperties) {
          this.groupIdentify(groupType, groupKey, groupProperties, options);
        }
        return this;
      };
      PostHogCore.prototype.groupIdentify = function(groupType, groupKey, groupProperties, options) {
        var distinctId = this.getDistinctId();
        var eventProperties = this.enrichProperties({});
        _super.prototype.groupIdentifyStateless.call(this, groupType, groupKey, groupProperties, options, distinctId, eventProperties);
        return this;
      };
      PostHogCore.prototype.personProperties = function(properties) {
        var existingProperties = this.getPersistedProperty(PostHogPersistedProperty.PersonProperties) || {};
        this.setPersistedProperty(PostHogPersistedProperty.PersonProperties, __assign(__assign({}, existingProperties), properties));
        return this;
      };
      PostHogCore.prototype.groupProperties = function(properties) {
        var existingProperties = this.getPersistedProperty(PostHogPersistedProperty.GroupProperties) || {};
        if (Object.keys(existingProperties).length !== 0) {
          Object.keys(existingProperties).forEach(function(groupType) {
            existingProperties[groupType] = __assign(__assign({}, existingProperties[groupType]), properties[groupType]);
            delete properties[groupType];
          });
        }
        this.setPersistedProperty(PostHogPersistedProperty.GroupProperties, __assign(__assign({}, existingProperties), properties));
        return this;
      };
      PostHogCore.prototype.decideAsync = function(sendAnonDistinctId) {
        if (sendAnonDistinctId === void 0) {
          sendAnonDistinctId = true;
        }
        if (this._decideResponsePromise) {
          return this._decideResponsePromise;
        }
        return this._decideAsync(sendAnonDistinctId);
      };
      PostHogCore.prototype._decideAsync = function(sendAnonDistinctId) {
        if (sendAnonDistinctId === void 0) {
          sendAnonDistinctId = true;
        }
        return __awaiter(this, void 0, void 0, function() {
          var distinctId, groups, personProperties, groupProperties, extraProperties;
          var _this = this;
          return __generator(this, function(_a) {
            distinctId = this.getDistinctId();
            groups = this.props.$groups || {};
            personProperties = this.getPersistedProperty(PostHogPersistedProperty.PersonProperties) || {};
            groupProperties = this.getPersistedProperty(PostHogPersistedProperty.GroupProperties) || {};
            extraProperties = {
              $anon_distinct_id: sendAnonDistinctId ? this.getAnonymousId() : void 0
            };
            this._decideResponsePromise = _super.prototype.getDecide.call(this, distinctId, groups, personProperties, groupProperties, extraProperties).then(function(res) {
              if (res === null || res === void 0 ? void 0 : res.featureFlags) {
                var newFeatureFlags = res.featureFlags;
                var newFeatureFlagPayloads = res.featureFlagPayloads;
                if (res.errorsWhileComputingFlags) {
                  var currentFlags = _this.getPersistedProperty(PostHogPersistedProperty.FeatureFlags);
                  var currentFlagPayloads = _this.getPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads);
                  newFeatureFlags = __assign(__assign({}, currentFlags), res.featureFlags);
                  newFeatureFlagPayloads = __assign(__assign({}, currentFlagPayloads), res.featureFlagPayloads);
                }
                _this.setKnownFeatureFlags(newFeatureFlags);
                _this.setKnownFeatureFlagPayloads(newFeatureFlagPayloads);
              }
              return res;
            }).finally(function() {
              _this._decideResponsePromise = void 0;
            });
            return [2, this._decideResponsePromise];
          });
        });
      };
      PostHogCore.prototype.setKnownFeatureFlags = function(featureFlags) {
        this.setPersistedProperty(PostHogPersistedProperty.FeatureFlags, featureFlags);
        this._events.emit("featureflags", featureFlags);
      };
      PostHogCore.prototype.setKnownFeatureFlagPayloads = function(featureFlagPayloads) {
        this.setPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads, featureFlagPayloads);
      };
      PostHogCore.prototype.getFeatureFlag = function(key) {
        var featureFlags = this.getFeatureFlags();
        if (!featureFlags) {
          return void 0;
        }
        var response = featureFlags[key];
        if (response === void 0) {
          response = false;
        }
        if (this.sendFeatureFlagEvent && !this.flagCallReported[key]) {
          this.flagCallReported[key] = true;
          this.capture("$feature_flag_called", {
            $feature_flag: key,
            $feature_flag_response: response
          });
        }
        return response;
      };
      PostHogCore.prototype.getFeatureFlagPayload = function(key) {
        var payloads = this.getFeatureFlagPayloads();
        if (!payloads) {
          return void 0;
        }
        var response = payloads[key];
        if (response === void 0) {
          return null;
        }
        return this._parsePayload(response);
      };
      PostHogCore.prototype.getFeatureFlagPayloads = function() {
        var _this = this;
        var payloads = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlagPayloads);
        if (payloads) {
          return Object.fromEntries(Object.entries(payloads).map(function(_a) {
            var k = _a[0], v = _a[1];
            return [k, _this._parsePayload(v)];
          }));
        }
        return payloads;
      };
      PostHogCore.prototype.getFeatureFlags = function() {
        var flags = this.getPersistedProperty(PostHogPersistedProperty.FeatureFlags);
        var overriddenFlags = this.getPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags);
        if (!overriddenFlags) {
          return flags;
        }
        flags = flags || {};
        for (var key in overriddenFlags) {
          if (!overriddenFlags[key]) {
            delete flags[key];
          } else {
            flags[key] = overriddenFlags[key];
          }
        }
        return flags;
      };
      PostHogCore.prototype.getFeatureFlagsAndPayloads = function() {
        var flags = this.getFeatureFlags();
        var payloads = this.getFeatureFlagPayloads();
        return {
          flags,
          payloads
        };
      };
      PostHogCore.prototype.isFeatureEnabled = function(key) {
        var response = this.getFeatureFlag(key);
        if (response === void 0) {
          return void 0;
        }
        return !!response;
      };
      PostHogCore.prototype.reloadFeatureFlags = function(cb) {
        this.decideAsync().then(function(res) {
          cb === null || cb === void 0 ? void 0 : cb(void 0, res === null || res === void 0 ? void 0 : res.featureFlags);
        }).catch(function(e2) {
          cb === null || cb === void 0 ? void 0 : cb(e2, void 0);
          if (!cb) {
            console.log("[PostHog] Error reloading feature flags", e2);
          }
        });
      };
      PostHogCore.prototype.reloadFeatureFlagsAsync = function(sendAnonDistinctId) {
        var _a;
        if (sendAnonDistinctId === void 0) {
          sendAnonDistinctId = true;
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.decideAsync(sendAnonDistinctId)];
              case 1:
                return [2, (_a = _b.sent()) === null || _a === void 0 ? void 0 : _a.featureFlags];
            }
          });
        });
      };
      PostHogCore.prototype.onFeatureFlags = function(cb) {
        var _this = this;
        return this.on("featureflags", function() {
          return __awaiter(_this, void 0, void 0, function() {
            var flags;
            return __generator(this, function(_a) {
              flags = this.getFeatureFlags();
              if (flags) {
                cb(flags);
              }
              return [
                2
                /*return*/
              ];
            });
          });
        });
      };
      PostHogCore.prototype.onFeatureFlag = function(key, cb) {
        var _this = this;
        return this.on("featureflags", function() {
          return __awaiter(_this, void 0, void 0, function() {
            var flagResponse;
            return __generator(this, function(_a) {
              flagResponse = this.getFeatureFlag(key);
              if (flagResponse !== void 0) {
                cb(flagResponse);
              }
              return [
                2
                /*return*/
              ];
            });
          });
        });
      };
      PostHogCore.prototype.overrideFeatureFlag = function(flags) {
        if (flags === null) {
          return this.setPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags, null);
        }
        return this.setPersistedProperty(PostHogPersistedProperty.OverrideFeatureFlags, flags);
      };
      return PostHogCore;
    })(PostHogCoreStateless);
    var PostHogMemoryStorage = (
      /** @class */
      function() {
        function PostHogMemoryStorage2() {
          this._memoryStorage = {};
        }
        PostHogMemoryStorage2.prototype.getProperty = function(key) {
          return this._memoryStorage[key];
        };
        PostHogMemoryStorage2.prototype.setProperty = function(key, value) {
          this._memoryStorage[key] = value !== null ? value : void 0;
        };
        return PostHogMemoryStorage2;
      }()
    );
    var fetch3 = function(url, options) {
      return __awaiter(void 0, void 0, void 0, function() {
        var res;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [
                4,
                axios__default["default"].request({
                  url,
                  headers: options.headers,
                  method: options.method.toLowerCase(),
                  data: options.body,
                  signal: options.signal,
                  // fetch only throws on network errors, not on HTTP errors
                  validateStatus: function() {
                    return true;
                  }
                })
              ];
            case 1:
              res = _a.sent();
              return [
                2,
                {
                  status: res.status,
                  text: function() {
                    return __awaiter(void 0, void 0, void 0, function() {
                      return __generator(this, function(_a2) {
                        return [
                          2,
                          res.data
                        ];
                      });
                    });
                  },
                  json: function() {
                    return __awaiter(void 0, void 0, void 0, function() {
                      return __generator(this, function(_a2) {
                        return [
                          2,
                          res.data
                        ];
                      });
                    });
                  }
                }
              ];
          }
        });
      });
    };
    var LONG_SCALE = 1152921504606847e3;
    var ClientError = (
      /** @class */
      function(_super) {
        __extends(ClientError2, _super);
        function ClientError2(message) {
          var _this = _super.call(this) || this;
          Error.captureStackTrace(_this, _this.constructor);
          _this.name = "ClientError";
          _this.message = message;
          Object.setPrototypeOf(_this, ClientError2.prototype);
          return _this;
        }
        return ClientError2;
      }(Error)
    );
    var InconclusiveMatchError = (
      /** @class */
      function(_super) {
        __extends(InconclusiveMatchError2, _super);
        function InconclusiveMatchError2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = _this.constructor.name;
          Error.captureStackTrace(_this, _this.constructor);
          Object.setPrototypeOf(_this, InconclusiveMatchError2.prototype);
          return _this;
        }
        return InconclusiveMatchError2;
      }(Error)
    );
    var FeatureFlagsPoller = (
      /** @class */
      function() {
        function FeatureFlagsPoller2(_a) {
          var pollingInterval = _a.pollingInterval, personalApiKey = _a.personalApiKey, projectApiKey = _a.projectApiKey, timeout = _a.timeout, host = _a.host, options = __rest(_a, ["pollingInterval", "personalApiKey", "projectApiKey", "timeout", "host"]);
          this.debugMode = false;
          this.pollingInterval = pollingInterval;
          this.personalApiKey = personalApiKey;
          this.featureFlags = [];
          this.featureFlagsByKey = {};
          this.groupTypeMapping = {};
          this.cohorts = {};
          this.loadedSuccessfullyOnce = false;
          this.timeout = timeout;
          this.projectApiKey = projectApiKey;
          this.host = host;
          this.poller = void 0;
          this.fetch = options.fetch || fetch3;
          void this.loadFeatureFlags();
        }
        FeatureFlagsPoller2.prototype.debug = function(enabled) {
          if (enabled === void 0) {
            enabled = true;
          }
          this.debugMode = enabled;
        };
        FeatureFlagsPoller2.prototype.getFeatureFlag = function(key, distinctId, groups, personProperties, groupProperties) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, featureFlag, _i, _a, flag;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.loadFeatureFlags()
                  ];
                case 1:
                  _b.sent();
                  response = void 0;
                  featureFlag = void 0;
                  if (!this.loadedSuccessfullyOnce) {
                    return [
                      2,
                      response
                    ];
                  }
                  for (_i = 0, _a = this.featureFlags; _i < _a.length; _i++) {
                    flag = _a[_i];
                    if (key === flag.key) {
                      featureFlag = flag;
                      break;
                    }
                  }
                  if (featureFlag !== void 0) {
                    try {
                      response = this.computeFlagLocally(featureFlag, distinctId, groups, personProperties, groupProperties);
                      if (this.debugMode) {
                        console.debug("Successfully computed flag locally: ".concat(key, " -> ").concat(response));
                      }
                    } catch (e2) {
                      if (e2 instanceof InconclusiveMatchError) {
                        if (this.debugMode) {
                          console.debug("InconclusiveMatchError when computing flag locally: ".concat(key, ": ").concat(e2));
                        }
                      } else if (e2 instanceof Error) {
                        console.error("Error computing flag locally: ".concat(key, ": ").concat(e2));
                      }
                    }
                  }
                  return [
                    2,
                    response
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype.computeFeatureFlagPayloadLocally = function(key, matchValue) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_j) {
              switch (_j.label) {
                case 0:
                  return [
                    4,
                    this.loadFeatureFlags()
                  ];
                case 1:
                  _j.sent();
                  response = void 0;
                  if (!this.loadedSuccessfullyOnce) {
                    return [
                      2,
                      void 0
                    ];
                  }
                  if (typeof matchValue == "boolean") {
                    response = (_d = (_c = (_b = (_a = this.featureFlagsByKey) === null || _a === void 0 ? void 0 : _a[key]) === null || _b === void 0 ? void 0 : _b.filters) === null || _c === void 0 ? void 0 : _c.payloads) === null || _d === void 0 ? void 0 : _d[matchValue.toString()];
                  } else if (typeof matchValue == "string") {
                    response = (_h = (_g = (_f = (_e = this.featureFlagsByKey) === null || _e === void 0 ? void 0 : _e[key]) === null || _f === void 0 ? void 0 : _f.filters) === null || _g === void 0 ? void 0 : _g.payloads) === null || _h === void 0 ? void 0 : _h[matchValue];
                  }
                  if (response === void 0) {
                    return [
                      2,
                      null
                    ];
                  }
                  return [
                    2,
                    response
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype.getAllFlagsAndPayloads = function(distinctId, groups, personProperties, groupProperties) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, payloads, fallbackToDecide;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [
                    4,
                    this.loadFeatureFlags()
                  ];
                case 1:
                  _a.sent();
                  response = {};
                  payloads = {};
                  fallbackToDecide = this.featureFlags.length == 0;
                  this.featureFlags.map(function(flag) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var matchValue, matchPayload, e_1;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            _a2.trys.push([0, 2, , 3]);
                            matchValue = this.computeFlagLocally(flag, distinctId, groups, personProperties, groupProperties);
                            response[flag.key] = matchValue;
                            return [
                              4,
                              this.computeFeatureFlagPayloadLocally(flag.key, matchValue)
                            ];
                          case 1:
                            matchPayload = _a2.sent();
                            if (matchPayload) {
                              payloads[flag.key] = matchPayload;
                            }
                            return [
                              3,
                              3
                            ];
                          case 2:
                            e_1 = _a2.sent();
                            if (e_1 instanceof InconclusiveMatchError)
                              ;
                            else if (e_1 instanceof Error) {
                              console.error("Error computing flag locally: ".concat(flag.key, ": ").concat(e_1));
                            }
                            fallbackToDecide = true;
                            return [
                              3,
                              3
                            ];
                          case 3:
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  });
                  return [
                    2,
                    {
                      response,
                      payloads,
                      fallbackToDecide
                    }
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype.computeFlagLocally = function(flag, distinctId, groups, personProperties, groupProperties) {
          if (groups === void 0) {
            groups = {};
          }
          if (personProperties === void 0) {
            personProperties = {};
          }
          if (groupProperties === void 0) {
            groupProperties = {};
          }
          if (flag.ensure_experience_continuity) {
            throw new InconclusiveMatchError("Flag has experience continuity enabled");
          }
          if (!flag.active) {
            return false;
          }
          var flagFilters = flag.filters || {};
          var aggregation_group_type_index = flagFilters.aggregation_group_type_index;
          if (aggregation_group_type_index != void 0) {
            var groupName = this.groupTypeMapping[String(aggregation_group_type_index)];
            if (!groupName) {
              console.warn("[FEATURE FLAGS] Unknown group type index ".concat(aggregation_group_type_index, " for feature flag ").concat(flag.key));
              throw new InconclusiveMatchError("Flag has unknown group type index");
            }
            if (!(groupName in groups)) {
              console.warn("[FEATURE FLAGS] Can't compute group feature flag: ".concat(flag.key, " without group names passed in"));
              return false;
            }
            var focusedGroupProperties = groupProperties[groupName];
            return this.matchFeatureFlagProperties(flag, groups[groupName], focusedGroupProperties);
          } else {
            return this.matchFeatureFlagProperties(flag, distinctId, personProperties);
          }
        };
        FeatureFlagsPoller2.prototype.matchFeatureFlagProperties = function(flag, distinctId, properties) {
          var _a;
          var flagFilters = flag.filters || {};
          var flagConditions = flagFilters.groups || [];
          var isInconclusive = false;
          var result = void 0;
          var sortedFlagConditions = __spreadArray([], flagConditions, true).sort(function(conditionA, conditionB) {
            var AHasVariantOverride = !!conditionA.variant;
            var BHasVariantOverride = !!conditionB.variant;
            if (AHasVariantOverride && BHasVariantOverride) {
              return 0;
            } else if (AHasVariantOverride) {
              return -1;
            } else if (BHasVariantOverride) {
              return 1;
            } else {
              return 0;
            }
          });
          var _loop_1 = function(condition2) {
            try {
              if (this_1.isConditionMatch(flag, distinctId, condition2, properties)) {
                var variantOverride_1 = condition2.variant;
                var flagVariants = ((_a = flagFilters.multivariate) === null || _a === void 0 ? void 0 : _a.variants) || [];
                if (variantOverride_1 && flagVariants.some(function(variant) {
                  return variant.key === variantOverride_1;
                })) {
                  result = variantOverride_1;
                } else {
                  result = this_1.getMatchingVariant(flag, distinctId) || true;
                }
                return "break";
              }
            } catch (e2) {
              if (e2 instanceof InconclusiveMatchError) {
                isInconclusive = true;
              } else {
                throw e2;
              }
            }
          };
          var this_1 = this;
          for (var _i = 0, sortedFlagConditions_1 = sortedFlagConditions; _i < sortedFlagConditions_1.length; _i++) {
            var condition = sortedFlagConditions_1[_i];
            var state_1 = _loop_1(condition);
            if (state_1 === "break")
              break;
          }
          if (result !== void 0) {
            return result;
          } else if (isInconclusive) {
            throw new InconclusiveMatchError("Can't determine if feature flag is enabled or not with given properties");
          }
          return false;
        };
        FeatureFlagsPoller2.prototype.isConditionMatch = function(flag, distinctId, condition, properties) {
          var rolloutPercentage = condition.rollout_percentage;
          if ((condition.properties || []).length > 0) {
            for (var _i = 0, _a = condition.properties; _i < _a.length; _i++) {
              var prop = _a[_i];
              var propertyType = prop.type;
              var matches = false;
              if (propertyType === "cohort") {
                matches = matchCohort(prop, properties, this.cohorts);
              } else {
                matches = matchProperty(prop, properties);
              }
              if (!matches) {
                return false;
              }
            }
            if (rolloutPercentage == void 0) {
              return true;
            }
          }
          if (rolloutPercentage != void 0 && _hash(flag.key, distinctId) > rolloutPercentage / 100) {
            return false;
          }
          return true;
        };
        FeatureFlagsPoller2.prototype.getMatchingVariant = function(flag, distinctId) {
          var hashValue = _hash(flag.key, distinctId, "variant");
          var matchingVariant = this.variantLookupTable(flag).find(function(variant) {
            return hashValue >= variant.valueMin && hashValue < variant.valueMax;
          });
          if (matchingVariant) {
            return matchingVariant.key;
          }
          return void 0;
        };
        FeatureFlagsPoller2.prototype.variantLookupTable = function(flag) {
          var _a;
          var lookupTable = [];
          var valueMin = 0;
          var valueMax = 0;
          var flagFilters = flag.filters || {};
          var multivariates = ((_a = flagFilters.multivariate) === null || _a === void 0 ? void 0 : _a.variants) || [];
          multivariates.forEach(function(variant) {
            valueMax = valueMin + variant.rollout_percentage / 100;
            lookupTable.push({
              valueMin,
              valueMax,
              key: variant.key
            });
            valueMin = valueMax;
          });
          return lookupTable;
        };
        FeatureFlagsPoller2.prototype.loadFeatureFlags = function(forceReload) {
          if (forceReload === void 0) {
            forceReload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!(!this.loadedSuccessfullyOnce || forceReload))
                    return [
                      3,
                      2
                    ];
                  return [
                    4,
                    this._loadFeatureFlags()
                  ];
                case 1:
                  _a.sent();
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype._loadFeatureFlags = function() {
          return __awaiter(this, void 0, void 0, function() {
            var res, responseJson, err_1;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (this.poller) {
                    clearTimeout(this.poller);
                    this.poller = void 0;
                  }
                  this.poller = setTimeout(function() {
                    return _this._loadFeatureFlags();
                  }, this.pollingInterval);
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 5]);
                  return [
                    4,
                    this._requestFeatureFlagDefinitions()
                  ];
                case 2:
                  res = _a.sent();
                  if (res && res.status === 401) {
                    throw new ClientError("Your personalApiKey is invalid. Are you sure you're not using your Project API key? More information: https://posthog.com/docs/api/overview");
                  }
                  if (res && res.status !== 200) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  return [
                    4,
                    res.json()
                  ];
                case 3:
                  responseJson = _a.sent();
                  if (!("flags" in responseJson)) {
                    console.error("Invalid response when getting feature flags: ".concat(JSON.stringify(responseJson)));
                  }
                  this.featureFlags = responseJson.flags || [];
                  this.featureFlagsByKey = this.featureFlags.reduce(function(acc, curr) {
                    return acc[curr.key] = curr, acc;
                  }, {});
                  this.groupTypeMapping = responseJson.group_type_mapping || {};
                  this.cohorts = responseJson.cohorts || [];
                  this.loadedSuccessfullyOnce = true;
                  return [
                    3,
                    5
                  ];
                case 4:
                  err_1 = _a.sent();
                  if (err_1 instanceof ClientError) {
                    throw err_1;
                  }
                  return [
                    3,
                    5
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype._requestFeatureFlagDefinitions = function() {
          return __awaiter(this, void 0, void 0, function() {
            var url, options, abortTimeout, controller_1, err_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  url = "".concat(this.host, "/api/feature_flag/local_evaluation?token=").concat(this.projectApiKey, "&send_cohorts");
                  options = {
                    method: "GET",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: "Bearer ".concat(this.personalApiKey),
                      "user-agent": "posthog-node/".concat(version2)
                    }
                  };
                  abortTimeout = null;
                  if (this.timeout && typeof this.timeout === "number") {
                    controller_1 = new AbortController();
                    abortTimeout = safeSetTimeout(function() {
                      controller_1.abort();
                    }, this.timeout);
                    options.signal = controller_1.signal;
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, 4, 5]);
                  return [
                    4,
                    this.fetch(url, options)
                  ];
                case 2:
                  return [
                    2,
                    _a.sent()
                  ];
                case 3:
                  err_2 = _a.sent();
                  throw err_2;
                case 4:
                  clearTimeout(abortTimeout);
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FeatureFlagsPoller2.prototype.stopPoller = function() {
          clearTimeout(this.poller);
        };
        return FeatureFlagsPoller2;
      }()
    );
    function _hash(key, distinctId, salt) {
      if (salt === void 0) {
        salt = "";
      }
      var sha1Hash = rusha.createHash();
      sha1Hash.update("".concat(key, ".").concat(distinctId).concat(salt));
      return parseInt(sha1Hash.digest("hex").slice(0, 15), 16) / LONG_SCALE;
    }
    function matchProperty(property, propertyValues) {
      var key = property.key;
      var value = property.value;
      var operator = property.operator || "exact";
      if (!(key in propertyValues)) {
        throw new InconclusiveMatchError("Property ".concat(key, " not found in propertyValues"));
      } else if (operator === "is_not_set") {
        throw new InconclusiveMatchError("Operator is_not_set is not supported");
      }
      var overrideValue = propertyValues[key];
      switch (operator) {
        case "exact":
          return Array.isArray(value) ? value.indexOf(overrideValue) !== -1 : value === overrideValue;
        case "is_not":
          return Array.isArray(value) ? value.indexOf(overrideValue) === -1 : value !== overrideValue;
        case "is_set":
          return key in propertyValues;
        case "icontains":
          return String(overrideValue).toLowerCase().includes(String(value).toLowerCase());
        case "not_icontains":
          return !String(overrideValue).toLowerCase().includes(String(value).toLowerCase());
        case "regex":
          return isValidRegex(String(value)) && String(overrideValue).match(String(value)) !== null;
        case "not_regex":
          return isValidRegex(String(value)) && String(overrideValue).match(String(value)) === null;
        case "gt":
          return typeof overrideValue == typeof value && overrideValue > value;
        case "gte":
          return typeof overrideValue == typeof value && overrideValue >= value;
        case "lt":
          return typeof overrideValue == typeof value && overrideValue < value;
        case "lte":
          return typeof overrideValue == typeof value && overrideValue <= value;
        case "is_date_after":
        case "is_date_before":
          var parsedDate = convertToDateTime(value);
          var overrideDate = convertToDateTime(overrideValue);
          if (operator === "is_date_before") {
            return overrideDate < parsedDate;
          }
          return overrideDate > parsedDate;
        default:
          console.error("Unknown operator: ".concat(operator));
          return false;
      }
    }
    function matchCohort(property, propertyValues, cohortProperties) {
      var cohortId = String(property.value);
      if (!(cohortId in cohortProperties)) {
        throw new InconclusiveMatchError("can't match cohort without a given cohort property value");
      }
      var propertyGroup = cohortProperties[cohortId];
      return matchPropertyGroup(propertyGroup, propertyValues, cohortProperties);
    }
    function matchPropertyGroup(propertyGroup, propertyValues, cohortProperties) {
      if (!propertyGroup) {
        return true;
      }
      var propertyGroupType = propertyGroup.type;
      var properties = propertyGroup.values;
      if (!properties || properties.length === 0) {
        return true;
      }
      var errorMatchingLocally = false;
      if ("values" in properties[0]) {
        for (var _i = 0, _a = properties; _i < _a.length; _i++) {
          var prop = _a[_i];
          try {
            var matches = matchPropertyGroup(prop, propertyValues, cohortProperties);
            if (propertyGroupType === "AND") {
              if (!matches) {
                return false;
              }
            } else {
              if (matches) {
                return true;
              }
            }
          } catch (err) {
            if (err instanceof InconclusiveMatchError) {
              console.debug("Failed to compute property ".concat(prop, " locally: ").concat(err));
              errorMatchingLocally = true;
            } else {
              throw err;
            }
          }
        }
        if (errorMatchingLocally) {
          throw new InconclusiveMatchError("Can't match cohort without a given cohort property value");
        }
        return propertyGroupType === "AND";
      } else {
        for (var _b = 0, _c = properties; _b < _c.length; _b++) {
          var prop = _c[_b];
          try {
            var matches = void 0;
            if (prop.type === "cohort") {
              matches = matchCohort(prop, propertyValues, cohortProperties);
            } else {
              matches = matchProperty(prop, propertyValues);
            }
            var negation = prop.negation || false;
            if (propertyGroupType === "AND") {
              if (!matches && !negation) {
                return false;
              }
              if (matches && negation) {
                return false;
              }
            } else {
              if (matches && !negation) {
                return true;
              }
              if (!matches && negation) {
                return true;
              }
            }
          } catch (err) {
            if (err instanceof InconclusiveMatchError) {
              console.debug("Failed to compute property ".concat(prop, " locally: ").concat(err));
              errorMatchingLocally = true;
            } else {
              throw err;
            }
          }
        }
        if (errorMatchingLocally) {
          throw new InconclusiveMatchError("can't match cohort without a given cohort property value");
        }
        return propertyGroupType === "AND";
      }
    }
    function isValidRegex(regex) {
      try {
        new RegExp(regex);
        return true;
      } catch (err) {
        return false;
      }
    }
    function convertToDateTime(value) {
      if (value instanceof Date) {
        return value;
      } else if (typeof value === "string" || typeof value === "number") {
        var date = new Date(value);
        if (!isNaN(date.valueOf())) {
          return date;
        }
        throw new InconclusiveMatchError("".concat(value, " is in an invalid date format"));
      } else {
        throw new InconclusiveMatchError("The date provided ".concat(value, " must be a string, number, or date object"));
      }
    }
    var THIRTY_SECONDS = 30 * 1e3;
    var MAX_CACHE_SIZE = 50 * 1e3;
    var PostHog3 = (
      /** @class */
      function(_super) {
        __extends(PostHog4, _super);
        function PostHog4(apiKey, options) {
          if (options === void 0) {
            options = {};
          }
          var _this = this;
          var _a;
          options.captureMode = (options === null || options === void 0 ? void 0 : options.captureMode) || "json";
          _this = _super.call(this, apiKey, options) || this;
          _this._memoryStorage = new PostHogMemoryStorage();
          _this.options = options;
          if (options.personalApiKey) {
            _this.featureFlagsPoller = new FeatureFlagsPoller({
              pollingInterval: typeof options.featureFlagsPollingInterval === "number" ? options.featureFlagsPollingInterval : THIRTY_SECONDS,
              personalApiKey: options.personalApiKey,
              projectApiKey: apiKey,
              timeout: (_a = options.requestTimeout) !== null && _a !== void 0 ? _a : 1e4,
              host: _this.host,
              fetch: options.fetch
            });
          }
          _this.distinctIdHasSentFlagCalls = {};
          _this.maxCacheSize = options.maxCacheSize || MAX_CACHE_SIZE;
          return _this;
        }
        PostHog4.prototype.getPersistedProperty = function(key) {
          return this._memoryStorage.getProperty(key);
        };
        PostHog4.prototype.setPersistedProperty = function(key, value) {
          return this._memoryStorage.setProperty(key, value);
        };
        PostHog4.prototype.fetch = function(url, options) {
          return this.options.fetch ? this.options.fetch(url, options) : fetch3(url, options);
        };
        PostHog4.prototype.getLibraryId = function() {
          return "posthog-node";
        };
        PostHog4.prototype.getLibraryVersion = function() {
          return version2;
        };
        PostHog4.prototype.getCustomUserAgent = function() {
          return "posthog-node/".concat(version2);
        };
        PostHog4.prototype.enable = function() {
          return _super.prototype.optIn.call(this);
        };
        PostHog4.prototype.disable = function() {
          return _super.prototype.optOut.call(this);
        };
        PostHog4.prototype.debug = function(enabled) {
          var _a;
          if (enabled === void 0) {
            enabled = true;
          }
          _super.prototype.debug.call(this, enabled);
          (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.debug(enabled);
        };
        PostHog4.prototype.capture = function(_a) {
          var _this = this;
          var distinctId = _a.distinctId, event = _a.event, properties = _a.properties, groups = _a.groups, sendFeatureFlags = _a.sendFeatureFlags, timestamp = _a.timestamp, disableGeoip = _a.disableGeoip;
          var _capture = function(props) {
            _super.prototype.captureStateless.call(_this, distinctId, event, props, {
              timestamp,
              disableGeoip
            });
          };
          if (sendFeatureFlags) {
            _super.prototype.getFeatureFlagsStateless.call(this, distinctId, groups, void 0, void 0, disableGeoip).then(function(flags) {
              var featureVariantProperties = {};
              if (flags) {
                for (var _i = 0, _a2 = Object.entries(flags); _i < _a2.length; _i++) {
                  var _b = _a2[_i], feature = _b[0], variant = _b[1];
                  if (variant !== false) {
                    featureVariantProperties["$feature/".concat(feature)] = variant;
                  }
                }
              }
              var activeFlags = Object.keys(flags || {}).filter(function(flag) {
                return (flags === null || flags === void 0 ? void 0 : flags[flag]) !== false;
              });
              var flagProperties = __assign({
                $active_feature_flags: activeFlags || void 0
              }, featureVariantProperties);
              _capture(__assign(__assign(__assign({}, properties), {
                $groups: groups
              }), flagProperties));
            });
          } else {
            _capture(__assign(__assign({}, properties), {
              $groups: groups
            }));
          }
        };
        PostHog4.prototype.identify = function(_a) {
          var distinctId = _a.distinctId, properties = _a.properties, disableGeoip = _a.disableGeoip;
          var personProperties = (properties === null || properties === void 0 ? void 0 : properties.$set) || properties;
          _super.prototype.identifyStateless.call(this, distinctId, {
            $set: personProperties
          }, {
            disableGeoip
          });
        };
        PostHog4.prototype.alias = function(data) {
          _super.prototype.aliasStateless.call(this, data.alias, data.distinctId, void 0, {
            disableGeoip: data.disableGeoip
          });
        };
        PostHog4.prototype.getFeatureFlag = function(key, distinctId, options) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            var _b, groups, personProperties, groupProperties, disableGeoip, _c, onlyEvaluateLocally, sendFeatureFlagEvents, response, flagWasLocallyEvaluated, featureFlagReportedKey;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  _b = options || {}, groups = _b.groups, personProperties = _b.personProperties, groupProperties = _b.groupProperties, disableGeoip = _b.disableGeoip;
                  _c = options || {}, onlyEvaluateLocally = _c.onlyEvaluateLocally, sendFeatureFlagEvents = _c.sendFeatureFlagEvents;
                  if (onlyEvaluateLocally == void 0) {
                    onlyEvaluateLocally = false;
                  }
                  if (sendFeatureFlagEvents == void 0) {
                    sendFeatureFlagEvents = true;
                  }
                  return [
                    4,
                    (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.getFeatureFlag(key, distinctId, groups, personProperties, groupProperties)
                  ];
                case 1:
                  response = _d.sent();
                  flagWasLocallyEvaluated = response !== void 0;
                  if (!(!flagWasLocallyEvaluated && !onlyEvaluateLocally))
                    return [
                      3,
                      3
                    ];
                  return [
                    4,
                    _super.prototype.getFeatureFlagStateless.call(this, key, distinctId, groups, personProperties, groupProperties, disableGeoip)
                  ];
                case 2:
                  response = _d.sent();
                  _d.label = 3;
                case 3:
                  featureFlagReportedKey = "".concat(key, "_").concat(response);
                  if (sendFeatureFlagEvents && (!(distinctId in this.distinctIdHasSentFlagCalls) || !this.distinctIdHasSentFlagCalls[distinctId].includes(featureFlagReportedKey))) {
                    if (Object.keys(this.distinctIdHasSentFlagCalls).length >= this.maxCacheSize) {
                      this.distinctIdHasSentFlagCalls = {};
                    }
                    if (Array.isArray(this.distinctIdHasSentFlagCalls[distinctId])) {
                      this.distinctIdHasSentFlagCalls[distinctId].push(featureFlagReportedKey);
                    } else {
                      this.distinctIdHasSentFlagCalls[distinctId] = [featureFlagReportedKey];
                    }
                    this.capture({
                      distinctId,
                      event: "$feature_flag_called",
                      properties: {
                        $feature_flag: key,
                        $feature_flag_response: response,
                        locally_evaluated: flagWasLocallyEvaluated
                      },
                      groups,
                      disableGeoip
                    });
                  }
                  return [
                    2,
                    response
                  ];
              }
            });
          });
        };
        PostHog4.prototype.getFeatureFlagPayload = function(key, distinctId, matchValue, options) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            var _b, groups, personProperties, groupProperties, disableGeoip, _c, onlyEvaluateLocally, response, payloadWasLocallyEvaluated;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  _b = options || {}, groups = _b.groups, personProperties = _b.personProperties, groupProperties = _b.groupProperties, disableGeoip = _b.disableGeoip;
                  _c = options || {}, onlyEvaluateLocally = _c.onlyEvaluateLocally, _c.sendFeatureFlagEvents;
                  response = void 0;
                  if (!!matchValue)
                    return [
                      3,
                      2
                    ];
                  return [
                    4,
                    this.getFeatureFlag(key, distinctId, __assign(__assign({}, options), {
                      onlyEvaluateLocally: true
                    }))
                  ];
                case 1:
                  matchValue = _d.sent();
                  _d.label = 2;
                case 2:
                  if (!matchValue)
                    return [
                      3,
                      4
                    ];
                  return [
                    4,
                    (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.computeFeatureFlagPayloadLocally(key, matchValue)
                  ];
                case 3:
                  response = _d.sent();
                  _d.label = 4;
                case 4:
                  if (onlyEvaluateLocally == void 0) {
                    onlyEvaluateLocally = false;
                  }
                  if (onlyEvaluateLocally == void 0) {
                    onlyEvaluateLocally = false;
                  }
                  payloadWasLocallyEvaluated = response !== void 0;
                  if (!(!payloadWasLocallyEvaluated && !onlyEvaluateLocally))
                    return [
                      3,
                      6
                    ];
                  return [
                    4,
                    _super.prototype.getFeatureFlagPayloadStateless.call(this, key, distinctId, groups, personProperties, groupProperties, disableGeoip)
                  ];
                case 5:
                  response = _d.sent();
                  _d.label = 6;
                case 6:
                  try {
                    return [
                      2,
                      JSON.parse(response)
                    ];
                  } catch (_e) {
                    return [
                      2,
                      response
                    ];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PostHog4.prototype.isFeatureEnabled = function(key, distinctId, options) {
          return __awaiter(this, void 0, void 0, function() {
            var feat;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [
                    4,
                    this.getFeatureFlag(key, distinctId, options)
                  ];
                case 1:
                  feat = _a.sent();
                  if (feat === void 0) {
                    return [
                      2,
                      void 0
                    ];
                  }
                  return [
                    2,
                    !!feat || false
                  ];
              }
            });
          });
        };
        PostHog4.prototype.getAllFlags = function(distinctId, options) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [
                    4,
                    this.getAllFlagsAndPayloads(distinctId, options)
                  ];
                case 1:
                  response = _a.sent();
                  return [
                    2,
                    response.featureFlags
                  ];
              }
            });
          });
        };
        PostHog4.prototype.getAllFlagsAndPayloads = function(distinctId, options) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            var _b, groups, personProperties, groupProperties, disableGeoip, onlyEvaluateLocally, localEvaluationResult, featureFlags, featureFlagPayloads, fallbackToDecide, remoteEvaluationResult;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _b = options || {}, groups = _b.groups, personProperties = _b.personProperties, groupProperties = _b.groupProperties, disableGeoip = _b.disableGeoip;
                  onlyEvaluateLocally = (options || {}).onlyEvaluateLocally;
                  if (onlyEvaluateLocally == void 0) {
                    onlyEvaluateLocally = false;
                  }
                  return [
                    4,
                    (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.getAllFlagsAndPayloads(distinctId, groups, personProperties, groupProperties)
                  ];
                case 1:
                  localEvaluationResult = _c.sent();
                  featureFlags = {};
                  featureFlagPayloads = {};
                  fallbackToDecide = true;
                  if (localEvaluationResult) {
                    featureFlags = localEvaluationResult.response;
                    featureFlagPayloads = localEvaluationResult.payloads;
                    fallbackToDecide = localEvaluationResult.fallbackToDecide;
                  }
                  if (!(fallbackToDecide && !onlyEvaluateLocally))
                    return [
                      3,
                      3
                    ];
                  return [
                    4,
                    _super.prototype.getFeatureFlagsAndPayloadsStateless.call(this, distinctId, groups, personProperties, groupProperties, disableGeoip)
                  ];
                case 2:
                  remoteEvaluationResult = _c.sent();
                  featureFlags = __assign(__assign({}, featureFlags), remoteEvaluationResult.flags || {});
                  featureFlagPayloads = __assign(__assign({}, featureFlagPayloads), remoteEvaluationResult.payloads || {});
                  _c.label = 3;
                case 3:
                  return [
                    2,
                    {
                      featureFlags,
                      featureFlagPayloads
                    }
                  ];
              }
            });
          });
        };
        PostHog4.prototype.groupIdentify = function(_a) {
          var groupType = _a.groupType, groupKey = _a.groupKey, properties = _a.properties, distinctId = _a.distinctId, disableGeoip = _a.disableGeoip;
          _super.prototype.groupIdentifyStateless.call(this, groupType, groupKey, properties, {
            disableGeoip
          }, distinctId);
        };
        PostHog4.prototype.reloadFeatureFlags = function() {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.loadFeatureFlags(true)
                  ];
                case 1:
                  _b.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PostHog4.prototype.shutdown = function() {
          void this.shutdownAsync();
        };
        PostHog4.prototype.shutdownAsync = function() {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              (_a = this.featureFlagsPoller) === null || _a === void 0 ? void 0 : _a.stopPoller();
              return [
                2,
                _super.prototype.shutdownAsync.call(this)
              ];
            });
          });
        };
        return PostHog4;
      }(PostHogCoreStateless)
    );
    exports.PostHog = PostHog3;
  }
});

// ../../node_modules/cli-table3/src/debug.js
var require_debug2 = __commonJS({
  "../../node_modules/cli-table3/src/debug.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var messages = [];
    var level = 0;
    var debug = (msg, min) => {
      if (level >= min) {
        messages.push(msg);
      }
    };
    debug.WARN = 1;
    debug.INFO = 2;
    debug.DEBUG = 3;
    debug.reset = () => {
      messages = [];
    };
    debug.setDebugLevel = (v) => {
      level = v;
    };
    debug.warn = (msg) => debug(msg, debug.WARN);
    debug.info = (msg) => debug(msg, debug.INFO);
    debug.debug = (msg) => debug(msg, debug.DEBUG);
    debug.debugMessages = () => messages;
    module.exports = debug;
  }
});

// ../../node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../../node_modules/ansi-regex/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../../node_modules/strip-ansi/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var ansiRegex = require_ansi_regex();
    module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// ../../node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "../../node_modules/is-fullwidth-code-point/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module.exports = isFullwidthCodePoint;
    module.exports.default = isFullwidthCodePoint;
  }
});

// ../../node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "../../node_modules/emoji-regex/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// ../../node_modules/string-width/index.js
var require_string_width = __commonJS({
  "../../node_modules/string-width/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex2 = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex2(), "  ");
      let width = 0;
      for (let i2 = 0; i2 < string.length; i2++) {
        const code = string.codePointAt(i2);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i2++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module.exports = stringWidth;
    module.exports.default = stringWidth;
  }
});

// ../../node_modules/cli-table3/src/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/cli-table3/src/utils.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var stringWidth = require_string_width();
    function codeRegex(capture2) {
      return capture2 ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
    }
    function strlen(str) {
      let code = codeRegex();
      let stripped = ("" + str).replace(code, "");
      let split = stripped.split("\n");
      return split.reduce(function(memo, s2) {
        return stringWidth(s2) > memo ? stringWidth(s2) : memo;
      }, 0);
    }
    function repeat(str, times) {
      return Array(times + 1).join(str);
    }
    function pad(str, len, pad2, dir) {
      let length = strlen(str);
      if (len + 1 >= length) {
        let padlen = len - length;
        switch (dir) {
          case "right": {
            str = repeat(pad2, padlen) + str;
            break;
          }
          case "center": {
            let right = Math.ceil(padlen / 2);
            let left = padlen - right;
            str = repeat(pad2, left) + str + repeat(pad2, right);
            break;
          }
          default: {
            str = str + repeat(pad2, padlen);
            break;
          }
        }
      }
      return str;
    }
    var codeCache = {};
    function addToCodeCache(name, on, off) {
      on = "\x1B[" + on + "m";
      off = "\x1B[" + off + "m";
      codeCache[on] = { set: name, to: true };
      codeCache[off] = { set: name, to: false };
      codeCache[name] = { on, off };
    }
    addToCodeCache("bold", 1, 22);
    addToCodeCache("italics", 3, 23);
    addToCodeCache("underline", 4, 24);
    addToCodeCache("inverse", 7, 27);
    addToCodeCache("strikethrough", 9, 29);
    function updateState(state, controlChars) {
      let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
      if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) {
        state.lastForegroundAdded = controlChars[0];
        return;
      }
      if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) {
        state.lastBackgroundAdded = controlChars[0];
        return;
      }
      if (controlCode === 0) {
        for (let i2 in state) {
          if (Object.prototype.hasOwnProperty.call(state, i2)) {
            delete state[i2];
          }
        }
        return;
      }
      let info = codeCache[controlChars[0]];
      if (info) {
        state[info.set] = info.to;
      }
    }
    function readState(line) {
      let code = codeRegex(true);
      let controlChars = code.exec(line);
      let state = {};
      while (controlChars !== null) {
        updateState(state, controlChars);
        controlChars = code.exec(line);
      }
      return state;
    }
    function unwindState(state, ret) {
      let lastBackgroundAdded = state.lastBackgroundAdded;
      let lastForegroundAdded = state.lastForegroundAdded;
      delete state.lastBackgroundAdded;
      delete state.lastForegroundAdded;
      Object.keys(state).forEach(function(key) {
        if (state[key]) {
          ret += codeCache[key].off;
        }
      });
      if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
        ret += "\x1B[49m";
      }
      if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
        ret += "\x1B[39m";
      }
      return ret;
    }
    function rewindState(state, ret) {
      let lastBackgroundAdded = state.lastBackgroundAdded;
      let lastForegroundAdded = state.lastForegroundAdded;
      delete state.lastBackgroundAdded;
      delete state.lastForegroundAdded;
      Object.keys(state).forEach(function(key) {
        if (state[key]) {
          ret = codeCache[key].on + ret;
        }
      });
      if (lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") {
        ret = lastBackgroundAdded + ret;
      }
      if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") {
        ret = lastForegroundAdded + ret;
      }
      return ret;
    }
    function truncateWidth(str, desiredLength) {
      if (str.length === strlen(str)) {
        return str.substr(0, desiredLength);
      }
      while (strlen(str) > desiredLength) {
        str = str.slice(0, -1);
      }
      return str;
    }
    function truncateWidthWithAnsi(str, desiredLength) {
      let code = codeRegex(true);
      let split = str.split(codeRegex());
      let splitIndex = 0;
      let retLen = 0;
      let ret = "";
      let myArray;
      let state = {};
      while (retLen < desiredLength) {
        myArray = code.exec(str);
        let toAdd = split[splitIndex];
        splitIndex++;
        if (retLen + strlen(toAdd) > desiredLength) {
          toAdd = truncateWidth(toAdd, desiredLength - retLen);
        }
        ret += toAdd;
        retLen += strlen(toAdd);
        if (retLen < desiredLength) {
          if (!myArray) {
            break;
          }
          ret += myArray[0];
          updateState(state, myArray);
        }
      }
      return unwindState(state, ret);
    }
    function truncate(str, desiredLength, truncateChar) {
      truncateChar = truncateChar || "\u2026";
      let lengthOfStr = strlen(str);
      if (lengthOfStr <= desiredLength) {
        return str;
      }
      desiredLength -= strlen(truncateChar);
      let ret = truncateWidthWithAnsi(str, desiredLength);
      return ret + truncateChar;
    }
    function defaultOptions() {
      return {
        chars: {
          top: "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          bottom: "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          left: "\u2502",
          "left-mid": "\u251C",
          mid: "\u2500",
          "mid-mid": "\u253C",
          right: "\u2502",
          "right-mid": "\u2524",
          middle: "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        rowHeights: [],
        colAligns: [],
        rowAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      };
    }
    function mergeOptions(options, defaults) {
      options = options || {};
      defaults = defaults || defaultOptions();
      let ret = Object.assign({}, defaults, options);
      ret.chars = Object.assign({}, defaults.chars, options.chars);
      ret.style = Object.assign({}, defaults.style, options.style);
      return ret;
    }
    function wordWrap(maxLength, input) {
      let lines = [];
      let split = input.split(/(\s+)/g);
      let line = [];
      let lineLength = 0;
      let whitespace;
      for (let i2 = 0; i2 < split.length; i2 += 2) {
        let word = split[i2];
        let newLength = lineLength + strlen(word);
        if (lineLength > 0 && whitespace) {
          newLength += whitespace.length;
        }
        if (newLength > maxLength) {
          if (lineLength !== 0) {
            lines.push(line.join(""));
          }
          line = [word];
          lineLength = strlen(word);
        } else {
          line.push(whitespace || "", word);
          lineLength = newLength;
        }
        whitespace = split[i2 + 1];
      }
      if (lineLength) {
        lines.push(line.join(""));
      }
      return lines;
    }
    function textWrap(maxLength, input) {
      let lines = [];
      let line = "";
      function pushLine(str, ws) {
        if (line.length && ws)
          line += ws;
        line += str;
        while (line.length > maxLength) {
          lines.push(line.slice(0, maxLength));
          line = line.slice(maxLength);
        }
      }
      let split = input.split(/(\s+)/g);
      for (let i2 = 0; i2 < split.length; i2 += 2) {
        pushLine(split[i2], i2 && split[i2 - 1]);
      }
      if (line.length)
        lines.push(line);
      return lines;
    }
    function multiLineWordWrap(maxLength, input, wrapOnWordBoundary = true) {
      let output = [];
      input = input.split("\n");
      const handler = wrapOnWordBoundary ? wordWrap : textWrap;
      for (let i2 = 0; i2 < input.length; i2++) {
        output.push.apply(output, handler(maxLength, input[i2]));
      }
      return output;
    }
    function colorizeLines(input) {
      let state = {};
      let output = [];
      for (let i2 = 0; i2 < input.length; i2++) {
        let line = rewindState(state, input[i2]);
        state = readState(line);
        let temp = Object.assign({}, state);
        output.push(unwindState(temp, line));
      }
      return output;
    }
    function hyperlink(url, text) {
      const OSC = "\x1B]";
      const BEL = "\x07";
      const SEP = ";";
      return [OSC, "8", SEP, SEP, url || text, BEL, text, OSC, "8", SEP, SEP, BEL].join("");
    }
    module.exports = {
      strlen,
      repeat,
      pad,
      truncate,
      mergeOptions,
      wordWrap: multiLineWordWrap,
      colorizeLines,
      hyperlink
    };
  }
});

// ../../node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "../../node_modules/@colors/colors/lib/styles.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var styles = {};
    module["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// ../../node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag2 = __commonJS({
  "../../node_modules/@colors/colors/lib/system/has-flag.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "../../node_modules/@colors/colors/lib/system/supports-colors.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var os = __require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "../../node_modules/@colors/colors/lib/custom/trap.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// ../../node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "../../node_modules/@colors/colors/lib/custom/zalgo.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r2 = Math.floor(Math.random() * range);
        return r2;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i2) {
          bool = i2 === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i2 = 0; i2 <= counts[index]; i2++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/america.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function(colors) {
      return function(letter, i2, exploded) {
        if (letter === " ")
          return letter;
        switch (i2 % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/zebra.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function(colors) {
      return function(letter, i2, exploded) {
        return i2 % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/rainbow.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i2, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/random.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i2, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "../../node_modules/@colors/colors/lib/colors.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var colors = {};
    module["exports"] = colors;
    colors.themes = {};
    var util2 = __require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util2.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i2 = nestedStyles.length;
      while (i2--) {
        var code = ansiStyles[nestedStyles[i2]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i2 in theme[style2]) {
                out = colors[theme[style2][i2]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init3() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init3());
  }
});

// ../../node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "../../node_modules/@colors/colors/safe.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var colors = require_colors();
    module["exports"] = colors;
  }
});

// ../../node_modules/cli-table3/src/cell.js
var require_cell = __commonJS({
  "../../node_modules/cli-table3/src/cell.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { info, debug } = require_debug2();
    var utils = require_utils5();
    var Cell = class {
      /**
       * A representation of a cell within the table.
       * Implementations must have `init` and `draw` methods,
       * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.
       * @param options
       * @constructor
       */
      constructor(options) {
        this.setOptions(options);
        this.x = null;
        this.y = null;
      }
      setOptions(options) {
        if (["boolean", "number", "string"].indexOf(typeof options) !== -1) {
          options = { content: "" + options };
        }
        options = options || {};
        this.options = options;
        let content = options.content;
        if (["boolean", "number", "string"].indexOf(typeof content) !== -1) {
          this.content = String(content);
        } else if (!content) {
          this.content = this.options.href || "";
        } else {
          throw new Error("Content needs to be a primitive, got: " + typeof content);
        }
        this.colSpan = options.colSpan || 1;
        this.rowSpan = options.rowSpan || 1;
        if (this.options.href) {
          Object.defineProperty(this, "href", {
            get() {
              return this.options.href;
            }
          });
        }
      }
      mergeTableOptions(tableOptions, cells) {
        this.cells = cells;
        let optionsChars = this.options.chars || {};
        let tableChars = tableOptions.chars;
        let chars = this.chars = {};
        CHAR_NAMES.forEach(function(name) {
          setOption(optionsChars, tableChars, name, chars);
        });
        this.truncate = this.options.truncate || tableOptions.truncate;
        let style = this.options.style = this.options.style || {};
        let tableStyle = tableOptions.style;
        setOption(style, tableStyle, "padding-left", this);
        setOption(style, tableStyle, "padding-right", this);
        this.head = style.head || tableStyle.head;
        this.border = style.border || tableStyle.border;
        this.fixedWidth = tableOptions.colWidths[this.x];
        this.lines = this.computeLines(tableOptions);
        this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;
        this.desiredHeight = this.lines.length;
      }
      computeLines(tableOptions) {
        const tableWordWrap = tableOptions.wordWrap || tableOptions.textWrap;
        const { wordWrap = tableWordWrap } = this.options;
        if (this.fixedWidth && wordWrap) {
          this.fixedWidth -= this.paddingLeft + this.paddingRight;
          if (this.colSpan) {
            let i2 = 1;
            while (i2 < this.colSpan) {
              this.fixedWidth += tableOptions.colWidths[this.x + i2];
              i2++;
            }
          }
          const { wrapOnWordBoundary: tableWrapOnWordBoundary = true } = tableOptions;
          const { wrapOnWordBoundary = tableWrapOnWordBoundary } = this.options;
          return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));
        }
        return this.wrapLines(this.content.split("\n"));
      }
      wrapLines(computedLines) {
        const lines = utils.colorizeLines(computedLines);
        if (this.href) {
          return lines.map((line) => utils.hyperlink(this.href, line));
        }
        return lines;
      }
      /**
       * Initializes the Cells data structure.
       *
       * @param tableOptions - A fully populated set of tableOptions.
       * In addition to the standard default values, tableOptions must have fully populated the
       * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number
       * of columns or rows (respectively) in this table, and each array item must be a Number.
       *
       */
      init(tableOptions) {
        let x2 = this.x;
        let y = this.y;
        this.widths = tableOptions.colWidths.slice(x2, x2 + this.colSpan);
        this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);
        this.width = this.widths.reduce(sumPlusOne, -1);
        this.height = this.heights.reduce(sumPlusOne, -1);
        this.hAlign = this.options.hAlign || tableOptions.colAligns[x2];
        this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];
        this.drawRight = x2 + this.colSpan == tableOptions.colWidths.length;
      }
      /**
       * Draws the given line of the cell.
       * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.
       * @param lineNum - can be `top`, `bottom` or a numerical line number.
       * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how
       * many rows below it's being called from. Otherwise it's undefined.
       * @returns {String} The representation of this line.
       */
      draw(lineNum, spanningCell) {
        if (lineNum == "top")
          return this.drawTop(this.drawRight);
        if (lineNum == "bottom")
          return this.drawBottom(this.drawRight);
        let content = utils.truncate(this.content, 10, this.truncate);
        if (!lineNum) {
          info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);
        } else {
        }
        let padLen = Math.max(this.height - this.lines.length, 0);
        let padTop;
        switch (this.vAlign) {
          case "center":
            padTop = Math.ceil(padLen / 2);
            break;
          case "bottom":
            padTop = padLen;
            break;
          default:
            padTop = 0;
        }
        if (lineNum < padTop || lineNum >= padTop + this.lines.length) {
          return this.drawEmpty(this.drawRight, spanningCell);
        }
        let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
        return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
      }
      /**
       * Renders the top line of the cell.
       * @param drawRight - true if this method should render the right edge of the cell.
       * @returns {String}
       */
      drawTop(drawRight) {
        let content = [];
        if (this.cells) {
          this.widths.forEach(function(width, index) {
            content.push(this._topLeftChar(index));
            content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], width));
          }, this);
        } else {
          content.push(this._topLeftChar(0));
          content.push(utils.repeat(this.chars[this.y == 0 ? "top" : "mid"], this.width));
        }
        if (drawRight) {
          content.push(this.chars[this.y == 0 ? "topRight" : "rightMid"]);
        }
        return this.wrapWithStyleColors("border", content.join(""));
      }
      _topLeftChar(offset) {
        let x2 = this.x + offset;
        let leftChar;
        if (this.y == 0) {
          leftChar = x2 == 0 ? "topLeft" : offset == 0 ? "topMid" : "top";
        } else {
          if (x2 == 0) {
            leftChar = "leftMid";
          } else {
            leftChar = offset == 0 ? "midMid" : "bottomMid";
            if (this.cells) {
              let spanAbove = this.cells[this.y - 1][x2] instanceof Cell.ColSpanCell;
              if (spanAbove) {
                leftChar = offset == 0 ? "topMid" : "mid";
              }
              if (offset == 0) {
                let i2 = 1;
                while (this.cells[this.y][x2 - i2] instanceof Cell.ColSpanCell) {
                  i2++;
                }
                if (this.cells[this.y][x2 - i2] instanceof Cell.RowSpanCell) {
                  leftChar = "leftMid";
                }
              }
            }
          }
        }
        return this.chars[leftChar];
      }
      wrapWithStyleColors(styleProperty, content) {
        if (this[styleProperty] && this[styleProperty].length) {
          try {
            let colors = require_safe();
            for (let i2 = this[styleProperty].length - 1; i2 >= 0; i2--) {
              colors = colors[this[styleProperty][i2]];
            }
            return colors(content);
          } catch (e2) {
            return content;
          }
        } else {
          return content;
        }
      }
      /**
       * Renders a line of text.
       * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.
       * There may be top-padding above the first line of text.
       * @param drawRight - true if this method should render the right edge of the cell.
       * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even
       * if the text fits. This is used when the cell is vertically truncated. If `false` the text should
       * only include the truncation symbol if the text will not fit horizontally within the cell width.
       * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.
       * @returns {String}
       */
      drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
        let left = this.chars[this.x == 0 ? "left" : "middle"];
        if (this.x && spanningCell && this.cells) {
          let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
          while (cellLeft instanceof ColSpanCell) {
            cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
          }
          if (!(cellLeft instanceof RowSpanCell)) {
            left = this.chars["rightMid"];
          }
        }
        let leftPadding = utils.repeat(" ", this.paddingLeft);
        let right = drawRight ? this.chars["right"] : "";
        let rightPadding = utils.repeat(" ", this.paddingRight);
        let line = this.lines[lineNum];
        let len = this.width - (this.paddingLeft + this.paddingRight);
        if (forceTruncationSymbol)
          line += this.truncate || "\u2026";
        let content = utils.truncate(line, len, this.truncate);
        content = utils.pad(content, len, " ", this.hAlign);
        content = leftPadding + content + rightPadding;
        return this.stylizeLine(left, content, right);
      }
      stylizeLine(left, content, right) {
        left = this.wrapWithStyleColors("border", left);
        right = this.wrapWithStyleColors("border", right);
        if (this.y === 0) {
          content = this.wrapWithStyleColors("head", content);
        }
        return left + content + right;
      }
      /**
       * Renders the bottom line of the cell.
       * @param drawRight - true if this method should render the right edge of the cell.
       * @returns {String}
       */
      drawBottom(drawRight) {
        let left = this.chars[this.x == 0 ? "bottomLeft" : "bottomMid"];
        let content = utils.repeat(this.chars.bottom, this.width);
        let right = drawRight ? this.chars["bottomRight"] : "";
        return this.wrapWithStyleColors("border", left + content + right);
      }
      /**
       * Renders a blank line of text within the cell. Used for top and/or bottom padding.
       * @param drawRight - true if this method should render the right edge of the cell.
       * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.
       * @returns {String}
       */
      drawEmpty(drawRight, spanningCell) {
        let left = this.chars[this.x == 0 ? "left" : "middle"];
        if (this.x && spanningCell && this.cells) {
          let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
          while (cellLeft instanceof ColSpanCell) {
            cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
          }
          if (!(cellLeft instanceof RowSpanCell)) {
            left = this.chars["rightMid"];
          }
        }
        let right = drawRight ? this.chars["right"] : "";
        let content = utils.repeat(" ", this.width);
        return this.stylizeLine(left, content, right);
      }
    };
    var ColSpanCell = class {
      /**
       * A Cell that doesn't do anything. It just draws empty lines.
       * Used as a placeholder in column spanning.
       * @constructor
       */
      constructor() {
      }
      draw(lineNum) {
        if (typeof lineNum === "number") {
          debug(`${this.y}-${this.x}: 1x1 ColSpanCell`);
        }
        return "";
      }
      init() {
      }
      mergeTableOptions() {
      }
    };
    var RowSpanCell = class {
      /**
       * A placeholder Cell for a Cell that spans multiple rows.
       * It delegates rendering to the original cell, but adds the appropriate offset.
       * @param originalCell
       * @constructor
       */
      constructor(originalCell) {
        this.originalCell = originalCell;
      }
      init(tableOptions) {
        let y = this.y;
        let originalY = this.originalCell.y;
        this.cellOffset = y - originalY;
        this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);
      }
      draw(lineNum) {
        if (lineNum == "top") {
          return this.originalCell.draw(this.offset, this.cellOffset);
        }
        if (lineNum == "bottom") {
          return this.originalCell.draw("bottom");
        }
        debug(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`);
        return this.originalCell.draw(this.offset + 1 + lineNum);
      }
      mergeTableOptions() {
      }
    };
    function firstDefined(...args) {
      return args.filter((v) => v !== void 0 && v !== null).shift();
    }
    function setOption(objA, objB, nameB, targetObj) {
      let nameA = nameB.split("-");
      if (nameA.length > 1) {
        nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);
        nameA = nameA.join("");
        targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);
      } else {
        targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);
      }
    }
    function findDimension(dimensionTable, startingIndex, span) {
      let ret = dimensionTable[startingIndex];
      for (let i2 = 1; i2 < span; i2++) {
        ret += 1 + dimensionTable[startingIndex + i2];
      }
      return ret;
    }
    function sumPlusOne(a, b) {
      return a + b + 1;
    }
    var CHAR_NAMES = [
      "top",
      "top-mid",
      "top-left",
      "top-right",
      "bottom",
      "bottom-mid",
      "bottom-left",
      "bottom-right",
      "left",
      "left-mid",
      "mid",
      "mid-mid",
      "right",
      "right-mid",
      "middle"
    ];
    module.exports = Cell;
    module.exports.ColSpanCell = ColSpanCell;
    module.exports.RowSpanCell = RowSpanCell;
  }
});

// ../../node_modules/cli-table3/src/layout-manager.js
var require_layout_manager = __commonJS({
  "../../node_modules/cli-table3/src/layout-manager.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { warn, debug } = require_debug2();
    var Cell = require_cell();
    var { ColSpanCell, RowSpanCell } = Cell;
    (function() {
      function next(alloc, col) {
        if (alloc[col] > 0) {
          return next(alloc, col + 1);
        }
        return col;
      }
      function layoutTable(table) {
        let alloc = {};
        table.forEach(function(row, rowIndex) {
          let col = 0;
          row.forEach(function(cell) {
            cell.y = rowIndex;
            cell.x = rowIndex ? next(alloc, col) : col;
            const rowSpan = cell.rowSpan || 1;
            const colSpan = cell.colSpan || 1;
            if (rowSpan > 1) {
              for (let cs = 0; cs < colSpan; cs++) {
                alloc[cell.x + cs] = rowSpan;
              }
            }
            col = cell.x + colSpan;
          });
          Object.keys(alloc).forEach((idx) => {
            alloc[idx]--;
            if (alloc[idx] < 1)
              delete alloc[idx];
          });
        });
      }
      function maxWidth(table) {
        let mw = 0;
        table.forEach(function(row) {
          row.forEach(function(cell) {
            mw = Math.max(mw, cell.x + (cell.colSpan || 1));
          });
        });
        return mw;
      }
      function maxHeight(table) {
        return table.length;
      }
      function cellsConflict(cell1, cell2) {
        let yMin1 = cell1.y;
        let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);
        let yMin2 = cell2.y;
        let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);
        let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);
        let xMin1 = cell1.x;
        let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);
        let xMin2 = cell2.x;
        let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
        let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);
        return yConflict && xConflict;
      }
      function conflictExists(rows, x2, y) {
        let i_max = Math.min(rows.length - 1, y);
        let cell = { x: x2, y };
        for (let i2 = 0; i2 <= i_max; i2++) {
          let row = rows[i2];
          for (let j = 0; j < row.length; j++) {
            if (cellsConflict(cell, row[j])) {
              return true;
            }
          }
        }
        return false;
      }
      function allBlank(rows, y, xMin, xMax) {
        for (let x2 = xMin; x2 < xMax; x2++) {
          if (conflictExists(rows, x2, y)) {
            return false;
          }
        }
        return true;
      }
      function addRowSpanCells(table) {
        table.forEach(function(row, rowIndex) {
          row.forEach(function(cell) {
            for (let i2 = 1; i2 < cell.rowSpan; i2++) {
              let rowSpanCell = new RowSpanCell(cell);
              rowSpanCell.x = cell.x;
              rowSpanCell.y = cell.y + i2;
              rowSpanCell.colSpan = cell.colSpan;
              insertCell(rowSpanCell, table[rowIndex + i2]);
            }
          });
        });
      }
      function addColSpanCells(cellRows) {
        for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {
          let cellColumns = cellRows[rowIndex];
          for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {
            let cell = cellColumns[columnIndex];
            for (let k = 1; k < cell.colSpan; k++) {
              let colSpanCell = new ColSpanCell();
              colSpanCell.x = cell.x + k;
              colSpanCell.y = cell.y;
              cellColumns.splice(columnIndex + 1, 0, colSpanCell);
            }
          }
        }
      }
      function insertCell(cell, row) {
        let x2 = 0;
        while (x2 < row.length && row[x2].x < cell.x) {
          x2++;
        }
        row.splice(x2, 0, cell);
      }
      function fillInTable(table) {
        let h_max = maxHeight(table);
        let w_max = maxWidth(table);
        debug(`Max rows: ${h_max}; Max cols: ${w_max}`);
        for (let y = 0; y < h_max; y++) {
          for (let x2 = 0; x2 < w_max; x2++) {
            if (!conflictExists(table, x2, y)) {
              let opts = { x: x2, y, colSpan: 1, rowSpan: 1 };
              x2++;
              while (x2 < w_max && !conflictExists(table, x2, y)) {
                opts.colSpan++;
                x2++;
              }
              let y2 = y + 1;
              while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {
                opts.rowSpan++;
                y2++;
              }
              let cell = new Cell(opts);
              cell.x = opts.x;
              cell.y = opts.y;
              warn(`Missing cell at ${cell.y}-${cell.x}.`);
              insertCell(cell, table[y]);
            }
          }
        }
      }
      function generateCells(rows) {
        return rows.map(function(row) {
          if (!Array.isArray(row)) {
            let key = Object.keys(row)[0];
            row = row[key];
            if (Array.isArray(row)) {
              row = row.slice();
              row.unshift(key);
            } else {
              row = [key, row];
            }
          }
          return row.map(function(cell) {
            return new Cell(cell);
          });
        });
      }
      function makeTableLayout(rows) {
        let cellRows = generateCells(rows);
        layoutTable(cellRows);
        fillInTable(cellRows);
        addRowSpanCells(cellRows);
        addColSpanCells(cellRows);
        return cellRows;
      }
      module.exports = {
        makeTableLayout,
        layoutTable,
        addRowSpanCells,
        maxWidth,
        fillInTable,
        computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
        computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
      };
    })();
    function makeComputeWidths(colSpan, desiredWidth, x2, forcedMin) {
      return function(vals, table) {
        let result = [];
        let spanners = [];
        let auto = {};
        table.forEach(function(row) {
          row.forEach(function(cell) {
            if ((cell[colSpan] || 1) > 1) {
              spanners.push(cell);
            } else {
              result[cell[x2]] = Math.max(result[cell[x2]] || 0, cell[desiredWidth] || 0, forcedMin);
            }
          });
        });
        vals.forEach(function(val, index) {
          if (typeof val === "number") {
            result[index] = val;
          }
        });
        for (let k = spanners.length - 1; k >= 0; k--) {
          let cell = spanners[k];
          let span = cell[colSpan];
          let col = cell[x2];
          let existingWidth = result[col];
          let editableCols = typeof vals[col] === "number" ? 0 : 1;
          if (typeof existingWidth === "number") {
            for (let i2 = 1; i2 < span; i2++) {
              existingWidth += 1 + result[col + i2];
              if (typeof vals[col + i2] !== "number") {
                editableCols++;
              }
            }
          } else {
            existingWidth = desiredWidth === "desiredWidth" ? cell.desiredWidth - 1 : 1;
            if (!auto[col] || auto[col] < existingWidth) {
              auto[col] = existingWidth;
            }
          }
          if (cell[desiredWidth] > existingWidth) {
            let i2 = 0;
            while (editableCols > 0 && cell[desiredWidth] > existingWidth) {
              if (typeof vals[col + i2] !== "number") {
                let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
                existingWidth += dif;
                result[col + i2] += dif;
                editableCols--;
              }
              i2++;
            }
          }
        }
        Object.assign(vals, result, auto);
        for (let j = 0; j < vals.length; j++) {
          vals[j] = Math.max(forcedMin, vals[j] || 0);
        }
      };
    }
  }
});

// ../../node_modules/cli-table3/src/table.js
var require_table = __commonJS({
  "../../node_modules/cli-table3/src/table.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var debug = require_debug2();
    var utils = require_utils5();
    var tableLayout = require_layout_manager();
    var Table2 = class extends Array {
      constructor(opts) {
        super();
        const options = utils.mergeOptions(opts);
        Object.defineProperty(this, "options", {
          value: options,
          enumerable: options.debug
        });
        if (options.debug) {
          switch (typeof options.debug) {
            case "boolean":
              debug.setDebugLevel(debug.WARN);
              break;
            case "number":
              debug.setDebugLevel(options.debug);
              break;
            case "string":
              debug.setDebugLevel(parseInt(options.debug, 10));
              break;
            default:
              debug.setDebugLevel(debug.WARN);
              debug.warn(`Debug option is expected to be boolean, number, or string. Received a ${typeof options.debug}`);
          }
          Object.defineProperty(this, "messages", {
            get() {
              return debug.debugMessages();
            }
          });
        }
      }
      toString() {
        let array = this;
        let headersPresent = this.options.head && this.options.head.length;
        if (headersPresent) {
          array = [this.options.head];
          if (this.length) {
            array.push.apply(array, this);
          }
        } else {
          this.options.style.head = [];
        }
        let cells = tableLayout.makeTableLayout(array);
        cells.forEach(function(row) {
          row.forEach(function(cell) {
            cell.mergeTableOptions(this.options, cells);
          }, this);
        }, this);
        tableLayout.computeWidths(this.options.colWidths, cells);
        tableLayout.computeHeights(this.options.rowHeights, cells);
        cells.forEach(function(row) {
          row.forEach(function(cell) {
            cell.init(this.options);
          }, this);
        }, this);
        let result = [];
        for (let rowIndex = 0; rowIndex < cells.length; rowIndex++) {
          let row = cells[rowIndex];
          let heightOfRow = this.options.rowHeights[rowIndex];
          if (rowIndex === 0 || !this.options.style.compact || rowIndex == 1 && headersPresent) {
            doDraw(row, "top", result);
          }
          for (let lineNum = 0; lineNum < heightOfRow; lineNum++) {
            doDraw(row, lineNum, result);
          }
          if (rowIndex + 1 == cells.length) {
            doDraw(row, "bottom", result);
          }
        }
        return result.join("\n");
      }
      get width() {
        let str = this.toString().split("\n");
        return str[0].length;
      }
    };
    Table2.reset = () => debug.reset();
    function doDraw(row, lineNum, result) {
      let line = [];
      row.forEach(function(cell) {
        line.push(cell.draw(lineNum));
      });
      let str = line.join("");
      if (str.length)
        result.push(str);
    }
    module.exports = Table2;
  }
});

// ../../node_modules/cli-table3/index.js
var require_cli_table3 = __commonJS({
  "../../node_modules/cli-table3/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = require_table();
  }
});

// src/main.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// node_modules/commander/esm.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/commands/config/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/config/init.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_prompts = __toESM(require_prompts3(), 1);
import fs4 from "node:fs";
import path2 from "node:path";

// src/utilities.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_consola = __toESM(require_consola(), 1);
var log = import_consola.default;
var countMessagesPerLanguage = (resource) => {
  const counts = {};
  for (const { languageTag, body } of resource) {
    const language = languageTag.name;
    if (!counts[language]) {
      counts[language] = 0;
    }
    counts[language] += body.length;
  }
  return counts;
};
var getFlag = (countryCode) => {
  const cc = countryCode.toUpperCase();
  if (cc == "AD")
    return "\u{1F1E6}\u{1F1E9}";
  if (cc == "AE")
    return "\u{1F1E6}\u{1F1EA}";
  if (cc == "AF")
    return "\u{1F1E6}\u{1F1EB}";
  if (cc == "AG")
    return "\u{1F1E6}\u{1F1EC}";
  if (cc == "AI")
    return "\u{1F1E6}\u{1F1EE}";
  if (cc == "AL")
    return "\u{1F1E6}\u{1F1F1}";
  if (cc == "AM")
    return "\u{1F1E6}\u{1F1F2}";
  if (cc == "AO")
    return "\u{1F1E6}\u{1F1F4}";
  if (cc == "AQ")
    return "\u{1F1E6}\u{1F1F6}";
  if (cc == "AR")
    return "\u{1F1E6}\u{1F1F7}";
  if (cc == "AS")
    return "\u{1F1E6}\u{1F1F8}";
  if (cc == "AT")
    return "\u{1F1E6}\u{1F1F9}";
  if (cc == "AU")
    return "\u{1F1E6}\u{1F1FA}";
  if (cc == "AW")
    return "\u{1F1E6}\u{1F1FC}";
  if (cc == "AX")
    return "\u{1F1E6}\u{1F1FD}";
  if (cc == "AZ")
    return "\u{1F1E6}\u{1F1FF}";
  if (cc == "BA")
    return "\u{1F1E7}\u{1F1E6}";
  if (cc == "BB")
    return "\u{1F1E7}\u{1F1E7}";
  if (cc == "BD")
    return "\u{1F1E7}\u{1F1E9}";
  if (cc == "BE")
    return "\u{1F1E7}\u{1F1EA}";
  if (cc == "BF")
    return "\u{1F1E7}\u{1F1EB}";
  if (cc == "BG")
    return "\u{1F1E7}\u{1F1EC}";
  if (cc == "BH")
    return "\u{1F1E7}\u{1F1ED}";
  if (cc == "BI")
    return "\u{1F1E7}\u{1F1EE}";
  if (cc == "BJ")
    return "\u{1F1E7}\u{1F1EF}";
  if (cc == "BL")
    return "\u{1F1E7}\u{1F1F1}";
  if (cc == "BM")
    return "\u{1F1E7}\u{1F1F2}";
  if (cc == "BN")
    return "\u{1F1E7}\u{1F1F3}";
  if (cc == "BO")
    return "\u{1F1E7}\u{1F1F4}";
  if (cc == "BQ")
    return "\u{1F1E7}\u{1F1F6}";
  if (cc == "BR")
    return "\u{1F1E7}\u{1F1F7}";
  if (cc == "BS")
    return "\u{1F1E7}\u{1F1F8}";
  if (cc == "BT")
    return "\u{1F1E7}\u{1F1F9}";
  if (cc == "BV")
    return "\u{1F1E7}\u{1F1FB}";
  if (cc == "BW")
    return "\u{1F1E7}\u{1F1FC}";
  if (cc == "BY")
    return "\u{1F1E7}\u{1F1FE}";
  if (cc == "BZ")
    return "\u{1F1E7}\u{1F1FF}";
  if (cc == "CA")
    return "\u{1F1E8}\u{1F1E6}";
  if (cc == "CC")
    return "\u{1F1E8}\u{1F1E8}";
  if (cc == "CD")
    return "\u{1F1E8}\u{1F1E9}";
  if (cc == "CF")
    return "\u{1F1E8}\u{1F1EB}";
  if (cc == "CG")
    return "\u{1F1E8}\u{1F1EC}";
  if (cc == "CH")
    return "\u{1F1E8}\u{1F1ED}";
  if (cc == "CI")
    return "\u{1F1E8}\u{1F1EE}";
  if (cc == "CK")
    return "\u{1F1E8}\u{1F1F0}";
  if (cc == "CL")
    return "\u{1F1E8}\u{1F1F1}";
  if (cc == "CM")
    return "\u{1F1E8}\u{1F1F2}";
  if (cc == "CN")
    return "\u{1F1E8}\u{1F1F3}";
  if (cc == "CO")
    return "\u{1F1E8}\u{1F1F4}";
  if (cc == "CR")
    return "\u{1F1E8}\u{1F1F7}";
  if (cc == "CU")
    return "\u{1F1E8}\u{1F1FA}";
  if (cc == "CV")
    return "\u{1F1E8}\u{1F1FB}";
  if (cc == "CW")
    return "\u{1F1E8}\u{1F1FC}";
  if (cc == "CX")
    return "\u{1F1E8}\u{1F1FD}";
  if (cc == "CY")
    return "\u{1F1E8}\u{1F1FE}";
  if (cc == "CZ")
    return "\u{1F1E8}\u{1F1FF}";
  if (cc == "DE")
    return "\u{1F1E9}\u{1F1EA}";
  if (cc == "DJ")
    return "\u{1F1E9}\u{1F1EF}";
  if (cc == "DK")
    return "\u{1F1E9}\u{1F1F0}";
  if (cc == "DM")
    return "\u{1F1E9}\u{1F1F2}";
  if (cc == "DO")
    return "\u{1F1E9}\u{1F1F4}";
  if (cc == "DZ")
    return "\u{1F1E9}\u{1F1FF}";
  if (cc == "EC")
    return "\u{1F1EA}\u{1F1E8}";
  if (cc == "EE")
    return "\u{1F1EA}\u{1F1EA}";
  if (cc == "EG")
    return "\u{1F1EA}\u{1F1EC}";
  if (cc == "EH")
    return "\u{1F1EA}\u{1F1ED}";
  if (cc == "ER")
    return "\u{1F1EA}\u{1F1F7}";
  if (cc == "ES")
    return "\u{1F1EA}\u{1F1F8}";
  if (cc == "ET")
    return "\u{1F1EA}\u{1F1F9}";
  if (cc == "FI")
    return "\u{1F1EB}\u{1F1EE}";
  if (cc == "FJ")
    return "\u{1F1EB}\u{1F1EF}";
  if (cc == "FK")
    return "\u{1F1EB}\u{1F1F0}";
  if (cc == "FM")
    return "\u{1F1EB}\u{1F1F2}";
  if (cc == "FO")
    return "\u{1F1EB}\u{1F1F4}";
  if (cc == "FR")
    return "\u{1F1EB}\u{1F1F7}";
  if (cc == "GA")
    return "\u{1F1EC}\u{1F1E6}";
  if (cc == "GB")
    return "\u{1F1EC}\u{1F1E7}";
  if (cc == "GD")
    return "\u{1F1EC}\u{1F1E9}";
  if (cc == "GE")
    return "\u{1F1EC}\u{1F1EA}";
  if (cc == "GF")
    return "\u{1F1EC}\u{1F1EB}";
  if (cc == "GG")
    return "\u{1F1EC}\u{1F1EC}";
  if (cc == "GH")
    return "\u{1F1EC}\u{1F1ED}";
  if (cc == "GI")
    return "\u{1F1EC}\u{1F1EE}";
  if (cc == "GL")
    return "\u{1F1EC}\u{1F1F1}";
  if (cc == "GM")
    return "\u{1F1EC}\u{1F1F2}";
  if (cc == "GN")
    return "\u{1F1EC}\u{1F1F3}";
  if (cc == "GP")
    return "\u{1F1EC}\u{1F1F5}";
  if (cc == "GQ")
    return "\u{1F1EC}\u{1F1F6}";
  if (cc == "GR")
    return "\u{1F1EC}\u{1F1F7}";
  if (cc == "GS")
    return "\u{1F1EC}\u{1F1F8}";
  if (cc == "GT")
    return "\u{1F1EC}\u{1F1F9}";
  if (cc == "GU")
    return "\u{1F1EC}\u{1F1FA}";
  if (cc == "GW")
    return "\u{1F1EC}\u{1F1FC}";
  if (cc == "GY")
    return "\u{1F1EC}\u{1F1FE}";
  if (cc == "HK")
    return "\u{1F1ED}\u{1F1F0}";
  if (cc == "HM")
    return "\u{1F1ED}\u{1F1F2}";
  if (cc == "HN")
    return "\u{1F1ED}\u{1F1F3}";
  if (cc == "HR")
    return "\u{1F1ED}\u{1F1F7}";
  if (cc == "HT")
    return "\u{1F1ED}\u{1F1F9}";
  if (cc == "HU")
    return "\u{1F1ED}\u{1F1FA}";
  if (cc == "ID")
    return "\u{1F1EE}\u{1F1E9}";
  if (cc == "IE")
    return "\u{1F1EE}\u{1F1EA}";
  if (cc == "IL")
    return "\u{1F1EE}\u{1F1F1}";
  if (cc == "IM")
    return "\u{1F1EE}\u{1F1F2}";
  if (cc == "IN")
    return "\u{1F1EE}\u{1F1F3}";
  if (cc == "IO")
    return "\u{1F1EE}\u{1F1F4}";
  if (cc == "IQ")
    return "\u{1F1EE}\u{1F1F6}";
  if (cc == "IR")
    return "\u{1F1EE}\u{1F1F7}";
  if (cc == "IS")
    return "\u{1F1EE}\u{1F1F8}";
  if (cc == "IT")
    return "\u{1F1EE}\u{1F1F9}";
  if (cc == "JE")
    return "\u{1F1EF}\u{1F1EA}";
  if (cc == "JM")
    return "\u{1F1EF}\u{1F1F2}";
  if (cc == "JO")
    return "\u{1F1EF}\u{1F1F4}";
  if (cc == "JP")
    return "\u{1F1EF}\u{1F1F5}";
  if (cc == "KE")
    return "\u{1F1F0}\u{1F1EA}";
  if (cc == "KG")
    return "\u{1F1F0}\u{1F1EC}";
  if (cc == "KH")
    return "\u{1F1F0}\u{1F1ED}";
  if (cc == "KI")
    return "\u{1F1F0}\u{1F1EE}";
  if (cc == "KM")
    return "\u{1F1F0}\u{1F1F2}";
  if (cc == "KN")
    return "\u{1F1F0}\u{1F1F3}";
  if (cc == "KP")
    return "\u{1F1F0}\u{1F1F5}";
  if (cc == "KR")
    return "\u{1F1F0}\u{1F1F7}";
  if (cc == "KW")
    return "\u{1F1F0}\u{1F1FC}";
  if (cc == "KY")
    return "\u{1F1F0}\u{1F1FE}";
  if (cc == "KZ")
    return "\u{1F1F0}\u{1F1FF}";
  if (cc == "LA")
    return "\u{1F1F1}\u{1F1E6}";
  if (cc == "LB")
    return "\u{1F1F1}\u{1F1E7}";
  if (cc == "LC")
    return "\u{1F1F1}\u{1F1E8}";
  if (cc == "LI")
    return "\u{1F1F1}\u{1F1EE}";
  if (cc == "LK")
    return "\u{1F1F1}\u{1F1F0}";
  if (cc == "LR")
    return "\u{1F1F1}\u{1F1F7}";
  if (cc == "LS")
    return "\u{1F1F1}\u{1F1F8}";
  if (cc == "LT")
    return "\u{1F1F1}\u{1F1F9}";
  if (cc == "LU")
    return "\u{1F1F1}\u{1F1FA}";
  if (cc == "LV")
    return "\u{1F1F1}\u{1F1FB}";
  if (cc == "LY")
    return "\u{1F1F1}\u{1F1FE}";
  if (cc == "MA")
    return "\u{1F1F2}\u{1F1E6}";
  if (cc == "MC")
    return "\u{1F1F2}\u{1F1E8}";
  if (cc == "MD")
    return "\u{1F1F2}\u{1F1E9}";
  if (cc == "ME")
    return "\u{1F1F2}\u{1F1EA}";
  if (cc == "MF")
    return "\u{1F1F2}\u{1F1EB}";
  if (cc == "MG")
    return "\u{1F1F2}\u{1F1EC}";
  if (cc == "MH")
    return "\u{1F1F2}\u{1F1ED}";
  if (cc == "MK")
    return "\u{1F1F2}\u{1F1F0}";
  if (cc == "ML")
    return "\u{1F1F2}\u{1F1F1}";
  if (cc == "MM")
    return "\u{1F1F2}\u{1F1F2}";
  if (cc == "MN")
    return "\u{1F1F2}\u{1F1F3}";
  if (cc == "MO")
    return "\u{1F1F2}\u{1F1F4}";
  if (cc == "MP")
    return "\u{1F1F2}\u{1F1F5}";
  if (cc == "MQ")
    return "\u{1F1F2}\u{1F1F6}";
  if (cc == "MR")
    return "\u{1F1F2}\u{1F1F7}";
  if (cc == "MS")
    return "\u{1F1F2}\u{1F1F8}";
  if (cc == "MT")
    return "\u{1F1F2}\u{1F1F9}";
  if (cc == "MU")
    return "\u{1F1F2}\u{1F1FA}";
  if (cc == "MV")
    return "\u{1F1F2}\u{1F1FB}";
  if (cc == "MW")
    return "\u{1F1F2}\u{1F1FC}";
  if (cc == "MX")
    return "\u{1F1F2}\u{1F1FD}";
  if (cc == "MY")
    return "\u{1F1F2}\u{1F1FE}";
  if (cc == "MZ")
    return "\u{1F1F2}\u{1F1FF}";
  if (cc == "NA")
    return "\u{1F1F3}\u{1F1E6}";
  if (cc == "NC")
    return "\u{1F1F3}\u{1F1E8}";
  if (cc == "NE")
    return "\u{1F1F3}\u{1F1EA}";
  if (cc == "NF")
    return "\u{1F1F3}\u{1F1EB}";
  if (cc == "NG")
    return "\u{1F1F3}\u{1F1EC}";
  if (cc == "NI")
    return "\u{1F1F3}\u{1F1EE}";
  if (cc == "NL")
    return "\u{1F1F3}\u{1F1F1}";
  if (cc == "NO")
    return "\u{1F1F3}\u{1F1F4}";
  if (cc == "NP")
    return "\u{1F1F3}\u{1F1F5}";
  if (cc == "NR")
    return "\u{1F1F3}\u{1F1F7}";
  if (cc == "NU")
    return "\u{1F1F3}\u{1F1FA}";
  if (cc == "NZ")
    return "\u{1F1F3}\u{1F1FF}";
  if (cc == "OM")
    return "\u{1F1F4}\u{1F1F2}";
  if (cc == "PA")
    return "\u{1F1F5}\u{1F1E6}";
  if (cc == "PE")
    return "\u{1F1F5}\u{1F1EA}";
  if (cc == "PF")
    return "\u{1F1F5}\u{1F1EB}";
  if (cc == "PG")
    return "\u{1F1F5}\u{1F1EC}";
  if (cc == "PH")
    return "\u{1F1F5}\u{1F1ED}";
  if (cc == "PK")
    return "\u{1F1F5}\u{1F1F0}";
  if (cc == "PL")
    return "\u{1F1F5}\u{1F1F1}";
  if (cc == "PM")
    return "\u{1F1F5}\u{1F1F2}";
  if (cc == "PN")
    return "\u{1F1F5}\u{1F1F3}";
  if (cc == "PR")
    return "\u{1F1F5}\u{1F1F7}";
  if (cc == "PS")
    return "\u{1F1F5}\u{1F1F8}";
  if (cc == "PT")
    return "\u{1F1F5}\u{1F1F9}";
  if (cc == "PW")
    return "\u{1F1F5}\u{1F1FC}";
  if (cc == "PY")
    return "\u{1F1F5}\u{1F1FE}";
  if (cc == "QA")
    return "\u{1F1F6}\u{1F1E6}";
  if (cc == "RE")
    return "\u{1F1F7}\u{1F1EA}";
  if (cc == "RO")
    return "\u{1F1F7}\u{1F1F4}";
  if (cc == "RS")
    return "\u{1F1F7}\u{1F1F8}";
  if (cc == "RU")
    return "\u{1F1F7}\u{1F1FA}";
  if (cc == "RW")
    return "\u{1F1F7}\u{1F1FC}";
  if (cc == "SA")
    return "\u{1F1F8}\u{1F1E6}";
  if (cc == "SB")
    return "\u{1F1F8}\u{1F1E7}";
  if (cc == "SC")
    return "\u{1F1F8}\u{1F1E8}";
  if (cc == "SD")
    return "\u{1F1F8}\u{1F1E9}";
  if (cc == "SE")
    return "\u{1F1F8}\u{1F1EA}";
  if (cc == "SG")
    return "\u{1F1F8}\u{1F1EC}";
  if (cc == "SH")
    return "\u{1F1F8}\u{1F1ED}";
  if (cc == "SI")
    return "\u{1F1F8}\u{1F1EE}";
  if (cc == "SJ")
    return "\u{1F1F8}\u{1F1EF}";
  if (cc == "SK")
    return "\u{1F1F8}\u{1F1F0}";
  if (cc == "SL")
    return "\u{1F1F8}\u{1F1F1}";
  if (cc == "SM")
    return "\u{1F1F8}\u{1F1F2}";
  if (cc == "SN")
    return "\u{1F1F8}\u{1F1F3}";
  if (cc == "SO")
    return "\u{1F1F8}\u{1F1F4}";
  if (cc == "SR")
    return "\u{1F1F8}\u{1F1F7}";
  if (cc == "SS")
    return "\u{1F1F8}\u{1F1F8}";
  if (cc == "ST")
    return "\u{1F1F8}\u{1F1F9}";
  if (cc == "SV")
    return "\u{1F1F8}\u{1F1FB}";
  if (cc == "SX")
    return "\u{1F1F8}\u{1F1FD}";
  if (cc == "SY")
    return "\u{1F1F8}\u{1F1FE}";
  if (cc == "SZ")
    return "\u{1F1F8}\u{1F1FF}";
  if (cc == "TC")
    return "\u{1F1F9}\u{1F1E8}";
  if (cc == "TD")
    return "\u{1F1F9}\u{1F1E9}";
  if (cc == "TF")
    return "\u{1F1F9}\u{1F1EB}";
  if (cc == "TG")
    return "\u{1F1F9}\u{1F1EC}";
  if (cc == "TH")
    return "\u{1F1F9}\u{1F1ED}";
  if (cc == "TJ")
    return "\u{1F1F9}\u{1F1EF}";
  if (cc == "TK")
    return "\u{1F1F9}\u{1F1F0}";
  if (cc == "TL")
    return "\u{1F1F9}\u{1F1F1}";
  if (cc == "TM")
    return "\u{1F1F9}\u{1F1F2}";
  if (cc == "TN")
    return "\u{1F1F9}\u{1F1F3}";
  if (cc == "TO")
    return "\u{1F1F9}\u{1F1F4}";
  if (cc == "TR")
    return "\u{1F1F9}\u{1F1F7}";
  if (cc == "TT")
    return "\u{1F1F9}\u{1F1F9}";
  if (cc == "TV")
    return "\u{1F1F9}\u{1F1FB}";
  if (cc == "TW")
    return "\u{1F1F9}\u{1F1FC}";
  if (cc == "TZ")
    return "\u{1F1F9}\u{1F1FF}";
  if (cc == "UA")
    return "\u{1F1FA}\u{1F1E6}";
  if (cc == "UG")
    return "\u{1F1FA}\u{1F1EC}";
  if (cc == "UM")
    return "\u{1F1FA}\u{1F1F2}";
  if (cc == "US")
    return "\u{1F1FA}\u{1F1F8}";
  if (cc == "UY")
    return "\u{1F1FA}\u{1F1FE}";
  if (cc == "UZ")
    return "\u{1F1FA}\u{1F1FF}";
  if (cc == "VA")
    return "\u{1F1FB}\u{1F1E6}";
  if (cc == "VC")
    return "\u{1F1FB}\u{1F1E8}";
  if (cc == "VE")
    return "\u{1F1FB}\u{1F1EA}";
  if (cc == "VG")
    return "\u{1F1FB}\u{1F1EC}";
  if (cc == "VI")
    return "\u{1F1FB}\u{1F1EE}";
  if (cc == "VN")
    return "\u{1F1FB}\u{1F1F3}";
  if (cc == "VU")
    return "\u{1F1FB}\u{1F1FA}";
  if (cc == "WF")
    return "\u{1F1FC}\u{1F1EB}";
  if (cc == "WS")
    return "\u{1F1FC}\u{1F1F8}";
  if (cc == "XK")
    return "\u{1F1FD}\u{1F1F0}";
  if (cc == "YE")
    return "\u{1F1FE}\u{1F1EA}";
  if (cc == "YT")
    return "\u{1F1FE}\u{1F1F9}";
  if (cc == "ZA")
    return "\u{1F1FF}\u{1F1E6}";
  if (cc == "ZM")
    return "\u{1F1FF}\u{1F1F2}";
  if (cc == "ZW")
    return "\u{1F1FF}\u{1F1FC}";
  return "\u{1F3F3}";
};

// src/utilities/format.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var bold = (text) => `\x1B[1m${text}\x1B[0m`;
var italic = (text) => `\x1B[3m${text}\x1B[0m`;

// src/utilities/fs/env/node.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
import * as fs from "node:fs";
var nodeFileSystem = {
  readDirectory: async (dir) => {
    try {
      const entries = await fs.promises.readdir(dir);
      return entries.map((entry) => [entry, 0]);
    } catch (error) {
      console.error(`node:fs: Error reading directory '${dir}':`, error);
      return [];
    }
  },
  exists: async (path4) => {
    try {
      await fs.promises.access(path4, fs.constants.F_OK);
      return true;
    } catch (error) {
      return false;
    }
  },
  readFile: async (path4, encoding) => {
    try {
      const content = await fs.promises.readFile(path4, encoding);
      return content.toString();
    } catch (error) {
      console.error(`node:fs: Error reading file '${path4}':`, error);
      return "";
    }
  },
  stat: async (path4) => {
    try {
      const stat2 = await fs.promises.stat(path4);
      return stat2;
    } catch (error) {
      console.error(`node:fs: Error getting file stats for '${path4}':`, error);
      return void 0;
    }
  },
  isDirectory: async (stat2) => {
    return stat2.isDirectory();
  }
};

// src/utilities/getConfig.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/config/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/config/setupConfig.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/plugin/setupPlugins.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/plugin/errors/PluginSetupError.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var _PluginSetupError_id;
var PluginSetupError = class extends Error {
  constructor() {
    super(...arguments);
    _PluginSetupError_id.set(this, "PluginSetupError");
  }
};
_PluginSetupError_id = /* @__PURE__ */ new WeakMap();

// ../../node_modules/deepmerge-ts/dist/node/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
var actionsInto = {
  defaultMerge: actions.defaultMerge
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
var validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords(m_target, values, utils, meta) {
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyTarget = { value: propValues[0] };
    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);
    if (key === "__proto__") {
      Object.defineProperty(m_target, key, {
        value: propertyTarget.value,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      m_target.value[key] = propertyTarget.value;
    }
  }
}
function mergeArrays(m_target, values) {
  m_target.value.push(...values.slice(1).flat());
}
function mergeSets(m_target, values) {
  for (const value of getIterableOfIterables(values.slice(1))) {
    m_target.value.add(value);
  }
}
function mergeMaps(m_target, values) {
  for (const [key, value] of getIterableOfIterables(values.slice(1))) {
    m_target.value.set(key, value);
  }
}
function mergeOthers(m_target, values) {
  m_target.value = values.at(-1);
}
var defaultMergeIntoFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeArrays,
  mergeMaps,
  mergeOthers,
  mergeRecords,
  mergeSets
});
function deepmergeInto(target, ...objects) {
  return void deepmergeIntoCustom({})(target, ...objects);
}
function deepmergeIntoCustom(options, rootMetaData) {
  const utils = getIntoUtils(options, customizedDeepmergeInto);
  function customizedDeepmergeInto(target, ...objects) {
    mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);
  }
  return customizedDeepmergeInto;
}
function getIntoUtils(options, customizedDeepmergeInto) {
  return {
    defaultMergeFunctions: defaultMergeIntoFunctions,
    mergeFunctions: {
      ...defaultMergeIntoFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeIntoFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers] : [key, option]))
    },
    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,
    deepmergeInto: customizedDeepmergeInto,
    actions: actionsInto
  };
}
function mergeUnknownsInto(m_target, values, utils, meta) {
  if (values.length === 0) {
    return;
  }
  if (values.length === 1) {
    return void mergeOthersInto(m_target, values, utils, meta);
  }
  const type = getObjectType(m_target.value);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return void mergeRecordsInto(m_target, values, utils, meta);
    }
    case 2: {
      return void mergeArraysInto(m_target, values, utils, meta);
    }
    case 3: {
      return void mergeSetsInto(m_target, values, utils, meta);
    }
    case 4: {
      return void mergeMapsInto(m_target, values, utils, meta);
    }
    default: {
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
}
function mergeRecordsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);
  }
}
function mergeArraysInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeArrays(m_target, values);
  }
}
function mergeSetsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeSets(m_target, values);
  }
}
function mergeMapsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeMaps(m_target, values);
  }
}
function mergeOthersInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeOthers(m_target, values);
  }
}

// ../core/dist/plugin/setupPlugins.js
var import_ts_dedent = __toESM(require_dist2(), 1);
async function setupPlugins(args) {
  var _a;
  if (args.config.plugins === void 0) {
    args.config.plugins = [];
    return [args.config];
  }
  const mergedConfig = { ...args.config };
  const errors = [];
  for (let i2 = 0; i2 < args.config.plugins.length; i2++) {
    try {
      if (typeof args.config.plugins[i2] === "function") {
        args.config.plugins[i2] = args.config.plugins[i2](args.env);
      }
      const plugin = args.config.plugins[i2];
      const config3 = await (plugin == null ? void 0 : plugin.config({ ...mergedConfig }));
      deepmergeInto(mergedConfig, config3);
    } catch (error) {
      if (!error || typeof error !== "object" || !("message" in error)) {
        errors.push(new PluginSetupError("" + error));
        continue;
      }
      const id = (_a = args.config.plugins[i2]) == null ? void 0 : _a.id;
      if (!id) {
        errors.push(new PluginSetupError(import_ts_dedent.dedent`
					Failed to setup a plugin:

					${(error == null ? void 0 : error.message) ?? "Unknown error"}

					It seems a plugin was configured incorrectly.
					Try to change 'plugin' to 'plugin()' or consult the documentation of that plugin.
				`));
      } else {
        errors.push(new PluginSetupError(import_ts_dedent.dedent`
					Failed to setup plugin '${id}':

					${(error == null ? void 0 : error.message) ?? "Unknown error"}
				`));
      }
    }
  }
  mergedConfig.languages = [...new Set(mergedConfig.languages)];
  return [mergedConfig, errors.length > 0 ? errors : void 0];
}

// ../core/dist/config/setupConfig.js
var import_ts_dedent3 = __toESM(require_dist2(), 1);

// ../core/dist/config/parseConfig.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/ast/zod.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_lib();
var Node = z.object({
  type: z.string(),
  metadata: z.any().optional()
});
var Identifier = Node.extend({
  type: z.literal("Identifier"),
  name: z.string()
});
var LanguageTag = Node.extend({
  type: z.literal("LanguageTag"),
  name: z.string()
});
var Text = Node.extend({
  type: z.literal("Text"),
  value: z.string()
});
var VariableReference = Node.extend({
  type: z.literal("VariableReference"),
  name: z.string()
});
var Placeholder = Node.extend({
  type: z.literal("Placeholder"),
  body: VariableReference
});
var Pattern = Node.extend({
  type: z.literal("Pattern"),
  elements: z.array(Text.or(Placeholder))
});
var Message = Node.extend({
  type: z.literal("Message"),
  id: Identifier,
  pattern: Pattern
});
var Resource = Node.extend({
  type: z.literal("Resource"),
  languageTag: LanguageTag,
  body: z.array(Message)
});

// ../core/dist/config/parseConfig.js
var import_ts_dedent2 = __toESM(require_dist2(), 1);

// ../core/dist/config/zod.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_lib();

// ../core/dist/config/ideExtension/zodSchema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_lib();
var documentSelectorSchema = arrayType(objectType({
  language: stringType().optional(),
  scheme: stringType().optional(),
  pattern: stringType().optional(),
  notebookType: stringType().optional()
})).optional();
var positionSchema = objectType({
  start: objectType({
    line: numberType(),
    character: numberType()
  }),
  end: objectType({
    line: numberType(),
    character: numberType()
  })
});
var messageReferenceSchema = objectType({
  messageId: stringType(),
  position: positionSchema
});
var zodIdeExtensionConfigSchema = objectType({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: arrayType(functionType().args(objectType({ documentText: stringType() })).returns(promiseType(arrayType(messageReferenceSchema)))).optional(),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: arrayType(objectType({
    /**
     * Function which is called, when the user finished the message extraction command.
     *
     * @param messageId is the message identifier entered by the user
     * @param selection is the text which was extracted
     * @returns the code which is inserted into the document
     */
    callback: functionType().args(stringType(), stringType()).returns(stringType())
  })).optional(),
  /**
   * An array of VSCode DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: documentSelectorSchema
});

// ../core/dist/config/zod.js
var zConfig = z.object({
  referenceLanguage: z.string().transform((value) => value),
  languages: z.array(z.string()).refine((items) => new Set(items).size === items.length, {
    message: "Languages contains duplicates. The provided languages must be unique."
  }),
  lint: z.object({
    rules: z.array(z.any())
  }).optional(),
  readResources: z.function().args(z.any()).returns(z.promise(z.array(Resource))),
  writeResources: z.function().args(z.any()).returns(z.promise(z.void())),
  ideExtension: zodIdeExtensionConfigSchema.optional(),
  plugins: z.union([z.undefined(), z.array(z.object({ id: z.string(), config: z.function() }))])
  // TODO define lint and experimental
});

// ../core/dist/config/parseConfig.js
var _ParseConfigException_id;
var ParseConfigException = class extends Error {
  constructor() {
    super(...arguments);
    _ParseConfigException_id.set(this, "ParseConfigException");
  }
};
_ParseConfigException_id = /* @__PURE__ */ new WeakMap();
async function parseConfig(args) {
  try {
    hasSetupAResourcePlugin(args.config);
    const parsedConfig = zConfig.passthrough().parse(args.config);
    referenceLanguageMustBeInLanguages(args.config);
    const resources = await args.config.readResources({ config: args.config });
    validateResources(resources);
    await languagesMatch(args.config, resources);
    await roundtripTest(args.config, resources);
    return [parsedConfig, void 0];
  } catch (error) {
    return [void 0, error];
  }
}
function hasSetupAResourcePlugin(config3) {
  if (!config3.readResources || !config3.writeResources) {
    throw new ParseConfigException(`It seems you didn't set up a plugin to handle Resource files. See https://inlang.com/documentation/plugins/registry.`);
  }
}
function referenceLanguageMustBeInLanguages(config3) {
  if (!config3.languages.includes(config3.referenceLanguage)) {
    throw new ParseConfigException(`The reference language "${config3.referenceLanguage}" must be included in the list of languages.`);
  }
}
function validateResources(resources) {
  for (const resource of resources) {
    Resource.parse(resource);
  }
}
async function languagesMatch(config3, resources) {
  const languages = resources.map((resource) => resource.languageTag.name);
  const areEqual = languages.sort().join(",") === config3.languages.sort().join(",");
  if (areEqual === false) {
    throw new ParseConfigException(`The list of languages in the config file does not match the returned resources from \`readResources()\`.`);
  }
}
async function roundtripTest(config3, initialResources) {
  const commonErrorMessage = "A roundtrip test of the readResources and writeResources functions failed:\n";
  await config3.writeResources({ config: config3, resources: initialResources });
  const readResourcesAgain = await config3.readResources({ config: config3 });
  if (initialResources.length !== readResourcesAgain.length) {
    throw new ParseConfigException(commonErrorMessage + "The number of resources don't match.");
  }
  for (const intialResource of initialResources) {
    const matchingReadResourceAgain = readResourcesAgain.find((readResourceAgain) => readResourceAgain.languageTag.name === intialResource.languageTag.name);
    if (matchingReadResourceAgain === void 0) {
      throw new ParseConfigException(commonErrorMessage + `Missing the resource "${intialResource.languageTag.name}"`);
    }
    for (const [messageIndex, initialMessage] of intialResource.body.entries()) {
      if (JSON.stringify(initialMessage) !== JSON.stringify(matchingReadResourceAgain.body[messageIndex]))
        throw new ParseConfigException((0, import_ts_dedent2.dedent)(`
${commonErrorMessage}
The message with id "${initialMessage.id.name}" does not match for the resource
with languageTag.name "${intialResource.languageTag.name}".

Received:
${JSON.stringify(matchingReadResourceAgain.body[messageIndex], void 0, 2)}

Expected:
${JSON.stringify(initialMessage, void 0, 2)}
`));
    }
  }
}

// ../core/dist/config/setupConfig.js
init_lib();
async function setupConfig(args) {
  if (args.module.defineConfig === void 0) {
    throw new Error(`The "defineConfig" function is missing from the "inlang.config.js" file.`);
  }
  let config3 = await args.module.defineConfig(args.env);
  const [configWithPlugins, pluginErrors] = await setupPlugins({ config: config3, env: args.env });
  config3 = configWithPlugins;
  const [parsedConfig, testConfigException] = await parseConfig({ config: config3 });
  if (testConfigException) {
    throw new Error(import_ts_dedent3.dedent`
			The inlang.config.js is invalid.

			# The following errors occurred during the setup of plugins:

			${pluginErrors ? pluginErrors.map((e2) => e2.message).join("\n") : "None \u2705"}

			# The following errors occurred during the validation of the config:

			${formatErrors(testConfigException)}

			---

			If plugins return errors, chances are high that the plugin errors are the root cause
			for the config errors. Try to fix the plugin errors first.

		`);
  }
  if (pluginErrors) {
    for (const e2 of pluginErrors)
      console.error(e2);
  }
  return parsedConfig;
}
var formatErrors = (error) => {
  if (error instanceof ZodError) {
    return error.errors.map((e2) => `[${e2.path}] ${e2.message}`).join("\n");
  }
  return error.message;
};

// ../core/dist/environment/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/environment/$import.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_ts_dedent4 = __toESM(require_dist2(), 1);
init_dist();
function initialize$import(args) {
  return (uri) => $import(uri, args);
}
var $ImportError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "$ImportError";
  }
};
async function $import(uri, environment) {
  const _fetch = environment.fetch;
  const moduleAsText = uri.startsWith("http") ? await (await _fetch(uri)).text() : await environment.fs.readFile(normalizePath(uri), { encoding: "utf-8" });
  const moduleWithMimeType = "data:application/javascript," + encodeURIComponent(moduleAsText);
  try {
    return await import(
      /* @vite-ignore */
      moduleWithMimeType
    );
  } catch (error) {
    let message = `Error while importing ${uri}: ${(error == null ? void 0 : error.message) ?? "Unknown error"}`;
    if (error instanceof SyntaxError && uri.includes("jsdelivr")) {
      message += import_ts_dedent4.dedent`\n\n
Are you sure that the file exists on JSDelivr?

The error indicates that the imported file does not exist on JSDelivr. For non-existent files, JSDelivr returns a 404 text that JS cannot parse as a module and throws a SyntaxError.
			`;
    }
    throw new $ImportError(message);
  }
}

// src/utilities/getConfig.ts
import * as fs2 from "node:fs";
import { dirname, resolve } from "node:path";
var configCache = void 0;
var fsWrapper = (args) => {
  return {
    mkdir: async (..._args) => {
      _args[0] = resolve(args.configPath, _args[0]);
      return args.fs.mkdir(..._args);
    },
    readFile: async (..._args) => {
      _args[0] = resolve(args.configPath, _args[0]);
      return args.fs.readFile(..._args);
    },
    writeFile: async (..._args) => {
      _args[0] = resolve(args.configPath, _args[0]);
      return args.fs.writeFile(..._args);
    },
    readdir: async (..._args) => {
      _args[0] = resolve(args.configPath, _args[0]);
      return args.fs.readdir(..._args);
    }
  };
};
async function getConfig(args) {
  if (configCache)
    return [configCache];
  const $fs = fsWrapper({
    fs: fs2.promises,
    configPath: args.options.config ? dirname(args.options.config) : process.cwd()
  });
  const env = {
    $fs,
    $import: initialize$import({
      fs: $fs,
      fetch
    })
  };
  const baseDirectory = process.cwd();
  const filePath = args.options.config ? resolve(baseDirectory, args.options.config) : resolve(baseDirectory, "inlang.config.js");
  if (!fs2.existsSync(filePath)) {
    return [void 0, "No inlang.config.js file found in the repository."];
  }
  const file = fs2.readFileSync(filePath, "utf-8");
  const base64Data = Buffer.from(file.toString(), "binary").toString("base64");
  const module = await import("data:application/javascript;base64," + base64Data);
  const config3 = await setupConfig({
    module,
    env
  });
  configCache = config3;
  return [config3];
}

// src/utilities/getConfigContent.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/utilities/getLatestVersion.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// node_modules/node-fetch/src/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import http2 from "node:http";
import https from "node:https";
import zlib from "node:zlib";
import Stream2, { PassThrough as PassThrough2, pipeline as pump } from "node:stream";
import { Buffer as Buffer3 } from "node:buffer";

// ../../node_modules/data-uri-to-buffer/dist/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_fetch_blob();
init_esm_min();
import Stream, { PassThrough } from "node:stream";
import { types, deprecate, promisify } from "node:util";
import { Buffer as Buffer2 } from "node:buffer";

// node_modules/node-fetch/src/errors/fetch-error.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// node_modules/node-fetch/src/errors/base.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/node-fetch/src/utils/is.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = promisify(Stream.pipeline);
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer2.from(body.toString());
    } else if (isBlob(body)) {
    } else if (Buffer2.isBuffer(body)) {
    } else if (types.isAnyArrayBuffer(body)) {
      body = Buffer2.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer2.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream) {
    } else if (body instanceof FormData2) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = Buffer2.from(String(body));
    }
    let stream = body;
    if (Buffer2.isBuffer(body)) {
      stream = Stream.Readable.from(body);
    } else if (isBlob(body)) {
      stream = Stream.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof Stream) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData2();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: deprecate(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer2.alloc(0);
  }
  if (!(body instanceof Stream)) {
    return Buffer2.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer2.from(accum.join(""));
      }
      return Buffer2.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough({ highWaterMark });
    p2 = new PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = deprecate(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
);
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer2.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData2) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof Stream) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer2.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/node-fetch/src/response.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// node_modules/node-fetch/src/headers.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import { types as types2 } from "node:util";
import http from "node:http";
var validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error;
  }
};
var validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
    throw error;
  }
};
var Headers2 = class extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init3) {
    let result = [];
    if (init3 instanceof Headers2) {
      const raw2 = init3.raw();
      for (const [name, values] of Object.entries(raw2)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init3 == null) {
    } else if (typeof init3 === "object" && !types2.isBoxedPrimitive(init3)) {
      const method = init3[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init3));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init3].map((pair) => {
          if (typeof pair !== "object" || types2.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(
  Headers2.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {})
);
function fromRawHeaders(headers = []) {
  return new Headers2(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers2(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response2(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data = void 0, init3 = {}) {
    const body = JSON.stringify(data);
    if (body === void 0) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers = new Headers2(init3 && init3.headers);
    if (!headers.has("content-type")) {
      headers.set("content-type", "application/json");
    }
    return new Response2(body, {
      ...init3,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import { format as formatUrl } from "node:url";
import { deprecate as deprecate2 } from "node:util";

// node_modules/node-fetch/src/utils/get-search.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import { isIP } from "node:net";
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = isIP(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = deprecate2(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
);
var Request2 = class extends Body {
  constructor(input, init3 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init3.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init3) && "data" in init3) {
      doBadDataWarn();
    }
    if ((init3.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init3.size || input.size || 0
    });
    const headers = new Headers2(init3.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init3) {
      signal = init3.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init3.referrer == null ? input.referrer : init3.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init3.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
    this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
    this.counter = init3.counter || input.counter || 0;
    this.agent = init3.agent || input.agent;
    this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return formatUrl(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request2.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers2(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? https : http2).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof Stream2.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location2 === null ? null : new URL(location2, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream2.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = pump(response_, new PassThrough2(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pump(body, zlib.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw2 = pump(response_, new PassThrough2(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw2.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pump(body, zlib.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = pump(body, zlib.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        raw2.once("end", () => {
          if (!response) {
            response = new Response2(body, responseOptions);
            resolve2(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = pump(body, zlib.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer3.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = Buffer3.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer3.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer3.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/utilities/getLatestVersion.ts
async function getLatestVersion(packageName) {
  var _a;
  const response = await fetch2(`https://registry.npmjs.org/${packageName}`);
  const metadata = await response.json();
  const latestVersion = (_a = metadata["dist-tags"]) == null ? void 0 : _a.latest;
  if (latestVersion) {
    const majorVersion = latestVersion.split(".")[0];
    return majorVersion;
  } else {
    return "latest";
  }
}

// src/utilities/getConfigContent.ts
var getConfigContent = async (args) => {
  const v = getLatestVersion;
  const plugin = args.plugin;
  const pathPattern = args.pathPattern;
  const pluginImports = {
    json: `const { default: jsonPlugin } = await env.$import('https://cdn.jsdelivr.net/npm/@inlang/plugin-json@${await v(
      "@inlang/plugin-json"
    )}/dist/index.js');`,
    i18next: `const { default: i18nextPlugin } = await env.$import('https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@${await v(
      "@inlang/plugin-i18next"
    )}/dist/index.js');`,
    "typesafe-i18n": `const { default: typesafeI18nPlugin } = await env.$import('https://cdn.jsdelivr.net/gh/ivanhofer/inlang-plugin-typesafe-i18n@2/dist/index.js');`,
    "@inlang/sdk-js": `const { default: sdkPlugin } = await env.$import('https://cdn.jsdelivr.net/npm/@inlang/sdk-js-plugin@${await v(
      "@inlang/sdk-js-plugin"
    )}/dist/index.js');`
  };
  const standardLintRules = `const { default: standardLintRules } = await env.$import('https://cdn.jsdelivr.net/npm/@inlang/plugin-standard-lint-rules@${await v(
    "@inlang/plugin-standard-lint-rules"
  )}/dist/index.js');`;
  const pluginImportsCode = pluginImports[plugin] || "";
  const pluginFunctions = [
    plugin === "json" ? `jsonPlugin({ pathPattern: '${pathPattern}' }),` : void 0,
    plugin === "@inlang/sdk-js" ? `sdkPlugin({languageNegotiation: { strategies: [{ type: "localStorage" }]}}),` : void 0,
    plugin === "i18next" ? `i18nextPlugin({ pathPattern: '${pathPattern}' }),` : void 0,
    plugin === "typesafe-i18n" ? `typesafeI18nPlugin(),` : void 0
  ].filter((x2) => x2 !== void 0).join("\n");
  const configContent = `/**
* @type { import("@inlang/core/config").DefineConfig }
*/
export async function defineConfig(env) {
	${pluginImportsCode}

	${standardLintRules}

	return {
		referenceLanguage: 'en',
		plugins: [
			${pluginFunctions}
			standardLintRules(),
		],
	};
}`;
  return configContent;
};

// src/utilities/getLanguageFolderPath.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
import path from "node:path";

// src/utilities/potentialFolders.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var potentialFolders = [
  "language",
  "languages",
  "lang",
  "locale",
  "locales",
  "i18n",
  "translations",
  "translation",
  "resources"
  // Add other potential folder names here
];

// src/utilities/getLanguageFolderPath.ts
var getLanguageFolderPath = async (args) => {
  log.info("Searching for language folder in", args.rootDir);
  try {
    const searchForLanguageFolder = async (dir, ignoredPaths) => {
      const files = await args.fs.readDirectory(dir);
      const gitignorePath = path.join(dir, ".gitignore");
      let subIgnoredPaths = [];
      if (await args.fs.exists(gitignorePath)) {
        const gitignoreContent = await args.fs.readFile(gitignorePath, "utf-8");
        subIgnoredPaths = gitignoreContent.split("\n").map((line) => line.trim()).filter((line) => !line.startsWith("#") && line !== "");
      }
      for (const [file] of files) {
        const filePath = path.join(dir, file);
        const stat2 = await args.fs.stat(filePath);
        if (stat2 && await args.fs.isDirectory(stat2) && file !== "node_modules" && !ignoredPaths.some((ignoredPath) => filePath.includes(ignoredPath))) {
          const folderName = file.toLowerCase();
          if (potentialFolders.includes(folderName)) {
            return filePath;
          }
          if (!filePath.includes("node_modules")) {
            const subLanguageFolder = await searchForLanguageFolder(filePath, [
              ...ignoredPaths,
              ...subIgnoredPaths
            ]);
            if (subLanguageFolder) {
              return subLanguageFolder;
            }
          }
        }
      }
      return void 0;
    };
    return await searchForLanguageFolder(args.rootDir, []);
  } catch (error) {
    console.error("Error in getLanguageFolderPath:", error);
    return void 0;
  }
};

// src/utilities/getSupportedLibrary.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var getSupportedLibrary = (args) => {
  const dependencies = args.packageJson.dependencies || {};
  const devDependencies = args.packageJson.devDependencies || {};
  const isInlangSdkJsInstalled = !!dependencies["@inlang/sdk-js"] || !!devDependencies["@inlang/sdk-js"];
  const isI18nextInstalled = !!dependencies["i18next"] || !!devDependencies["i18next"];
  const isTypesafeI18nInstalled = !!dependencies["typesafe-i18n"] || !!devDependencies["typesafe-i18n"];
  if (isInlangSdkJsInstalled) {
    log.info(`\u2705 Supported library found: ${bold("@inlang/sdk-js")}`);
  }
  if (isI18nextInstalled) {
    log.info(`\u2705 Supported library found: ${bold("i18next")}`);
  }
  if (isTypesafeI18nInstalled) {
    log.info(`\u2705 Supported library found: ${bold("typesafe-i18n")}`);
  }
  if (isInlangSdkJsInstalled) {
    return "@inlang/sdk-js";
  } else if (isI18nextInstalled) {
    return "i18next";
  } else if (isTypesafeI18nInstalled) {
    return "typesafe-i18n";
  } else {
    return "json";
  }
};

// src/commands/config/init.ts
var init = new Command().command("init").description("Initialize the inlang.config.js file.").action(initCommandAction);
async function initCommandAction() {
  const packageJsonPath = "./package.json";
  const inlangConfigPath = "./inlang.config.js";
  const rootDir = "./";
  if (fs4.existsSync(inlangConfigPath)) {
    log.error("\u23F8\uFE0F  Config file already exists.");
    const answer = await (0, import_prompts.default)({
      type: "confirm",
      name: "overwrite",
      message: "Do you want to overwrite the existing config file?",
      initial: false
    });
    if (answer.overwrite === false) {
      log.info("Aborting.");
      return;
    }
  }
  const answerWip = await (0, import_prompts.default)({
    type: "confirm",
    name: "wip",
    message: "The auto generation is work in progress and might not work as expected. Do you want to continue?",
    initial: true
  });
  if (answerWip.wip === false) {
    return;
  }
  let plugin = "json";
  if (fs4.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs4.readFileSync(packageJsonPath, "utf-8"));
    plugin = getSupportedLibrary({ packageJson });
    if (plugin === "@inlang/sdk-js") {
      log.warn(
        "\u{1F4E6} Using plugin: @inlang/sdk-js. You have to add a plugin which reads and writes resources e.g. the inlang-plugin-json. See: https://inlang.com/documentation/plugins/registry"
      );
    }
  } else {
    log.warn("\u{1F4E6} No package.json found in this directory. Using fallback plugin: json");
    plugin = "json";
  }
  let pathPattern = `''`;
  if (plugin !== "typesafe-i18n") {
    const languageFolderPath = await getLanguageFolderPath({ fs: nodeFileSystem, rootDir });
    const pathPatternRaw = languageFolderPath ? path2.join(languageFolderPath, "{language}.json") : "";
    pathPattern = pathPatternRaw.replace(/\\/g, "/");
    if (pathPattern === "") {
      log.warn(
        "Could not find a language folder in the project. You have to enter the path to your language files (pathPattern) manually."
      );
    } else {
      log.info(`\u{1F5C2}\uFE0F  Found language folder path: ${italic(pathPattern)}`);
      log.info(
        `\u{1F5C2}\uFE0F  Please adjust the ${`pathPattern`} in the inlang.config.js manually if it is not parsed correctly.`
      );
    }
  }
  const configContent = await getConfigContent({
    plugin,
    pathPattern
  });
  fs4.writeFileSync(inlangConfigPath, configContent);
  const [, errorMessage] = await getConfig({ options: cli.opts() });
  if (errorMessage) {
    log.error(errorMessage);
    return;
  }
  log.success(`\u{1F389} inlang.config.js file created successfully.`);
}

// src/commands/config/update.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
import fs5 from "node:fs";
import path3 from "node:path";
var import_prompts2 = __toESM(require_prompts3(), 1);
var configFile = "inlang.config.js";
var update = new Command().command("update").description("Update the inlang config.").action(updateCommandAction);
async function updateCommandAction() {
  try {
    const answer = await (0, import_prompts2.default)({
      type: "confirm",
      name: "update",
      message: "This command will update the plugins in your config file to the latest major version. Updating to a new major version can break the code, please look into the docs of the plugins you are using to see if there are breaking changes. Do you want to continue?",
      initial: true
    });
    if (answer.update === false) {
      log.info("Aborting.");
      return;
    }
    log.info("Checking for new plugin versions...");
    const filePath = cli.opts().config ? path3.resolve(process.cwd(), cli.opts().config) : path3.resolve(process.cwd(), configFile);
    const config3 = await readConfigFile(filePath);
    const pluginURLs = extractPluginUrls(config3);
    const pluginURLsParsed = pluginURLs.map((url) => {
      const cleanedUrl = url.replace(/^(['"])(.*?)\1$/, "$2");
      const urlParts = cleanedUrl.split("/");
      const nameWithVersion = urlParts[5];
      const [name, version2] = nameWithVersion.split("@");
      const publisher = urlParts[4];
      return {
        publisher,
        name,
        url: cleanedUrl,
        version: version2
      };
    });
    const pluginURLsWithLatestVersion = await Promise.all(
      pluginURLsParsed.map(async (pluginURL) => {
        const latestVersion = await getLatestVersion(pluginURL.publisher + "/" + pluginURL.name);
        return {
          ...pluginURL,
          latestVersion
        };
      })
    );
    const pluginURLsToBeUpdated = pluginURLsWithLatestVersion.filter(
      (pluginURL) => pluginURL.version !== pluginURL.latestVersion
    );
    const pluginURLsAlreadyUpToDate = pluginURLsWithLatestVersion.filter(
      (pluginURL) => pluginURL.version === pluginURL.latestVersion
    );
    for (const pluginURL of pluginURLsAlreadyUpToDate) {
      log.info(
        `\u{1F4E6} ${bold(`${pluginURL.publisher}/${pluginURL.name}`)} is already up to date at v${italic(
          `${pluginURL.version}`
        )}`
      );
    }
    if (pluginURLsToBeUpdated.length === 0) {
      log.success("\u{1F389} All plugins are already up to date.");
      return;
    }
    for (const pluginURL of pluginURLsToBeUpdated) {
      log.info(
        `\u{1F4E6} ${bold(`${pluginURL.publisher}/${pluginURL.name}`)} will be updated from v${italic(
          `${pluginURL.version}`
        )} to v${italic(`${pluginURL.latestVersion}`)}`
      );
    }
    const pluginURLsWithUpdatedVersion = pluginURLsWithLatestVersion.map((pluginURL) => {
      const updatedURL = updatePluginVersion(pluginURL.url, pluginURL.latestVersion);
      return {
        ...pluginURL,
        updatedURL
      };
    });
    const updatedConfig = pluginURLsWithUpdatedVersion.reduce((acc, pluginURL) => {
      return acc.replace(pluginURL.url, pluginURL.updatedURL);
    }, config3);
    await writeFile(filePath, updatedConfig);
    log.success(`\u{1F389} ${configFile} updated successfully.`);
  } catch (err) {
    log.error("\u274C Failed to update plugin versions:", err);
  }
}
function readConfigFile(filePath) {
  return new Promise((resolve2, reject) => {
    fs5.readFile(filePath, "utf8", (err, data) => {
      if (err) {
        reject(err);
        return;
      }
      try {
        resolve2(data);
      } catch (err2) {
        reject(err2);
      }
    });
  });
}
function extractPluginUrls(code) {
  const urlRegex = /(["'])(https?:\/\/.*?)(?=\1)/g;
  return [...code.matchAll(urlRegex)].map((match) => match[0]).map((url) => url.replace(/^["']/, ""));
}
function updatePluginVersion(url, newVersion) {
  const versionRegex = /(@[\w.-]+)(?=\/dist\/index.js)/;
  return url.replace(versionRegex, `@${newVersion}`);
}
function writeFile(filePath, data) {
  return new Promise((resolve2, reject) => {
    fs5.writeFile(filePath, data, (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve2();
    });
  });
}

// src/commands/config/validate.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var validate = new Command().command("validate").description("Validate the inlang config.").action(validateCommandAction);
async function validateCommandAction() {
  try {
    const [config3, errorMessage] = await getConfig({ options: cli.opts() });
    if (errorMessage) {
      log.error(errorMessage);
      return;
    }
    log.info("\u{1F50E} Validating the config file...");
    await parseConfig({ config: config3 });
    log.success("\u{1F389} Inlang config is valid!");
  } catch (error) {
    log.error(error);
  }
}

// src/commands/config/index.ts
var config = new Command().command("config").description("Commands for managing the config file.").argument("<command>").addCommand(init).addCommand(validate).addCommand(update);

// src/commands/machine/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/machine/translate.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/query/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var _MessageAlreadyExistsException_id;
var _MessageDoesNotExistsException_id;
function query(resource) {
  return {
    /**
     * Creates a message in a resource.
     *
     * Returns an error if the message already exists, or the resource
     * does not exist.
     */
    create: (args) => create(resource, args),
    /**
     * Get a message.
     *
     * Returns undefined if the message does not exist.
     */
    get: (args) => get(resource, args),
    /**
     * Updates a message.
     *
     * Returns an error if the message does not exist.
     */
    update: (args) => update2(resource, args),
    /**
     * Upserts a message.
     */
    upsert: (args) => upsert(resource, args),
    /**
     * Delete a message.
     *
     * Returns an error if the message did not exist.
     */
    delete: (args) => _delete(resource, args),
    /**
     * Included message ids in a resource.
     */
    includedMessageIds: () => includedMessageIds(resource)
  };
}
var MessageAlreadyExistsException = class extends Error {
  constructor(messageId, resourceId) {
    super(`Message '${messageId}' already exists in resource '${resourceId}'.`);
    _MessageAlreadyExistsException_id.set(this, "MessageAlreadyExistsException");
  }
};
_MessageAlreadyExistsException_id = /* @__PURE__ */ new WeakMap();
function create(resource, args) {
  const copy = JSON.parse(JSON.stringify(resource));
  if (get(copy, { id: args.message.id.name })) {
    return [
      void 0,
      new MessageAlreadyExistsException(args.message.id.name, resource.languageTag.name)
    ];
  }
  copy.body.push(args.message);
  return [copy, void 0];
}
function upsert(resource, args) {
  const existingMessage = get(resource, { id: args.message.id.name });
  if (existingMessage) {
    const [updatedResource2, exception2] = update2(resource, {
      id: args.message.id.name,
      with: args.message
    });
    if (exception2) {
      return [
        void 0,
        Error("Message from an update is undefined. Even though an if statement checked is the message existed. This is an internal bug in inlang.", { cause: exception2 })
      ];
    }
    return [updatedResource2, void 0];
  }
  const [updatedResource, exception] = create(resource, args);
  if (exception) {
    throw Error("Message already exists even though we checked if a message exists. This is an internal bug in inlang.", { cause: exception });
  }
  return [updatedResource, void 0];
}
function get(resource, args) {
  const message = resource.body.find((message2) => message2.id.name === args.id);
  if (message) {
    return JSON.parse(JSON.stringify(message));
  }
  return void 0;
}
var MessageDoesNotExistsException = class extends Error {
  constructor(messageId, resourceId) {
    super(`Message '${messageId}' does not exist in resource '${resourceId}'.`);
    _MessageDoesNotExistsException_id.set(this, "MessageDoesNotExistsException");
  }
};
_MessageDoesNotExistsException_id = /* @__PURE__ */ new WeakMap();
function update2(resource, args) {
  const copy = JSON.parse(JSON.stringify(resource));
  for (const [i2, message] of resource.body.entries()) {
    if (message.id.name === args.id) {
      copy.body[i2] = args.with;
      return [copy, void 0];
    }
  }
  return [void 0, new MessageDoesNotExistsException(args.id, resource.languageTag.name)];
}
function _delete(resource, args) {
  const copy = JSON.parse(JSON.stringify(resource));
  for (const [i2, message] of resource.body.entries()) {
    if (message.id.name === args.id) {
      copy.body.splice(i2, 1);
      return [copy, void 0];
    }
  }
  return [void 0, new MessageDoesNotExistsException(args.id, resource.languageTag.name)];
}
function includedMessageIds(resource) {
  return resource.body.map((message) => message.id.name);
}

// ../rpc/src/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_client();

// src/commands/machine/translate.ts
var translate = new Command().command("translate").option("-f, --force", "Force machine translation and skip the confirmation prompt.").description("Machine translate all resources.").action(translateCommandAction);
async function translateCommandAction() {
  try {
    const options = translate.opts();
    if (!options.force) {
      const promptly = await Promise.resolve().then(() => __toESM(require_promptly(), 1));
      log.warn(
        "Machine translations are not very accurate. We advise you to only use machine translations in a build step to have them in production but not commit them to your repository. You can use the force flag (-f, --force) to skip this prompt in a build step."
      );
      const answer = await promptly.prompt("Are you sure you want to machine translate? (y/n)");
      if (answer !== "y") {
        log.info("\u{1F6AB} Aborting machine translation.");
        return;
      }
    }
    const [config3, errorMessage] = await getConfig({ options: cli.opts() });
    if (!config3) {
      log.error(errorMessage);
      return;
    }
    let resources = await config3.readResources({ config: config3 });
    const referenceLanguage = config3.referenceLanguage;
    const referenceLanguageResource = resources.find(
      (resource) => resource.languageTag.name === referenceLanguage
    );
    const messageCounts = countMessagesPerLanguage(resources);
    log.info(
      "\u{1F30F} Found " + Object.keys(messageCounts).length + " languages with a total of " + Object.values(messageCounts).reduce((a, b) => a + b, 0) + " messages."
    );
    const languagesToTranslateTo = resources.filter(
      (resource) => resource.languageTag.name !== referenceLanguage
    );
    log.info(
      "\u{1F4DD} Translating to " + languagesToTranslateTo.length + " languages. [" + [...new Set(languagesToTranslateTo)].map((language) => language.languageTag.name).join(", ") + "]"
    );
    for (const language of languagesToTranslateTo) {
      for (const message of referenceLanguageResource.body) {
        if (language.body.some((langMessage) => langMessage.id.name === message.id.name)) {
          continue;
        }
        const [translation, exception] = await rpc.machineTranslate({
          referenceLanguage,
          targetLanguage: language.languageTag.name,
          text: message.pattern.elements[0].value
        });
        if (exception) {
          log.error("Couldn't translate message " + message.id.name + ". ", exception.message);
          continue;
        }
        log.info(
          getFlag(language.languageTag.name) + " Translated message " + bold(message.id.name) + " to " + italic(translation)
        );
        const newMessage = {
          type: "Message",
          id: { type: "Identifier", name: message.id.name },
          pattern: {
            type: "Pattern",
            elements: [{ type: "Text", value: translation }]
          }
        };
        const languageResource = resources.find(
          (resource) => resource.languageTag.name === language.languageTag.name
        );
        if (languageResource) {
          const [newResource, exception2] = query(languageResource).upsert({
            message: newMessage
          });
          if (exception2) {
            log.error("Couldn't upsert new message. ", exception2.message);
          }
          resources = resources.map((resource) => {
            if (resource.languageTag.name === language.languageTag.name && newResource) {
              return newResource;
            }
            return resource;
          });
        }
      }
    }
    await config3.writeResources({
      config: config3,
      resources
    });
    log.info("\u2705 Translated all messages.");
  } catch (error) {
    log.error(error);
  }
}

// src/commands/machine/index.ts
var machine = new Command().command("machine").description("Commands for automating translations.").argument("<command>").addCommand(translate);

// package.json
var version = "0.13.3";

// src/main.ts
var import_consola2 = __toESM(require_consola(), 1);

// src/services/error-monitoring/implementation.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var Sentry = __toESM(require_cjs4(), 1);

// src/env.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var {
  isProduction
} = (
  // @ts-expect-error - defined in the build step
  define_ENV_DEFINED_IN_BUILD_STEP_default
);

// src/services/error-monitoring/implementation.ts
function initErrorMonitoring() {
  Sentry.init({
    dsn: "https://b7a06c6d36454ef2bc5e2ca7e257bd5b@o4504345873285120.ingest.sentry.io/4505172745650176",
    release: version,
    // Not interested in performance data
    tracesSampleRate: 0,
    environment: isProduction ? "production" : "development"
  });
}

// src/commands/open/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/open/editor.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
import { exec } from "node:child_process";

// src/utilities/getGitRemotes.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../source-code-git/client/dist/raw/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_isomorphic_git = __toESM(require_isomorphic_git(), 1);

// ../../node_modules/isomorphic-git/http/web/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../source-code-git/client/dist/raw/index.js
var raw = import_isomorphic_git.default;

// src/utilities/getGitRemotes.ts
import fs6 from "node:fs";
async function getGitRemotes() {
  try {
    const remotes = await raw.listRemotes({
      fs: fs6,
      dir: await raw.findRoot({ fs: fs6, filepath: process.cwd() })
    });
    return remotes;
  } catch (e2) {
    return void 0;
  }
}

// ../telemetry/src/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../telemetry/src/implementation/browser.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_posthog_js = __toESM(require_module2(), 1);
init_dist2();

// ../telemetry/src/implementation/shared.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ROUTE_PATH = "/_tm";

// ../telemetry/src/implementation/browser.ts
var telemetryBrowser = new Proxy(import_posthog_js.posthog, {
  get(target, prop) {
    if (prop === "init") {
      return initWrapper;
    } else if (publicEnv.PUBLIC_POSTHOG_TOKEN === void 0) {
      return () => void 0;
    }
    return target[prop];
  }
});
function initWrapper(config3, name) {
  if (window === void 0) {
    return console.warn(
      "You are likely trying to use this in a Node.js environment. Use telemetryNode instead."
    );
  } else if (config3 == null ? void 0 : config3.api_host) {
    return console.warn("The api_host is set by the telemetry module.");
  } else if (publicEnv.PUBLIC_POSTHOG_TOKEN === void 0) {
    return console.warn("Posthog token is not set. Telemetry will not be initialized.");
  }
  return import_posthog_js.posthog.init(
    publicEnv.PUBLIC_POSTHOG_TOKEN,
    {
      api_host: ROUTE_PATH,
      capture_performance: false,
      ...config3
    },
    name
  );
}

// ../telemetry/src/implementation/node.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_posthog_node = __toESM(require_index_cjs(), 1);
init_dist2();
var posthog2;
var telemetryNode = new Proxy({}, {
  get(target, prop) {
    if (posthog2) {
      return posthog2[prop];
    } else if (!posthog2 && publicEnv.PUBLIC_POSTHOG_TOKEN) {
      posthog2 = new import_posthog_node.PostHog(publicEnv.PUBLIC_POSTHOG_TOKEN, {
        host: "https://eu.posthog.com"
      });
      return posthog2[prop];
    }
    return () => void 0;
  }
});

// ../telemetry/src/utilities/parseOrigin.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
function parseOrigin(args) {
  var _a;
  const origin = (_a = args.remotes) == null ? void 0 : _a.find((elements) => elements.remote === "origin");
  if (origin === void 0) {
    return "unknown";
  }
  let result = origin.url;
  if (result.endsWith(".git") === false) {
    result += ".git";
  }
  result = transformRemote(result);
  return result;
}
function transformRemote(remote) {
  const regex = /(?:https:\/\/|@|git:\/\/)([^/]+)\/(.+?)(?:\.git)?$/;
  const matches = remote.match(regex);
  if (matches && matches[1] && matches[2]) {
    let host = matches[1].replace(/:/g, "/");
    const repo = matches[2];
    host = host.replace(/ghp_[\w]+@/, "");
    return `${host}/${repo}.git`;
  }
  return "unknown";
}

// ../telemetry/src/shared-events/coreUsedConfigEvent.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var coreUsedConfigEvent = {
  name: "CORE used config",
  // typesafe properties
  properties: (config3) => config3
};

// src/commands/open/editor.ts
var editor = new Command().command("editor").description("Open the Inlang editor for the current repository.").action(editorCommandAction);
async function editorCommandAction() {
  const gitOrigin2 = parseOrigin({ remotes: await getGitRemotes() });
  if (!gitOrigin2) {
    log.error("Failed to get the git origin.");
    return;
  }
  log.info(`Origin URL: ${gitOrigin2}`);
  const githubUrl = parseGithubUrl(gitOrigin2);
  if (!githubUrl) {
    log.error("Failed to parse the GitHub URL from the remote URL.");
    return;
  }
  const inlangEditorUrl = `https://inlang.com/editor/${githubUrl}`;
  let command;
  let args;
  if (process.platform === "win32") {
    command = "start";
    args = [inlangEditorUrl];
  } else if (process.platform === "darwin") {
    command = "open";
    args = [inlangEditorUrl];
  } else {
    console.error("Unsupported platform.");
    return;
  }
  exec(`${command} ${args.join(" ")}`, (error) => {
    if (error) {
      log.error("Failed to open the Inlang editor.", error.message);
      return;
    }
    log.info("\u2705 Opened the Inlang editor for the repository.");
  });
}
var parseGithubUrl = (url) => {
  const regex = /^(?:https?:\/\/)?(?:www\.)?github\.com\/([\w-]+\/[\w-]+)(?:\.git)?$/;
  const match = url.match(regex);
  if (match && match[1]) {
    return `github.com/${match[1]}`;
  }
  return void 0;
};

// src/commands/open/index.ts
var open = new Command().command("open").description("Commands for open parts of the inlang ecosystem.").argument("<command>").addCommand(editor);

// src/services/telemetry/implementation.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
init_dist2();
var import_posthog_node2 = __toESM(require_index_cjs(), 1);
var gitOrigin = parseOrigin({ remotes: await getGitRemotes() });
var posthog3 = new import_posthog_node2.PostHog(publicEnv.PUBLIC_POSTHOG_TOKEN, {
  host: "https://eu.posthog.com",
  // Events are not captured if not immediately flushed.
  //
  // Posthog shouldn't batch events because CLI commands
  // are short-lived, see https://posthog.com/docs/libraries/node.
  flushAt: 1,
  flushInterval: 0
});
var telemetry = new Proxy(posthog3, {
  get(target, prop) {
    if (publicEnv.PUBLIC_POSTHOG_TOKEN === void 0) {
      return () => void 0;
    } else if (prop === "capture") {
      return capture;
    }
    return target[prop];
  }
});
function capture(args) {
  return posthog3.capture({
    ...args,
    distinctId: "unknown",
    groups: {
      repository: gitOrigin
    }
  });
}

// src/commands/lint/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/lint/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/lint/createLintRule.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/lint/query.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function getLintReports(node, options) {
  if ((options == null ? void 0 : options.nested) !== void 0) {
    console.warn("The `nested` option is deprecated. Use `recursive` instead for better clarity.");
  }
  const withDefaults = { recursive: true, ...options };
  if (Array.isArray(node)) {
    return node.flatMap((n) => getLintReports(n, withDefaults));
  }
  const { type } = node;
  switch (type) {
    case "Resource":
      return withFilters(getLintReportsFromResource(node, withDefaults), withDefaults);
    case "Message":
      return withFilters(getLintReportsFromMessage(node, withDefaults), withDefaults);
    case "Pattern":
      return withFilters(getLintReportsFromPattern(node), withDefaults);
    default:
      throw new Error(`Unhandled linted node type: ${type}. You stumbled upon a bug in inlang's source code. Please open an issue on GitHub`);
  }
}
var getLintReportsFromResource = ({ lint: lint3, body }, options) => [
  ...lint3 || [],
  ...options.recursive || options.nested ? body.flatMap((message) => getLintReportsFromMessage(message, options)) : []
];
var getLintReportsFromMessage = ({ lint: lint3, pattern }, options) => [
  ...lint3 || [],
  ...options.recursive || options.nested ? getLintReportsFromPattern(pattern) : []
];
var getLintReportsFromPattern = ({ lint: lint3 }) => lint3 || [];
var withFilters = (report, options) => {
  return report.filter((report2) => {
    if (options.id && report2.id !== options.id) {
      return false;
    } else if (options.level && report2.level !== options.level) {
      return false;
    }
    return true;
  });
};

// ../core/dist/lint/linter.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../core/dist/lint/report.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var createReportFunction = (_args) => {
  return (args) => {
    if (!args.node)
      return;
    args.node.lint = [
      // copy existing lint reports
      ...args.node.lint ?? [],
      // add the new lint report to the node
      {
        id: _args.id,
        level: _args.level,
        message: args.message
      }
    ];
  };
};

// ../core/dist/lint/linter.js
var getResourceForLanguage = (resources, language) => resources.find(({ languageTag }) => languageTag.name === language);
var lint = async (args) => {
  const { referenceLanguage, languages, lint: lint3 } = args.config;
  const resources = structuredClone(args.resources);
  if (lint3 === void 0 || lint3.rules.length === 0) {
    return [args.resources, []];
  }
  const reference = getResourceForLanguage(resources, referenceLanguage);
  const errors = [];
  await Promise.all(lint3.rules.flat().map((rule) => processLintRule({
    rule,
    referenceLanguage,
    languages,
    reference,
    resources
  }).catch((e2) => errors.push(new Error(`Unexpected error in lint rule '${rule.id}'`, { cause: e2 })))));
  return [resources, errors.length > 0 ? errors : void 0];
};
var processLintRule = async (args) => {
  const { referenceLanguage, languages, reference, resources } = args;
  const report = createReportFunction(args.rule);
  const { visitors } = await args.rule.setup({ config: { referenceLanguage, languages }, report });
  for (const language of languages) {
    await processResource({
      reference,
      target: getResourceForLanguage(resources, language),
      visitors
    });
  }
};
var shouldProcessResourceChildren = (visitors) => !!visitors.Message || shouldProcessMessageChildren(visitors);
var processResource = async ({ visitors, target, reference }) => {
  const payload = visitors.Resource && await visitors.Resource({ target, reference });
  if (payload === "skip") {
    return;
  }
  if (shouldProcessResourceChildren(visitors)) {
    const processedReferenceMessages = /* @__PURE__ */ new Set();
    for (const targetMessage of (target == null ? void 0 : target.body) ?? []) {
      const referenceMessage = reference == null ? void 0 : reference.body.find(({ id }) => id.name === targetMessage.id.name);
      await processMessage({
        visitors,
        reference: referenceMessage,
        target: targetMessage
      });
      if (referenceMessage) {
        processedReferenceMessages.add(referenceMessage.id.name);
      }
    }
    const nonVisitedReferenceMessages = reference == null ? void 0 : reference.body.filter(({ id }) => !processedReferenceMessages.has(id.name));
    for (const referenceNode of nonVisitedReferenceMessages ?? []) {
      await processMessage({
        visitors,
        reference: referenceNode,
        target: void 0
      });
      processedReferenceMessages.add(referenceNode.id.name);
    }
  }
};
var shouldProcessMessageChildren = (visitors) => !!visitors.Pattern;
var processMessage = async ({ visitors, target, reference }) => {
  const payload = visitors.Message && await visitors.Message({ target, reference });
  if (payload === "skip") {
    return;
  }
  if (shouldProcessMessageChildren(visitors)) {
    await processPattern({
      visitors,
      reference: reference == null ? void 0 : reference.pattern,
      target: target == null ? void 0 : target.pattern
    });
  }
};
var processPattern = async ({ visitors, target, reference }) => {
  const payload = visitors.Pattern && await visitors.Pattern({ target, reference });
  if (payload === "skip") {
    return;
  }
};

// src/commands/lint/index.ts
var import_cli_table3 = __toESM(require_cli_table3(), 1);
var lint2 = new Command().command("lint").description("Commands for linting translations.").option("--no-fail", "Disable throwing an error if linting fails.").action(lintCommandAction);
async function lintCommandAction() {
  var _a;
  try {
    const [config3, errorMessage] = await getConfig({ options: cli.opts() });
    if (!config3) {
      log.error(errorMessage);
      return;
    }
    if (((_a = config3.lint) == null ? void 0 : _a.rules) === void 0) {
      log.error(
        `\u{1F6AB} For this command to work, you need lint rules configured in your inlang.config.js \u2013 for example, the ${bold(
          "standard-lint-rule"
        )} plugin: https://github.com/inlang/inlang/tree/main/source-code/plugins/standard-lint-rules. ${italic(
          "Learn more about lints here:"
        )} https://inlang.com/documentation/lint`
      );
      return;
    }
    const resources = await config3.readResources({ config: config3 });
    const [resourcesWithLints, errors] = await lint({ resources, config: config3 });
    if (errors) {
      console.error(
        "\u{1F6AB} Lints partially failed. Please check if you have your lint rules configured correctly.",
        errors.length && errors
      );
    }
    const lints = getLintReports(resourcesWithLints);
    if (lints.length === 0) {
      log.success("\u{1F389} Linting successful.");
      return;
    }
    const lintTable = new import_cli_table3.default({
      head: ["Level", "Lint Rule", "Message"],
      colWidths: [12, 35, 50],
      wordWrap: true
    });
    let hasError = false;
    for (const lint3 of lints) {
      if (lint3.level === "error") {
        hasError = true;
        lintTable.push(["Error", lint3.id, lint3.message]);
      } else if (lint3.level === "warn") {
        lintTable.push(["Warning", lint3.id, lint3.message]);
      }
    }
    log.log("");
    log.log("\u{1F6A8} Lint Report");
    log.log(lintTable.toString());
    const summaryTable = new import_cli_table3.default({
      head: ["Level", "Count"]
    });
    summaryTable.push(["Error", lints.filter((lint3) => lint3.level === "error").length]);
    summaryTable.push(["Warning", lints.filter((lint3) => lint3.level === "warn").length]);
    log.log("");
    log.log("\u{1F4CA} Summary");
    log.log(summaryTable.toString());
    if (hasError && lint2.opts().fail) {
      log.log("");
      log.info(
        "\u2139\uFE0F  You can add the `--no-fail` flag to disable throwing an error if linting fails."
      );
      throw new Error("\u{1F6AB} Lint failed with errors.");
    }
  } catch (error) {
    log.error(error);
  }
}

// src/main.ts
if (typeof fetch === "undefined") {
  globalThis.fetch = fetch2;
}
initErrorMonitoring();
import_consola2.default.wrapConsole();
var cli = new Command().name("inlang").version(version).description("CLI for inlang.").addCommand(config).addCommand(lint2).addCommand(machine).addCommand(open).option("-c, --config <value>", "Path to the inlang.config.js file.").hook("postAction", (command) => {
  const name = command.args.filter(
    // shouldn't start with a flag and the previous arg shouldn't be a flag
    (arg, i2) => {
      var _a;
      return !arg.startsWith("-") && !((_a = command.args[i2 - 1]) == null ? void 0 : _a.startsWith("-"));
    }
  );
  telemetry.capture({
    event: `CLI command executed`,
    properties: {
      name: name.join(" "),
      args: command.args.join(" ")
    }
  });
});
telemetry.capture({
  event: "CLI started",
  properties: {
    version
  }
});
telemetry.groupIdentify({
  groupType: "repository",
  groupKey: gitOrigin,
  properties: {
    name: gitOrigin
  }
});
try {
  const [inlangConfig] = await getConfig({ options: cli.opts() });
  if (inlangConfig) {
    telemetry.capture({
      event: coreUsedConfigEvent.name,
      properties: coreUsedConfigEvent.properties(inlangConfig)
    });
  }
} catch (error) {
}
export {
  cli
};
//! do not return a reference to the message in a resource
//! modifications to the returned message will leak into the
//! resource which is considered to be unmutable.
/*! Bundled license information:

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
